{"_id":"ts-pattern","_rev":"142-ede5a5958dad9ab7be96e30047b379e7","name":"ts-pattern","dist-tags":{"latest":"5.0.6","next":"5.0.3-rc.2","test":"4.2.4-test.1"},"versions":{"0.0.1":{"name":"ts-pattern","version":"0.0.1","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run clean && npm run build","test":"jest"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"999e989350630a59c45ddab27f19e907ba950cf1","_id":"ts-pattern@0.0.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-Miqa85tNU9bbE9DaqZxH9Kg1Ljvz5STVvAy7K0AbSf42PRU2fvu1UvTZOeoPBTJXiUauo2/iyLiR5JmyhsU4qg==","shasum":"d6fd1813ad44cca4c9c731635e555bed285350cf","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.0.1.tgz","fileCount":10,"unpackedSize":28745,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeyqX8CRA9TVsSAnZWagAAzfAQAINovi3EY0Ka7IBvKKFv\nUxsaKM89w0yf5ukZJ604Z7daCZVuGJvJ/WVfG11oi2DAfYUVPGEOzgdbOIfA\nnC6opZ8FcWAr6owui/NuuT3Pz9cEm4ChU96NZLfcCFLkrprBOqbm1rUE7x7x\nxZASgaL7IywGVsk/B2aYv0nn+JVd/ETGZgmvoR0QR6sTNUnLRdDfoNk4RUsI\nDEU5kq4p6r2YIq/xxLZGLwwNL3oNHhaLooWdaAugaCLrkDmlRop1MeNifu9F\ngorCZcx4/d8kKj11m4zZF3c7OHIgtJYG5BL8QEN5ltIVugl+3uZz2IB4MCoV\nVB8E51CekBOUsLQ8W9GsSpR0+MKiujB/+DFv9zi3SSYQKBlsJJHcLLgO+adM\np3+EVVCuTUAq3AVRDQqpe31NDoRJtgo43jRiCe8I32bFtDGwjeWtUUcqrzju\nZCZB7pBS/170d94IwWhgFOOZX4MT0dIJ+zo1t/O1Qm9ue/P8BjfAbipysxA6\nmKj9qxNfBYS2RbTASCHF/z2OeAMOgbHOR/V3J778LX1HJvyG024XtR+ai9xt\n/5mmz6K0X5UJOOucHU6BSY3nJIwdFWphXfCrqG8y4Nl45fbaFuL8PYeA2Jjh\nSkA803kRlfXq6I0hdUVepQzo5yGXvzOES1z9zOySf9+v/lh5Gz5uCjK+/m9V\n9U1k\r\n=UZTQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD6Vaj0Z+IjMKIbr8+59i0Wr/M9FYRX5Q/OvoTxIwcrTgIhAImQeuPpnAJu/cZ58Z6KYppJwbt38YWc9v/R+/sFXleN"}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.0.1_1590339067831_0.19579316378910483"},"_hasShrinkwrap":false},"0.0.2":{"name":"ts-pattern","version":"0.0.2","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run clean && npm run build","test":"jest"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"8cf3100dfa32cedeb800b904c6b86500b76a6724","_id":"ts-pattern@0.0.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-DSugoM0DQBNQp6Xvwt7IFMDAOmbQtO2CUyS1mcAFLMq4VVIoBE0Ppi3xooQccc1qTOCRrrPXG/QHSWrhjbofLg==","shasum":"5d1398d217addd156d5f33f0ceb21a31701eb730","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.0.2.tgz","fileCount":10,"unpackedSize":29735,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeyqg3CRA9TVsSAnZWagAA4qkP/3ndIhWoxRhpHA5L34w5\nZvshV6KOIm2xitLmIBF6sZddj/mC3q2DsuUodd2SIl8HRhHFUqMwFcaUjoZn\nHXueegOMMV7yy4GM0/oXEB66kPSrzEKgAa7qyJnBbwGxfIMr+IGlDwyjFUhF\nMcPXfva+wNIZRGedQrYxMmY3f9oO7uefejDe8zOqBm+twd3ZrHnO5Sil1wBp\nBF3foKXDCiIkY/fZOK4aClCFFvEo7Sq44eQPEKRk+Ho76sSfP2E9a68pzjFK\nRa+0N4gRYZfBgzrNeqV8/sgJUGBh3FDk6QVXeSP5dtnjRoMoZtwOQ6dNF8iA\nLSJTv6GCo/2l5tyPc6L3Xyn51JoQTZfOl089Q5oALhZwNRdysRUCQQI8cE8R\nrHVG2P9+VqdGjNvUPhFJvUai5JNVt7gQibghy5e1JSxe3PVu/GxR1Eg0GrZ1\n5MuFKXUgdgpH8xZg4zVtetmYMUmKWKqOAANJO2gx23Q0EGWeUxcjSsOZ28HG\n/vOZazxIF9WJtgXWu8w/w8W5Q2neMAuoV/U+Qg5f7AOeRiQ70Av5dgWvLQhA\nXwKPZ1LC85t1SpUyTjgRWagvXNH86DZJTijXQ+nSlQQ4yeQKgK8ifSox94ZO\nfiqUdTb/Vq3Em0iKJEBJxpAKCb5vXsPC4W918D+KNKvzkd3PyJWxB+NkBcfT\ndAFE\r\n=o9E/\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC7oPfmfuJz7un5/iQY9W1SQ2pOUsOyoOkTqniPKm2PxQIhAKXoY3/QgH57NCsDdPa5Z7TJcsfI0JCOw34zaNTf3I83"}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.0.2_1590339639393_0.9993162216658735"},"_hasShrinkwrap":false},"0.0.3":{"name":"ts-pattern","version":"0.0.3","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test":"jest"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"9aee8c141206f8aed337e7265476bb8c2ca72373","_id":"ts-pattern@0.0.3","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-NrlSqHl8wNN/i7q507xj6SgHwGJIQ8MY/sDwi5ABF3lFSG3izlXQoHVJHopcqIOdhYs6Wz+UmXrqBp8nVrUFDA==","shasum":"011b90f7fb0c8072ad22f4fff9f8c3bd83541a19","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.0.3.tgz","fileCount":10,"unpackedSize":30261,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeyvCqCRA9TVsSAnZWagAAAngP/i609Bq6GoSYo7k7WlxI\nf8SC/omrQG44kIPl2f8AmuBYmlqIeqT74xIJGiGpM0KlIkQUepP/80r0C1GT\n6JUDWdAEg8Wkn9yXHn8tMj+K6U4zwhgV9hl9eOcn7GivzywZcbZ8CazydFVN\nqjbTJa24Rv6LpiQFpPQwbuTxC8QcytsZBP8ivQ7cylufFgU0f5fCl7VfYRU0\n/SYQERqeNVbVdWbPPDzDVRy5hws/iVAO8mJ1nfoBBiW8xgL2aIlYviFFQk/l\nw5POnwDuIos8zq040lR0AaHn+iR3p2NLY9xUf7uuKRRLVHQnd0Do+kctsV4c\ngJEdOaGXDbhwaaapWSZpnPDbDn9wWFZSXl+mtZfqSgWt60Nvk5KGgfylFaIJ\nb1vIKdXwIiGE567zcrQCEUu6lyPygZk9T6ZKEXzKK9xhHfIiOTTnck4uvQYd\n+6NyFLYr9EAke8MdtyKvukJLYDI5047OoebnO89xaLkTUZmfNQS8uddnDSVo\nNzAY+IsOLkzz680kSPm78mKJGqff4HejNmJECx1j1vxH0WrH6dnx9A2dy10s\nBBPev/F+/8YvUw80A7lh3sYVgT/UDD/vnOcaAa5Lrsv8MO98xqvKhwISn7Vv\nwEVTlwI2RNjcixwLkjmOSKs5Dal1yJo641EmdLzHUxCzha4g7vL+jDotSoS4\nbMGE\r\n=d6it\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIG4s9LpWd3s4Z+vnhmw9IWp9qaK6gYZ4XXwQlqgYhWcBAiEAnRFy3WTtBYrOnTtaW/q99Ce1zC3eG01FIK3DNzazRSg="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.0.3_1590358186387_0.5676011465868893"},"_hasShrinkwrap":false},"0.0.4":{"name":"ts-pattern","version":"0.0.4","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test":"jest"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"a5adf82dac87144e220a33b9a2b02f86f30e3798","_id":"ts-pattern@0.0.4","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-yO0kdExaDRMmtmfGTin7lZUv+xOl8AUQFSzcZKas0QFNELrbKhKjvK3HYySMyYso5hKNDAEf1VsG+wB4ZYFXXQ==","shasum":"9222b62e7874a89bda76e55f2ce1f85b240702a3","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.0.4.tgz","fileCount":10,"unpackedSize":31530,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeyvLHCRA9TVsSAnZWagAAX/oP/Rai966L+QQaC4oDnLUo\ngEWZdeJdyYR+U9E1kf0BZakj88HiPa1BTHuk1QU4xOUA+kc16HAp9chRYxXl\nnF/OkBhJQo1oz3HIvx4cfaGxwlJ5xiH0sfuSwlZ5n4uuVdtZlLKMkF7H+J53\nrfPffV9HeSXXnkY21wbLQx0J20PjeyXG6RzdGSFKVl971d69rSe/K3V/TIHC\nbx/CDRjasCOMoFBLIbTTl9pZ67ncFmhgTAy8Z5xTQQG1+a3FxgRjzDTRUJsL\nFWTO7wHEB5n8cIvH/3NphSf10AtOIYMeur9fN1RsNoCI0U9CUDqD3FzY+/4U\n6gC8W+34Bb3ZcLWcB9pgZuilWInt8gIUrrjD99G4dp63SWQC68J+D29Ys9Y9\nnkM71FyOW18fS2zxH0BwX6avuzlp6zWidssshz/jEnPXxyBVp5zw7Bbr4J2H\ndmn/CljjteRQd+9ekDoIqnHpuFtMyHGeaOYVuCdb0hX+ljvMSqbMiN50IniB\noI7JZQJyLcFI7H53TOvD1o4fhKDY23ZGZVKqE/Xdr3C/Xy0r50Xuuj2sAIym\ngCO3osJU05lbsaRxWxDnC2ZCvOG76LFHBCqmtcmOYwzfRxY40Ot00Pa/tNWK\nJMYon1RBhywiFhBPA3pmWJXGkFmHFC/w0udvBtKNqwZeB/64KxnK8JOosV8G\nI1Fd\r\n=5V72\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHkbzF3PZmZYN9EJszU/xFqPG2QZB2u3BiPS1XAcmlCkAiEArxuAduX5R5js73/goFMNczFPF3MGWOpIqYhuM5qKu5Y="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.0.4_1590358727449_0.6998395222695426"},"_hasShrinkwrap":false},"0.1.0":{"name":"ts-pattern","version":"0.1.0","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test":"jest"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"215206dc030bc510e45734ea6300a0f4a93d4a4a","_id":"ts-pattern@0.1.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-LMunuxfLKe3Dqpe0ckKrUztV1Nav+iMp9NpHCS9spCzHpvCxbpopL4oh4lh5o8k8ysLeYusOcgvlGEDNnGsFtA==","shasum":"dd2dbad714be87d558df81d34046b2f44e028299","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.0.tgz","fileCount":10,"unpackedSize":32072,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJey47LCRA9TVsSAnZWagAA6n0P/0B7SzLFRnAPSesD4XI8\nXa4ihnGdHQdkzI+ptc51dCdjK36cRouecyEU8jCbVuqRdRw5q9Wg/QBEkXeL\nDOTDzFiVOp2/4+Os8u3/8U0UkeZyVyKPq+V+t4zPco8G5v3sKNfHxC9nBqY/\nk0WeTT3I32w1Hr8V86AeMcR1qAAZnjyA+UJrb03r6CDMcEkJ7TcjzXsQ/8Tj\nIE/k7ZIluV5zWe7kX9Zb94EJbboMWrLrcZF9IuPmeI+HNQoc/fqlGmqoU5Sa\nlJdVMxDCjwYVMS5pR0gS9WvjDbJxnlYwe7zBTN7V1v3DJHN+gJEDRnf7K3E8\nm/NLX+4YXBtOqxnYcLIj1o9y2dMmluY+bbTlXowFroTXV2A8fTHzB5CRiD0s\n1Cfz+me7Vu2M7A0xQrlWSnZ0SO9m5SoF76hLTcx77oMtr+ejbYUpDHLRJs4F\nEFmqfQ2U9rABVNMpxKwQM/MfHRx2pLOmisjHMI3Sn3/FGsiClt7R5PHwrOP9\noAfKXyXKS/irzgDTOfB78nRTamtDAiyWW86i2mXXGjc9QRtKLa8YUjizfxE4\nhTW8fSzrqEcTwezKLezvjRi0adPvMm1Y/ujTGNIqHbcjVhVxE6dWCQB86jOG\ndLE8Hc77HFXIhYVf2rtsQ9yZxCz7wo0IG2m1qeEFhSlD8unmebley85qBeEW\neKnO\r\n=Tfhn\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHqsw1nN3ZpRTrONNEH5iHQsXQpfS54OhNo0+P/Q1DFHAiB2l/UdrsMdGMzcoKg/kGeOQnAMOQjfE+8B5xP8wu4HBA=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.0_1590398667597_0.04506229507862569"},"_hasShrinkwrap":false},"0.1.1":{"name":"ts-pattern","version":"0.1.1","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"68b2e7c3e8e1a409b0596fb15225e19e0b4dbfdb","_id":"ts-pattern@0.1.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-7sHUMJ1ogJACezunjtnii/RTEp8bxc/4fCSQXG4UYloR8itr8HRkfRtRClB9G7K/y1p7JKq0O+7XJwKrBuHPQA==","shasum":"577635f75f8c7a539f0b0eb23b1f78460b268990","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.1.tgz","fileCount":10,"unpackedSize":32660,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJey5IlCRA9TVsSAnZWagAAongQAI8foUtJANP8m2B2eENG\nd0Re1kVNxzEBufREGwpPBsGKlUN93aSTeziLXDDgNYEKm601XQlF3GkrVHa4\nClI8896rbV+lVIIW2ZRzWH6byVBXX5CThPHa7ukDOuOl85o0YM3/x1sY5bAj\nvejofpGhIt7obbrM/nAB8ulrRq0TQWMqmQisppbrAW4haxabXEB3cRaEAB7L\nVq9mZAdPuOAH28uNZPUAlTebLl+8BLxn/Wfy4sy36A1hMNuHkN0F6dvNQQMn\nxRpHKnYLG5dvEHfcoS2bQSRNd6Xu5YZdWZo7oARxhzNbLH8U2IM7QUVAuLCH\nDE8VZ1OgrwziyRlad+0o5r7PbiZz9KpNxR5Tx8vZFu9lQnryWe41eLgyvo6I\nHgOVEjZ7VNUO9xwG9uJ7WkQQdoXvOFuzJhyRPbLbKRpIe2MQVI3mDKLC/tNG\nIUTKplkoR6udCvMx21EIMfZi7VB2uMgBMcsCnLBIwdQjl/XRRuWuQGGBF/Cw\nWSlCraEcE1KP6/zQjTB1VopV1Lhf387QUOEH1XSbOyU4NIWL2aojougaWEvO\nt9Uj5kogDdVmot6JXpVARVAQ42TzCdOVEnsoDrB/Vg9LxrStgMqoPShPyNlR\nIuQcoShHrZlZkGxjOu3VaRZqoy5YmIQqorEceLZE1+1Xgy9Tus29RFGMo1fe\nAvl3\r\n=E70X\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCrSnY0Go1Rwrd05lB9Yi07Q9g6B4JXdFg4WuOEcpXdGwIhAJm+lSnWvHBLc1suPBZPCAOCsJy+JCfc5GVoqpSDjV5h"}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.1_1590399524755_0.9023442720643535"},"_hasShrinkwrap":false},"0.1.2":{"name":"ts-pattern","version":"0.1.2","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"20aa7b2584f1265c19e34a1d785ba106e89bd882","_id":"ts-pattern@0.1.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-1VMGgzyMRPAFZxivOVdOPi7Uy2EV9ZyrOo/R52X+bj9ObFRYR143+4vnG5u0gaWC7SIhO4HjHVLwtE9/OV5tDA==","shasum":"a7f34159ea9fb8579c022750a7917ceb01b36390","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.2.tgz","fileCount":11,"unpackedSize":33102,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJey8HrCRA9TVsSAnZWagAAElcP/RzZgAINO/vc1saT+Sde\nEouebBkq77xFVe0YAvI8OZgszLH6ms729mGPT1FABxqrkWS8v27vl/wNfJHO\ndjCAkMfr+kl9T1IufxJZ5x7nI0Dveqf/3As/+dGgD0DG4zI0DgHzQFsMKO4l\nJUAt6eD+lfjnVnv8/IhRlKPS3KXg2b7l59O10dCjbqK6S2gOyvlCL/kJfCrG\nzV043P6Faijkz68Q0+uWYMusr1IACpbzqBi1MuWxCORZzr6PWV+RqvDtHIaI\n13yxZpz1dAusZstptn/Hq8MO4b85O0FyVQY34PgPQgtLAl2cMQj6qykxO+gV\n4McvaEcUZ/fdwgigtmaf4GnkodawStkPHYhHEh/HNKXzhmmJfNKaurSPVPun\nzVLxDfQIMswrU4rVqXip8JWGsTKo1RSMqyHfq+x30m6RFCeeQbF+XkH54Gqy\np7GDhFFjB8GQDQbK62bgru2dk+4TTDK5t0duo5EGrRXPLKmJHLvtl2RqhTAr\nXYakgzgDJ+kbxAzeVTbIk4LpYrrUYsxkf9oaqFSg2LltUPMVTZJMzEPV6fgn\ndrHdtA9pAa2jAHSp2EkSCxz0BsEAP8NdOgdTC8nlldgl/dM+QtvFJAbzOtqU\n03XSgfvXr7t0SRIVg8l3NzH6VY+hMbLf8nU2ecW9sDhGvMZX68YTqMyZThyl\n2Jce\r\n=uUtr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFWsBXoIVgZsdhHfI+miSRx9wBvCZ9uyWmMjXTNH6PmwAiEAuIrZISg7u+RiKDHpgf9uZj1X66jEmIgITYWS+k8J9Ak="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.2_1590411755033_0.9384187471419412"},"_hasShrinkwrap":false},"0.1.3":{"name":"ts-pattern","version":"0.1.3","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"e456d39d43e12c2958478eaf721f71e1e2bb403e","_id":"ts-pattern@0.1.3","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-qzSTXOgTJsBbXhHyBIFQcdKYTlduW2iLttCEyhMf0Im6C20KYMcOAW5xcHQiw7h2e8h6DOAeb92dnu9WbvuYBg==","shasum":"facdd095c49e218d6ec7d15706227616604d0266","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.3.tgz","fileCount":11,"unpackedSize":44286,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezNmSCRA9TVsSAnZWagAA9+MQAIwMBfCOvHvGcoJNSJbD\nmGnFOrV2K01bLRGqFjf6eBCnhqtNe8HxJuXo+FWjTX8TMxDSnpp/A4CvYpsI\nnhfqxXazwCBva9ZzI20LJ3ZOyy14M8DMgQx/D2ARvWKTNGO+zYHVRFNUNDBm\nNr2s2h7mVPSzns9fFX3fI0hEjDTI0UZ2mc3Na4acI4d9obzWO+Eg9hJu7dcs\nrmkGhLIahs/5QnkXBvnWlYpz94BrKROvJFOUIZdBErKnDC4UAW0ZTnGx0rMr\nTL8Ex0GOUOQD90bnpa0+eHtDdkX4B0ixH/kVyLlViWaMkSPAqHZp6cpMv4L5\nnFJ3oDMOAUe1yGM1UZEZczsB40ybWjX2NES3bC+xOPVQOON3yABO2X17K0Ol\n/8m8qYaQRMCCuFmwFfdxNkbgRe+QlTK0nxOr5pBH4ja7BBeLK36S0oytbO96\nJwyXGPN/bnSdmGV4MKsQlJc4cFzXb+cR1ZXK4UEUKKj7cNXHfIKJF414mPok\nLuZff/ZISXwMnAdFKVQAaT/A2jA6+WdZY+GjIBKxSqtaVSJjFfhMoTiHiK7X\n6YV22U+YdoOERRCooE+65U000Esy/1Cud6oK8DGAJTFwbykQbz7IFSJDHy6H\nvYepT26tsZ8PAP0rW5YYTFsSxuYIB8PLM0Yq2YMlfJ78+pt1jhtsib6l0qhs\n4vGl\r\n=Ak1E\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIF7NHFsBu09xUpSeROQ3FaxkuqDmd0Zon3P9AH5MLv3QAiEAxFly9F/4aikNBSbBoO90kbgfF5Lth3zNyQj9cXzHwIM="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.3_1590483345846_0.3968917158299541"},"_hasShrinkwrap":false},"0.1.4":{"name":"ts-pattern","version":"0.1.4","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"9cecd61bbc4f51128534d7c9f5bc9ce7c9977588","_id":"ts-pattern@0.1.4","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-/240a2v/JzmgpI8tn44hnUKzfFEBSR2Vd+dXsdSVL2bqpACnPAykxufRtZHREMTe9KkojmwTcRPQBtLDm3+uXQ==","shasum":"638e599a969c7eef7531cb4548f638e96d33f8b5","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.4.tgz","fileCount":11,"unpackedSize":53733,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezRKGCRA9TVsSAnZWagAA1n4P/0wCPXYM36DzyAbq+yFK\ntuqxi68k4R9NEpHHI7Qdxo0N2pIGcLy78VWs9VilpqrFnWiMNISTAWBJP94/\n63Qno6AanfDGjMcjBNEkFAwpij9j3iCAhxmyDsHXYpG5RrtAvIwRO1vPrnfR\nwrgJh4z8CpdWRBpxefV0X5v+tN86g20OiPYhgzz+I2i292ZwN4CPzT9glMnE\nKi8pMxZye1sDEBRO1jAilqQTCoDHZtzTPDPYi+P1m+/oeApOZtDoj6SS6dOA\nBuPQsdGUzKFKkV1ettZ/hKDrNPaHRhkITm7lDBeXcuvZqnB8vUbJMGdoim5G\nUtr1R1Ybi/jAYUqkiXvDUSXNHErUJGAR+fViLIx0dCzwtAYtLUSpv6VwjXWX\ncdg0Irkz4zNK9RTFTFPfk2TcceGTuXCNTeRcK+xpJ8DPLAh3c4p4KSIbE3GD\nzuZeVWx49bZ8xWNDdw7/FQv8eNZ9VnE4me3Uws023L/aRVAF8qipsxiN55Cd\nbkG5yz/MAE9W2Ec4s0+JIc1km+FTua5DlM27mRUjpfoANsVAFlYZTemgd6Ip\nGGR6Gh8J8uTzCN589Bme95xZSbapg39ZMAeckpeF0BtLZH1hWD7r3NqmVns1\n2NQzr9PljkTd8/OuEqFYmPOveYKbG6w0A4VI1seqM4v/kLlpPuCPnfplXnm0\n8Hq7\r\n=r3GD\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAKP1ruM/hMYK4IeKSOWn+Jf+sizQRNNuESsBmg4SHoFAiEAzJkB6OKSy3bFDaziEQF8x6UkwSBQ4WhkSm7ZOKzFEbg="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.4_1590497925268_0.4855665020012314"},"_hasShrinkwrap":false},"0.1.5":{"name":"ts-pattern","version":"0.1.5","description":"Typescript pattern matching library","main":"index.js","scripts":{"clean":"rimraf index.js index.d.ts","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"2da9e917a46b6ee9484c3fc8d52115139c57e352","_id":"ts-pattern@0.1.5","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-N9kRuErEXjyi4vGXLeGFwAwZxbZBj3UKP14ez2+k9UxmPcabb9eY3gPs3gxkC6h/8EwHJ/Gkj2q4ejUbY8cRfA==","shasum":"215ff7446b900dfe32cf78ab59657086e597e871","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.5.tgz","fileCount":10,"unpackedSize":47817,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezV3bCRA9TVsSAnZWagAAWjQP/05HwSLbbGO4aaqHo84D\nx4nSM6eP3aTFSPZUxkyuAKvjEam0Ax55UIt70pA9wWll9VYqplzYmCrUOPGm\n025Hvp1uLwZB3urvJhFQak0yXm6lLywcIAKPr4Wu8XyZmEOdN2b/bTRks13U\nFYzobsrxAHd1sRZpTSyhAf4Jb+jARJYVeQGs3cA0owrd3mRHMsyXZBNNzcsb\nuHMuiF/IDQo57rVthA65KJxDLtK2DS4gIysA4T6kWkk/IsFkrzxq5Ek8Zxpc\n3wKigMx8AojfLavgD3X6y3+ND7WiDuyylL8dNakA/m8o9bxnldjqhY+unN0n\n7VS0SnlrlGecOk0K19vC+CPDiTjpsr+3dUHV63LxmCKs7i8FrjolEjguQDEA\nZ0ejcV35i7dXJAYIum77OICiq6LNx/nL1DWaOwepx+28XHdCCgN4QCOhnZjV\niKExr4FkFzZyUWXKgz1xWdGDfezWmaICRsxAdrkb/KnBI9sKM3U/biAqMHmA\nELxslzY9Net2RJrf3+7PUZwOGpK6E+qOg2iV/aUECeLcbgwnaZTORlZQVJBr\nnONeFozaH0/ZnAChTBaBLqTxGQAeg/f17NGd12E3P5biNXxogGIWyd3gnVX8\nuXiaANEMXMo+E8HrSuShkjIc76u/89a0XOYx22blHZggFSAg9FjaOgM6Kt2V\nlgOm\r\n=VfVP\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD1jvWM/Ag4MqAfcf9+oFW8oz7qJbV/DIkNw6KpIraMEQIhANRDyyjK8oqB+uwzuYTKvwL2ilGIx+F6Vq8AMlpNHpLW"}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.5_1590517210551_0.6419316426381452"},"_hasShrinkwrap":false},"0.1.6":{"name":"ts-pattern","version":"0.1.6","description":"Typescript pattern matching library","main":"lib/index.js","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"2e5da1f53ecf5b47d1e97e4278e18d91d6b1ca29","_id":"ts-pattern@0.1.6","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-suO1SyGN3THwB0ZnJ8oagkOrSRwTbhYZd1O7RZjz0vD3HDBxq0JpZYrNgUOmlTgoNngfaDJvTrkUGKgNQIKiyg==","shasum":"c057e7e6d4766b1009240a89d4e47f724574593e","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.6.tgz","fileCount":4,"unpackedSize":17896,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezWDNCRA9TVsSAnZWagAA9KQQAKPCDROrvY1K1c9VTprw\nQkXiTPau4Mac7TLIc7g/87ewDJRH48G5XCw/axLgU+8/zF8Wabf0XfQ8NEBV\nNXwO0j+kz+yB2bLSHYhQc7di6kPxM9xD8I48Ka88EjBlLNnd+mQy5yVMAUwB\nZmnSfIDCFJfBzITA0OaWlMrjjHlFlWU7uvF2n/fP5hf/roU1a4m6+WajDGbE\nIkkSJGDNU3r6FgpH5A5SZ309l9odNr18PVIpxcQG9ygBuRQbJyaSpTAG7DyR\nkPHeKPGlpg6PRADtWGPC0rwJq0pJmBexqwsX3PN9J2wtzcpgVLb4e2zRFFvr\ndIbv1RTHzKUnfkb2yPLmBlRUPdNXZDFVfrH69zrCvF3r9QWkanU6mebRZah2\nHWRM2HJIwrpmC1G0hwC09QDajRAhg9zf5jJHMYX48v/pamvGad7oMgNKku93\nCb+uJBhPACDmi55h5mIXpa3eIvShLarHyK2UWzaKhxJRDEGYDaYIsWSSMTrk\n6DNjLZPlqbEZe2pVvipJA7QNg9mhX7Qs/NhR9eg7zbdg61LWzOas73uXLyey\nC1O0brY2d457JDGHsCRIxL5XW4Ka72EgMSAWbryBclDvDoo/WxHXlxtxt3Cp\nr8lXHGjP1OB9wplLfOeo1Fl+cYsZsymdJ32qZecViovPDd/3IumUuXsGnt16\nzIW2\r\n=xmE5\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIChQkhSHQC14t4iJtSKp9MeQjvQMuZkU7XFwdCx9qrAZAiBBuoVCVjv6+uhBis9SiU9Ew6eVonBxdD5xEn3+e8gu9g=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.6_1590517965498_0.7638705092684257"},"_hasShrinkwrap":false},"0.1.7":{"name":"ts-pattern","version":"0.1.7","description":"Typescript pattern matching library","main":"lib/index.js","types":"./lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"eb524c532d29d0a3afd5e187de4e6a8224e5010b","_id":"ts-pattern@0.1.7","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-bddPbRBJEjXB9vzUogDhEOZBMeRrhSnYc6fGcPzCOBRPtQNMN/hR4/n3tGyEWyfRhGlokIz6UC+9EJKTHRkiWw==","shasum":"0f2cba558b21138a5764da7a99cab817da56ca66","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.7.tgz","fileCount":4,"unpackedSize":17927,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezWJVCRA9TVsSAnZWagAA8ssP/2LBPBJxt2v6a2kwmiiQ\n2Z4aLpf6mo9SLYaeSAW5HNeL9CyAXRvCNRX4J2TwT8E3vM3bDhYPvSN31TdB\nmIxSUf6x7+iHsziJUBXnn4yxe0UduFtEp4U8oDEpSI95rkOUT9lyCMTSjfwt\n4GixL4wJnJGwJA3E306QUqMA1Fd+A76gndM7wrC/fvwI1zzbEFrgPdOLm9W8\nhYr2tSKU+RLaa3Z9ipV2NxfclaMCVtocA0QzxzwunMaLfgS+RV+XX02+82V1\nlCW2HlRhnkgxEWP3e9GGlkH+vnI5mMaF/3HlOrZppRFs960JG7uQFZR8l70E\nwaxXbLIjE19mATiDOhwKRRRQ/8jqe7eaxnVEf0l+46XCIMMwnmDEyMxgY/Z+\naP4i49aZrgPDMVmxWsZYXLlDz4ygaftkX4O+7wPLMc86ay7fPvMSWM+DKbAX\nrqliVlXXS2IZStOpwOf1PJoV/mndpHKx0oQ2MYSY+MgRY4mPmxt+6s5xrRE+\nAoKgcWQg3e3/Sf4XYTsLp2T4E+JvELqkIPPkd8ElSBZCJ0rTiyqczKAlzJgV\n9Qmo7bJRzR6rivc7AS/TwNaz9EDJRlzqhImJ8a+EwKh0+RV3/7uAxsFPdtLf\nuVRh/vWiWJLb2+FxC87IIGnL6myvJkWfNmrz17kHX4lxhUFW3lBjW+ZT4SmE\nDmqw\r\n=z9j0\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDZd9jJln+Qp4kbrdYm7LZMD0S6q/rNcR+rm7LOY+ezoAiB+c9cwIlcTrcXjNPP6hk2j3UnwLjZ5k7ijKVqsSOxkjw=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.7_1590518353969_0.3275990758742451"},"_hasShrinkwrap":false},"0.1.8":{"name":"ts-pattern","version":"0.1.8","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"b9593ab0b2c9f63d3caffc7aea4dff543a8ac1cf","_id":"ts-pattern@0.1.8","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-gmThEv+Omm15VZ47/Wj3IEvNdQmCB8x+q/DW7YOvA5ksqNt61HNWxM5J38XYJIMstiYXJvMHY8EidU8E0oLTCw==","shasum":"aae67e09ee12f0f158b64f07539cb03b769e54c2","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.8.tgz","fileCount":4,"unpackedSize":18134,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezj+WCRA9TVsSAnZWagAAiOgP/1PXcO96QguzAa0XNJe9\nwUf/+CzzNYNljSBGC/d0ZYF3oSsox/QqjnFFQewimaO+MqDcj6xfsBJwg2mE\n7YSpS8qKRZXreKMZQjG2iqwfaDaOF6oBMtCyjTokNX077pLshRH9i5ewYob/\n2LavbOEXsejAe87kqmddvF7rXP5nzRU3XZpKBgUlYcfxdEHQGHnzX7BsoZNb\neGzP0zbG++I4wevpnVNK29lD6Sx8dmZ25XqIe+P+HQ22wDu6nakq3xupined\nKFTgCBSztfsZgQM0pYC0MFsFiO19ON5OYI9N1QlwOMiagUhkTy/koPx8k867\nhAcJzRe3mjSGy17i4dea6IqPmEK9yiT8eeg+S6VrLpfo2FOyzFO2OHFs0J8X\n2TJ8aYdeCC6gR3GZaNzercqyf9//ldd9NGXOFIdSret1OQeCWUFJB7YWN7ln\nza5iPEwpN9l+7oz1W3OrD37YL6+IYMHbQnQQevLmRfic1+RLO26vfmWxK+Rf\nx6eIFnJ9VdqlvOIVT9y6TuB+jXfZgwuswtgEDrNPJfiqzMgs1xcJKQA9qkRE\ne3YZG5ZEPs8C9zIoC7KTj6uUd1Iw0wH1sQE6UJikSR2ACwRMhq5RmWCN7EC2\nUZu8nAQ9c96qbME3owzfIySLsZ0RzWURfvd2C6zs+Nv0Ua2y2rRa0Dr9XDTo\nokyS\r\n=l24S\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGhu9ufGLKdrfxB/WJ6A0M8C9QPw2quJ0IWbQjieYbB/AiAy5/YcD1fWLo/6hlx/s7iUDJ+XMO3ZaTNnP/Ma9TBM9A=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.8_1590574997672_0.7132060693695907"},"_hasShrinkwrap":false},"0.1.9":{"name":"ts-pattern","version":"0.1.9","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"41042160ae40bae48040482a441ab6ebb8724a99","_id":"ts-pattern@0.1.9","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-r0SJCJtoq+LcOi8Z4KN3C09feWuxz6Qa9gmM0eIt19g54kp8S9Tq4fwwNRcg9ikhmbTW0CECZ/5KMALeDDj2AA==","shasum":"4ad514599eb019d1e2ed61b565901bc7cc87f00b","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.1.9.tgz","fileCount":6,"unpackedSize":21606,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe0QuuCRA9TVsSAnZWagAAEt0QAJ+y4hPTAvx3NlxfnSik\ng5212MubjseBXTY9+DgtAWSKcQr2QV6sKZ4whvagJNpZ/Zh8RoG/eurNsJBN\nb/HkF8r7dIUazQqi0VrciVGb9hJODKe5DhfE+qs665cX28j6P+n0cnYQmTZT\nT4xYpBBrn9gtCyhSSpN6NP37oojkWmR+zXzQDuXrezqwRtH8a4zVA7LUu9hA\nUvUAA17Fig7JThzLDITu/E+3JhAY8b1IlRn38mFJ26AYeGO0LwR+OWXLvFLc\nfqdI9MThoATWpSmuyikx/qhl+9sgK8fk4FEzw1yQD1g2GWGX+AwZchPUjmWe\n0CFVX7N+kmXj6l29B6eXxB4NZK0epd+0yWzbyO5Iyrxcc7NqV6ndbWX4/dsZ\n+SB931y7AoRyEq2cE/G+/kDxPUCqXzk5fr4GGZGr7HyWiJpzrdP/wjjtXZOJ\nM/g2fkYamr0VmW+R2+aEUHGx91XvZUtoHxTXbFMZUxfa+6kwRYkWFnAoZEmG\nc6+n8cKBWtgS3M3zsyKVurfJOvlss+gesKI+sgtf/bh5ubjAUrxwcRS+ulgr\n7lyIg8LUZ13vp+WBfKEtnqyrCia07Sm1PTPqHpP2uiCbcE8oPcXrT3xkgLZF\nojYjTgh8/pXcXq6PylAQt7hMV6b3Nrfjgtbxf2kAwzpgkGh8DYwrlPsc35/i\nNLPf\r\n=GAUq\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBA0Wt3DbhANFVmSKR0bUnebZdFbz+0Se4ynyM5Y26H4AiAriugAlu9lkOtHPaD2nz9sM0cAT2bONBB7BEUCfKJsKA=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.1.9_1590758317694_0.4044364617279177"},"_hasShrinkwrap":false},"0.2.0":{"name":"ts-pattern","version":"0.2.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"0c03b9b66cb4c14bebf5f512f84b608453b965fd","_id":"ts-pattern@0.2.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-6s2RepIir302UI4I+U/yAS0D+c7sshCLY9lqvGtiAtvFv0Ui3Olaq2FEXX171zAcFh5yNggJ48d6xktGrXK7oA==","shasum":"dd54ad98b4a91ae4d024dfc2e92c42898801d65f","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.2.0.tgz","fileCount":6,"unpackedSize":21938,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe0RXxCRA9TVsSAnZWagAAyekP/ipbuEthY3+9CoHOjpe9\nzCO95PecsJ1DkqEATXRO/fenjY1YX+c+QfTmuKMeBBuNHr6+sL1YkG1ZDbdW\n6lC6852DQvAxIEk3NzoYiQAapuKSenYI770wYgrSBxe+e9dtg1feguaPFG62\nqVRFTVBgPGJkis5SgetGG/qtay2sN3Dr9uq1DRTQW3vQqh7vCYL9a8lWJCtk\nKlAgG0ZgZmldTwT0tk9EELFL5Fcv/VOikALaUlvdtpIWBPYGNN5HRjUm/AiI\nD3zoSZPkF1y1Bp5wPX7D68fmsIHb+LyCn3k5QmeFn5EWI4fsWowy35GcSskW\nVC7KwW6vYDFwXow2TiSD65dZjVPWwXTvjNyfdSU74p42VJzyIhLyP4LKjFiF\nD12Xp/7zTe2ldGaxCZYKiAIiMYTfJ+ye+fJtneoh//RyzxF7np2sf1uhkQG/\ngDAMvHgI1w7Yl7c87Z19ME49lj1RU2+Y1E9NfWFc/lh1JLxGy3YT0qx3s6Ch\nzNDwYmYWIAdITx+tM14MKjKLwpJNUF/QIxtyEqqhIcbp3818WeSXUspKLAke\n38/Pr3MV+jiad7w3gecnW9HFcVGt3uizZNLCtShY005EMq87n1MxhkM6vlob\n8/S2QolzBbpumsosaZ5qGG2IssMInHjHzFLuOb2WDZBmnMwD1dYqOFlpCnic\n/Fsh\r\n=urdo\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDQh5/YSJvxqIbE9IDa+hs81vUz3IzCfwvgJSR9UCosdAiEArtS8bRRoeSVxxRvDGzIt0UPm21nmjyBuNkp2l8CjeaY="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.2.0_1590760945288_0.3093397206315791"},"_hasShrinkwrap":false},"0.2.1":{"name":"ts-pattern","version":"0.2.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"51b06ea3f5893f23ec7df2f6e7d29fa0fe8bef17","_id":"ts-pattern@0.2.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-xDhcGYzQs5fzj0eHNWLMfek7kMd+MlHarmK5R9cuqhRhUiws5CQb59BUZQLBMs1cqJu0RDQOfmOVDSXGYjevsA==","shasum":"25e18773627ff40f7680514187e06d176c21529f","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.2.1.tgz","fileCount":14,"unpackedSize":24215,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe1Os5CRA9TVsSAnZWagAAQ40P/RbwXq19yZAnOMjIJu9w\n8zPZGE9gTLAj+Wm0B//XVY7xs8685IyAHs9qJzMo3InfVCwW8WbJkaNKbuab\npGLpBQWKnENEgFoMO82csx/qYtuf1pJftDBdWJquBSRzi2MvwlzH+RXXTuhq\nLOc4ZOgKig3M4DyE88474d/DqxPZHOZ5OFGdV79y5QiyYmeir2wYL3fu8OfL\nISXrhL0gKcQIYmHI9gADK8v1BlctKHBqvcq7RiI4cYzTAegGxc42bnWoGbPU\nxlgSKowfTfFuGFq+oh5buWUU/CtlJ0DmIWfFNrK27D33uwIM7qKii3jKd3gD\nDSvicF3ZuBYyeYdSh7Mya4yQRPzps7utXiIh/wEDzK0pONVPgQ00l7mPku5F\noFNVx2wLPfzdc30DcCHBIBmA9rVXcsJxyAO9YZjq+HP6UsOeH4HQ7oCa4cnY\nxMzRvEw27c8MHU5L15+gWNquUWO6lTqZ/55VK0tRcQE9YLan+zn8oyqYW137\nHER0ilytbglqZ1lz7X5jyDwdwdWYl49tfSwIex7t8zNvmVO7DxR+JSYJYcvO\nrNPeIvB+QMXsaLoCXRRG10lVxDBzf++FUvLhIvbzlKSLO2Rd+LuOfWQFV3sc\nbnJ5AMv3sMEtuWF+Dt7XxtSvSQ7bcDs0MG2gM3ZQVVJYHUCHd/cIqKkuo523\nmEnZ\r\n=q+TH\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAF3BsyIWRYzTnY1R8izIxVPrhz0QePYZoH58C33jdiDAiAIdFkTTKb4e2x++UxPdAUKDCRFYogmA/8DfdczAhQHeQ=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.2.1_1591012152663_0.46845456027626753"},"_hasShrinkwrap":false},"0.2.2":{"name":"ts-pattern","version":"0.2.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/match.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/match/issues"},"homepage":"https://github.com/gvergnaud/match#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"e596b9af9e583a2af02a9f42fef3c530a7cc084a","_id":"ts-pattern@0.2.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-JAfOVt072YuUfaabc2zWLhFlD+BiFK+dUMcAkyUg5fYD4R3v2yvSyv9n4PlXVJYmmFBwnna6fGpIz+AkUNZLmw==","shasum":"c4a5b185ec38fa82382d73aefba21b6fae9b5533","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.2.2.tgz","fileCount":14,"unpackedSize":24226,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe1jjgCRA9TVsSAnZWagAAkjUP/1yRIrULM0s5mi5HPsh7\npJYetsvxaBCphXo265b5s+/oShe+ompjknfeN3HYSJQhutWzeG7vZDgOqLoo\nSFhBmbQvgLDBvjOhSwnJs+GPwFjMiXPEZgQHzHJnQF9LGjSCLurJGEBOFrHx\nPN6NLPEGc2eICePvH+wbmA0LtR7F8OemyK/e9ejts6I3ZnvRzoxQdu2cwLEJ\nM3YcweC4s+SyplChJqm8b0fgTr/aqO5ta+6fcXWNDtYHKy2juiuRddIxGTXA\nEOcAiuU/4DiuHkcYuOyx8bt3LC/gVNYg6oNVL0uDNyvk722Ji1JZ8rhylQiX\nv++gmBfbdfaZQ8wudYYHFBKQDPQgzvrejrvxsVs85BGtAnGrK1wxk1an9N0L\ndKaeEmAaxBPzVCkUNBzwT+bf2/MkUnpqqHfpRjTdLtc+e+yXHFSCRoF90qKi\nG1+/iyrUKAnKI6NWzKrshHolFfWUXBCXqFaCbKqdIz2MC25O9GKtAV5SgyfX\nB/bU16HnIrTpV/iRUMy2CaH5fQuQ+HpnmdDcMq5Uyv7N7CmTypiJgJtNxT/E\nOXLmGDoGol5sBWV5waDnW18g5NBSoUkDLMEq/YQ1dtKczXM9k587hZEMDr2p\nevTJd3fUq8WR7Jb8xONVLDsjQ2RrSN4kvMx0xv5WJCPUKd7tvFAZvNjyDhdV\nxaFm\r\n=YxOE\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGkt/GvtOQ454B3ebHN29evtRD7htPwj1QfWKHWcIC5fAiEAjl1N/b7XhvVKd6V2AbpSGy2glPxqsqS9dP3/r9FWikk="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.2.2_1591097567870_0.508744207994785"},"_hasShrinkwrap":false},"0.3.0":{"name":"ts-pattern","version":"0.3.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"6e698c3c1ff00fa3559809d5bf02d171e0c7fbef","_id":"ts-pattern@0.3.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-mtCvzuNtj+dwwZlrVu5qNEM42s3sPk8/d7l7ZALUFk8TuS2ZSj4Bi2H3BSeOO0cl8a6HglzZw6vErgYJKCjB4g==","shasum":"7b3057dba9270a2e268ef0da8028930e848dcb04","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.3.0.tgz","fileCount":14,"unpackedSize":25991,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe2PGrCRA9TVsSAnZWagAAIVUQAIL2O1UL/33J4Sp8gbKz\nHDPmM7dnP/UE9x5tT/GUhH1yArB6YdANyh8y01hoVVVxPlBy4+SAoNN1bD+z\nEdW9YizgFZit6lIi2EUOvLaRJO3QnrQ5Nf0vmkbR+JawlPYYmpeXPUBH26qy\n5QPKCPLZB6DD2P9HzZmN9f4ZbWLHBwwhnCG7u5yNQ2Ou/YEld/RNKL4oaVdX\njuegnc3xdqAGodAMortk6A1Bl9/xzrFu8kdg1TVmEdBD+3SSzyZMl08TOtXY\nl3fYeFUERdV0yq3ow0dTGjmbn0Wq+Tekz95lp/X4u0VjnUI8KnSCIbLDAdOQ\nGnxQj2S16BKvk4k+2laUWlVpLf57Bjhm07urjk0S6dG70gM2Sp/I6U95BdE7\nSzUK6fk0eIlrhIKbOyG8KvVqOSC58DofLi4wtsCX4NKuJl9oJmYFA3tQo91P\nFOVBRt9NzksAbVz9JihP7fcrztCZ6JqTK+i+CTp2eSyJQsIya0pVogcNX0d8\nzfvoOIohjJuVULfmGAwFUiODA5q6hZ7MGYCeXSD9C/VbWcxO5CsSo6UZYjBz\nCpfHHfHXnlskIYThFaRkNPt04+kAGwQ0jKeWIIZUxUIaYxmgbcrfP+gBzPds\nBAYzW5wxXQpkVo3z+DzxceBVvfp6bsgvBqAbGFPvjQN0T39A9GDru4x+tqgf\nGNG1\r\n=YcGu\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBv11+vGF3uil1jA3t5QbM4kV1n9w8Rs6ERAC+SNt4dWAiEAhvcFf4TxC2nqkUj4PS5DP7KRruz0PPaTEUtpP8+Wus8="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.3.0_1591275946842_0.9244455858767746"},"_hasShrinkwrap":false},"0.3.1":{"name":"ts-pattern","version":"0.3.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"c8c25d62d03de78f4a62a6c0927c6d32e01396c4","_id":"ts-pattern@0.3.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-7b7PtaB8VzWS5idhJUD4egflvOoPU4UNX7Hp6KxW5q7jVfl/GYiZ0KuS7rRmbIiVjr+h0xzMO0WReejRs2nNRQ==","shasum":"b90486f37a4bb92a2ae19196ab70dabcfcf40205","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.3.1.tgz","fileCount":14,"unpackedSize":26071,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe2PMQCRA9TVsSAnZWagAAwKAP/09UZAju9tNMMmW9j6+i\nV5SA8zibJo1ZC6q9oVTybpdNQH3DHwfYsJ01GQqsj+4kinMScuuJYYWhDWPC\nptJ8XzOKge26n2kZfaI56C1axy+6ZAojK22iYDw7Jid6/hZUq0dU/ybc5S2q\nsvbZdh+nTTTrkwfa8sU3GUXTa3ChTAkxRtJvN443uzL/+2hKUOOIhtf9WaDl\nhAB6RD7uNtTPGD67yQozg8c9bJOEPge6erDRvP+u1sWBoFAXGaUKAfOcmfcf\ndRxINLOeBVzjiMWjakbWrMqakh4jqv70O2t33MYZwyJMui0STSiBLizHtDEh\npZrICp2fXvh3KKUXIhEfuRp48fX5QHS0SgaL8JmQOgu52nKOhjaqiSbBrpkB\n5e2qB0lazWUXKqU3P9ZXNE2D9v6HqxDj7CQFDlm+DQVDePXejWYLCxzueQSK\n5o2JBGKlzqOysY9RY6O5kkLtW/W55YaH7zwsLrk3O2WjODchK1Es/sENIhgg\nFlx4K9HyejIm5tKORRXKGearS04pbtrQDYXibYCHTqfOiqZzqXqVbDckAUBS\nql1cmQ8DzD6uvIHr5jxd8lvL16UE00wW/C2O2mDut6/xe/JGAudIwTOR44DM\nZ7sCs/mWjsNhP3CU9WOMizmjq0xRSliVZaLDnfdyzXhKCIokU3GnBrKMMAxE\nebxU\r\n=v2dq\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFI+MBu5A6f9diT8+WQZBWpdDamXcRfDhaP2n/lEpsJmAiAf70Hmy56OHoY5RsV8RaLftai7sanyevPgb+2lo/OsEw=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.3.1_1591276303933_0.6807278737759483"},"_hasShrinkwrap":false},"0.3.2":{"name":"ts-pattern","version":"0.3.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"1809ffc44ae8deb72940bd35a3c50d56d5cbeb46","_id":"ts-pattern@0.3.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-72hSC29VTP6D3QkSOw5WaiN1f1iay2A+MsmGLYbdo50lag1W7E0eGy/uekyqYKgSXe/Plka23SfY450a8sWn5Q==","shasum":"71e578b8d5c91562e5b6a720bed015d351618e36","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-0.3.2.tgz","fileCount":14,"unpackedSize":29968,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe2idUCRA9TVsSAnZWagAAjEIQAIi5pZ2r6bVzW8gUl+uZ\nYCosh7TXYQdxdcRLpa97Wjg00tNxMp02LNS/0Irs7IidflNyrTBG4am82sbB\nPuvbXTT8yLDIdUYkczn/gn2Dy2DmrUMFxUZz+GAbBwhEYNC1BnCeNkNdhrYu\nancCVVgAqQ4w8NkP8g1MFKw7w9eHiBfr+L/7Qvm7sCZPHsZosC7LCVQdMjdX\neXysQWRoDIgLmix10kDATlo6KKR2ixbqNcV4ypMsc3q9XVNRZxIHEIfPj4jF\nkSUOp3AhS4ZeGO/i9/quVoypO7S/JGXVcnZn3D6FI5npO/3dde/50PsAtRCD\nh9NSXelSJoe+zep7oyMpb/fkLc6E9HPgu0oXDxHK6Hi3fH+F/oP1SEeJw8K8\nQH0tnyZTR+pWvVweEPVXrixokLqRiC9Xl9n8/PvwY33aLDrhzXweiiLs7M+C\n7spOti8KSMQkwDuJfVBRfKxOThZUiz2IecT2ufz35uqaavxzdU4hqD2FMD8q\ntqGYJm3j3KUctRQmqwMFTWMieKafl24eZQPLucQUsrlBhbMABX3uF8e2j0g2\nP2YtjYzJvm8o5oC7jtP/8EqSsn/uYQkd1Y4UH0JHfWSu8G0WI785eMS3Iuva\n/+3mKB1YzBSHppJ2HPpWOCAvoBzMykgmux0PmcLYh1srzVUUNU9Qt+bLBP4+\nY6XP\r\n=X6qf\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCm2K9ux0eqbrZraSHYTLha9DV0azKDhDFEB0ugAvV1UwIgTr6cxcFqueJpOx/S6DbW9xvj7Aywat/TKkomof2BT8s="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_0.3.2_1591355219694_0.11508512953643857"},"_hasShrinkwrap":false},"1.0.0":{"name":"ts-pattern","version":"1.0.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"3d0de779ece825d4909cab3bb63cf39c707f6ee3","_id":"ts-pattern@1.0.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-Dptp3bP+HhRxKWVd+oGg70pVMfwyeLLLftMvQl14kNZGGb2+Eb0sGWTFpPkx2DQcLfA91kJotHPR/rIx5XkW+g==","shasum":"93c803d190da717ff29ee7872173b8192efed7ce","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-1.0.0.tgz","fileCount":14,"unpackedSize":43247,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe4RI9CRA9TVsSAnZWagAA+T0P+QA3c+pe8n88S0xQFma1\nVYgNMbtBe72G9J1BK6e89jVAWe7A/xuXDWMy8CPVFL7p8Zzs6QODh4YLsLaU\nLfQMrBsoBgdDIGXK9RVMspNv4SWMCYM+KxGdUYPMZCyHrmDx1dKdz58sOwTR\nBdw/Cqa3ALYk/Cl8Y0djYPUUzUafuLKLxEsKfT/Oll3gStl5ZyXCnltH6FE7\nLixHV5btqzkEDIp5m0jKKIrhpwHFtg8dHnrU7hHCYZ6hWymbZXvIWUzDA3s9\n+qOfzW8rnLjt29kBIgS3Dm7hbbIpBDErYWH7fd80IL0zhVvNU9vJthb9613e\nTJs2O3rURAhZHfXKkQXtbTGXjFM6wE8U6tSYc+QArWEnmKvHSOq8o2QlBHNX\nqr/rgYa9JhYRO/we6h7Jwvurw23bCMAm+1WN/PMlhOvD/4ACU6dLbEoPnk79\nRj88Uo9N2BLeNP7P+YpFesZtaFWB/2APp0mUwyUJ5ZE1o1HyhKTMWqBqNTKk\nx36FIVHmIQKVnezZ51qDzKPRzhUTAsfEVQICIYPDimgsNS+9jmPDwPCJdmLT\natM621bxhZ7FGyvnJW9nYnbupX5x/vpTJM8zXpC1VEXJVQLZ7MTXCHln5Jcv\nvD1ILm9GsoF1aqGKknqCRz1p0BEwITXwzUHYh44wlgj1S1PVhdkEHl0hFhhy\nRqon\r\n=ehfk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHQcYyWXJyX4ZHjNj77G9noDhDDaAAVziK41WubnBwAzAiADWSiHnclrsOf3aoMb/dZ1xFKgJk5DX9dIm1yTTyN2Ug=="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_1.0.0_1591808572281_0.8394150085256193"},"_hasShrinkwrap":false},"1.1.0":{"name":"ts-pattern","version":"1.1.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"clean":"rimraf lib","build":"tsc -d","prepare":"npm run test && npm run clean && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^25.2.3","jest":"^26.0.1","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.0.0","typescript":"^3.9.3"},"gitHead":"cc41af3bdaecce3ede423d7293a7416a2bcf4c84","_id":"ts-pattern@1.1.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-7lipCHmn9UkP3HCSkH45juwZy0/CBo+3FyblHdkhWZ7BTlxyGTiadK983fePPqDzedVPCaz9Wgco9GQ8Md0XEQ==","shasum":"f7ecb9c13b3b1a92f9a16ef96e692da3c81178b1","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-1.1.0.tgz","fileCount":14,"unpackedSize":43604,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe/1MKCRA9TVsSAnZWagAAqysQAJAHDUABJhyUtTfW1z6l\n4VHqEleVIxogX6p1xQh3hweCT8Mu4Oz97RrIaOOAjPTMpaDvbQphCyZ+abaT\nBHKncBCh0MJEIF21naSjRksB5Smatm0EfrJeMk+xS4Iudv5k4qfdkorFyrUb\n0FmA33FbrjAxFUxe47JuBFoBdlJDoEOnnVvLGfwB/OVGfoJS/7hTXO7AcXQO\nptlCLmlcMuBsC+XaNJ09aD2W6j20a7giBEKorVaoVHmppUJmbEL0Q0P6ceph\naAi26kCsJgYwHUCHY4Zd9lVBISsxmxG8qOePesd3MW3E1+S7gBLIYg2/qx0R\n7PzJ8IuDs39Sfz9V3qR1g/SPOOG4uB5mxCnEouCE6ZGstYDiP51+RVGUQ0UN\nbFl+TcfHuDOTLpVnh6XNe4WqyG6QKrdZOWfQuPNbaqYUSszhJk1WfYa9FPUU\nvWnZRJQlx/rfIQW03kJj1GS1yxNQeE3bf2yBfIzfKDmvW5bKQxo8l0hQdYwl\n7+/WV/VzVezDjgmoL+5SbVKdLHb0AChCo3Uo1n2lLDVrf7o01TRwuxnql2B/\nOUz6+dOiTWJOa0D9twgaylWb3dTxk8Gi3qPJqszBs9bmuZVVi5RnnUbuCrlb\nRDaBBr6OkHjOiFw75lvHWl8z/cg9X6kpvKjSedhmL5BMY34lVcIrPQR1G4Tw\nAMoe\r\n=3nj9\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCDfcFikfsX8leMIima6clA+/mqsNvh3Ht11tCDZ+zIrQIgezphDGb8GQ+QPTbmimaMK9x4u7KRIthKkAZL45l7uZM="}]},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_1.1.0_1593791242167_0.5026021552996838"},"_hasShrinkwrap":false},"2.0.1-next.0":{"name":"ts-pattern","version":"2.0.1-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"gitHead":"fd384eb21b91dadb377641aeb7a7f8ca26ac0bb3","_id":"ts-pattern@2.0.1-next.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-zGJ6FR0qZ7BG6+CUm5Rca4KLRW7NNOniljZ1gnyMlGafbKdSJ4MlZCDIxU3mVb7jP2w67JAx5de+y8LzbPYSUw==","shasum":"fadac9a78a8f4c0148cc5d4e9946267ba2413ddf","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.0.1-next.0.tgz","fileCount":20,"unpackedSize":53744,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgAzarCRA9TVsSAnZWagAAaQ0P/jU2AwWpOLHOmLrT4391\neerlGByG4VGyz31gP1FbuGxlsBEK5LXonaKj0MGFMaq5IseLJhUb83ww6wrr\nsm7jN2Jhxc1C+Q5y6qlwjNycuOOIAEK9BHUGCp4hqtWocFeGNpNbs0kgFZmZ\nmgrcMkM64iu1cdql5CRxhXfKgiVKS9UUMZpil6mvdPv/olvTgg2Ly4TJMnGN\nvo0ZxJ2wiBZ+C8BOIqyK/YhZ01jJqbpAnh0iHFSCxQYZb0X0AS0pAAiNlib7\nsiSrvmkvYS6haHph//4+F8QsV8DGyMgFd7sF2VMt15gFq7d6HPpDL5Emh+q9\nC1P5g9BAzOIzvn27ac+0+h9HgbZSyx6cJSomUBM/wabp8i/AfTbBAJLucx7k\noIa8a/aR1GXMx1PtMu/SD1FLt0HcU2IUM1zCWtlX8msUV0oXHcji9ylFhukj\nuE834cxdjwRLz4O8wQIHGMoYbHZV7Z3rvRmfYaIVnZkZfCc4ZFHpg6oKMCnR\nYyhaaFlwpMLw6UJ5+qNBFNSHbxFMODlPLTXaw6ClXOGANtHn18lt0sMC3Vm7\ntTFrbLQCUpYEhmlpkM7NPjJVf1UxeUaLQBfrhF2S1d2IE9vlJO1sj5r5zxE5\nJENXT3yd481DwY/ZmcLKm4pc8NlYLqBvGKll6DAWk7DMbT8TRMZNptOas6lb\nWhLL\r\n=tPCU\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEUm1TZ5mVfgD7zwAN499KkeXPf44VgKoFk5NLj7R9wuAiEAotZvXR2ilpm8dSn9vzU/PGQa47eyIKGH0+U7URmAAT0="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.0.1-next.0_1610823339395_0.8459071421194371"},"_hasShrinkwrap":false},"2.0.1-next.1":{"name":"ts-pattern","version":"2.0.1-next.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"gitHead":"51d8e14d3d308c7b861b98d62ad41d9145810abd","_id":"ts-pattern@2.0.1-next.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-aJsu8gmGc484uLKWYs+IIusjSUxDEdRld3S1xK0kPOguMhOq0LOdj6Y2uEZIFxcdi4S3BtBneTnp+QmlYNEFEg==","shasum":"58ae623ab1270a2c078e8a3432fb18e88096f236","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.0.1-next.1.tgz","fileCount":20,"unpackedSize":53716,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgBHmZCRA9TVsSAnZWagAALtoQAJj1JBzb//G4G0PR6HWH\noUjDqTYNBTHU3E52tEGTwM5OSyD3St+t6kA1zFv8LmglGxjVShYjvD8kkKrR\n+5zKCiaHgIqe1tsRAvgy6gScneryToGyNHTXurc+s8/g1R1+KoenHsNUBNSh\nWMRZ4gWpMXjr/nMnovGB5De3bkrwt8m3S3HflywjewP29N2j0lyr+5SY/IAt\nPWR5815ZeYMcF5XlCgD97aW33447K6XPHpSaQl9Hg+6LZqSRBUM0/zf+bdjg\naGtmw7ZSssoxxCin68ktGs6l4JnMZP2ygmdbqHI8J+lpOF4bpKOt51luJ/rR\n6p1oYhmLz8WvlP+qqcGL2mOyJnHsWcY/bYsCenyDLrS5kkhybCpSaKlgCJZg\n3LT4bs/oGjSh0dNNy/oPL8jh9MkDCTacwKdq7SaTKDcSS1Vbe627rHBPqPjX\n1IgYbRDHBz5gjC78Yvk1Hbwb+foI+C+FqJY0o7+SqIHRUFjxMYv7RKYJYt/H\nw7snVeIQa+8k340/eDzU3c7/eIj9adM6CuLcFjD9qy+xQPeQ16yd4zPU1DUQ\niFzvl4RL6jm8w5ZFqpMKPO8bJ4aDklgElJMrvtVMeQ91ptElkg9yPMHXSYAJ\nbArFHVzBOuiua3dcJ4Ic/5FAphn+4g/vPbx8PSwA1+h4QXOJ3ZK8icDFW4Rf\nI7AN\r\n=FWxt\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFgca2ZIX4JSXls5Ss2eOlM8jkH1Fe9N17Xb6ibgT+xZAiB2fIQNlxO0VgDZBW7BoSiGM3MEPDXa2yU01P3xuTSXXw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.0.1-next.1_1610906009025_0.06463698336596568"},"_hasShrinkwrap":false},"2.0.1-next.2":{"name":"ts-pattern","version":"2.0.1-next.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"gitHead":"d7ea37c7e0638c659798dbfdd5b4667ba7410b11","_id":"ts-pattern@2.0.1-next.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-zsJxD+YgaOwbpXGEq8WhkfzzHk3AV9IeeK2W8kf4edxS9yGyP/qDWwKAynGrOG7X8hkyn9ih5SpYu86BTXrZkg==","shasum":"bd7bed9bc1c58bfcbe9804b37cf8999e265bc05e","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.0.1-next.2.tgz","fileCount":20,"unpackedSize":53734,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgBJyrCRA9TVsSAnZWagAAFmMP/3H2gTkfaR30MZeyuur3\nxBDP++WW42BtUb7NUHLEj+poNmcag0KleaG+aGIwGMZepGofDzNsAnnQJadJ\nyk9c+dBnsuvNAQipDnekAX0oMxjUUgvOWzRv7j02L7MP1uJKtVTFvwOaMPiO\nxSlbJwcDnbQsVXzryI1gilwAaivwoG+UaF131vZXG6jSsLOnQTfXEt4I4xp9\nTfPqFr20Ljtusgt6bNfKHqhRll3Sg3ooGn/CdyockbbelfutxeLAKZB121da\n37IekAMrSlv/ePiWzEze7y4XIyIkbmhutTw2kgaxR5bAcaoqkLOYGGLZliX+\nw8Eqlx1fTp85EctU2Ypytr95eDumAFX4OS9xtAZIXyHjtWi6QS9kiDTYNrBX\ngJAEttSd1N7wY2CpJdzKGbKT7oVQpJShrQMC7LJa9YKx0/uOnUlArq47B86p\n18YbM5pwzBExX5DYYaa+3QaBG92wemmYoqTbLMx0+gtg6f4B8B1o+VFRPd5I\n1XpPhwTzJvsGQlhbT47EYWEZOESOgl/GMt1P0WM16+K4m+HEDemq+fxGobCV\nrLIK8q2+Oc2Om8qMfqO3cQkD0oq2+8TLj1lpaN95KjFH3Z+DINjdjbvRPsjr\nmjE58LaJW63xhCzCIMV9k/QOosMvPTUtuOVplcVIiOQl17Wg6rf6zZx5HHU6\nmpvT\r\n=as/Z\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDkSGmaKzOdUo4nz414KUhLC+GnmpD6wvz4g4fBtF9fjgIgPDy/3Cc6GUV4ixJYRy9Ja6i9tqY+TQ6LbClLRM17zro="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.0.1-next.2_1610914986870_0.7461823596892958"},"_hasShrinkwrap":false},"2.1.0":{"name":"ts-pattern","version":"2.1.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"gitHead":"be1d83afbaa46da10310e87c0d4273757412e2ed","_id":"ts-pattern@2.1.0","_nodeVersion":"12.16.1","_npmVersion":"6.13.4","dist":{"integrity":"sha512-9F8n/O+R03x2lKaf/8ArN65LbdEWH2g5dKZvaw1hxRsP25uIeFkX+NFX6iVNrxW0gULBVqv7m+mJ6X34R/S6Jw==","shasum":"339d0e9d341e51a8918f048c74afc7dd51529742","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.0.tgz","fileCount":20,"unpackedSize":55814,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgFSGyCRA9TVsSAnZWagAAVeIP/Aopz7Wd2K+r7HBg27Fp\nHWTqWxwZNfV53dkh6PmOhTqgVrMPGrj6doMkInqtIRG0Zvm2eBK8ty4cV8wP\nAFuCdT/fuFkd2w1U880BvDPzUUNPNnAP6gKmZODJ5ME6fE4LYL+xfepZ6LhG\nI7h1Ze4TJFngx/6uI+hwQeWPwPWO73mn3pCQOtFqMiGjAoCRyCKQ5nkEPy7b\nHgIxszdK+zceYgqvtFH2wwbtjYw27KVck94XM03kSwFU7/3aV8lC1w0YJKUW\n0thKv9Y+BcbXlMecUJ1KV1NlSci7IdE6ej1Y9nxuaJn6fWPCLeaD8J1JstT/\n7slH2li9qwCULyva4taU+bRtQGMm0YWu1cCJy91iz6/xmlLf38rbcQkIs4jq\nFJREHypuc2ZsDqxEL2Y7oSwafolbVYRs7AvuzgGrjaCyQn/kqvPvpA9byDx8\n7m16Lcy95+M5ozQMU0vDi7cZak1g/Z11ban8yM5llNK28eOwAZ5ZYiyfYExP\nOaJt8sImfAS47Qbdy0w7fGqpH7Q86WIHRAvGBJu/Gv0yVFUWMrjYxL0tS3Io\nr3DNUL/cNv/dAO0qlZTPXq7fArEfJAoXnzzee4W1ZhE8datL92lO63Qh9biN\naSf6xs5G4iQnSCU9J9YJvh2BommRvhuSuwqavGMo56jLMFIefaeHQ5zNsj45\nUwvV\r\n=LOdm\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBSHwJTuGvcH3hrLFRfVD9fEaqVgKRYviXW8KF58zGliAiEA2njRWBD7ne3mcaa7xcPHYAie5e7hEJO1ZHq0eF0dg2I="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.0_1611997617728_0.048432010031315365"},"_hasShrinkwrap":false},"2.1.1-next.0":{"name":"ts-pattern","version":"2.1.1-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.1.1-next.0.tgz","readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nA complete Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://badge.fury.io/js/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string }\n  | ...; // Imagine this union is huge!\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img' } }, (res) => `<img src=${res.data.src} />`)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .otherwise(() => `<p>everything else</p>`);\n```\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with great type inference.\n- Optional **exhaustive matching**, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive syntax**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name>)` function.\n- Tiny bundle footprint (**only 1kb**).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from Functional Programming languages to declaratively write conditional code branches based on the structure of one or several values. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Elixir, Rust, Haskell, Swift and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n⚠️ `ts-pattern@2` requires TypeScript >= v4. If you are using TypeScript v3, please install `ts-pattern@1.1.0`.\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [match](#match)\n  - [.with](#with)\n  - [.when](#when)\n  - [.otherwise](#when)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.ts)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input (API response) Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.ts)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.ts)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.ts)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.ts)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case were `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .exhaustive()\n\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select('err') }],\n      (_, { err }) => ({\n        status: 'error',\n        error: err,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with([{ status: 'loading' }, { type: 'cancel' }], () => ({\n      status: 'idle',\n    }))\n\n    .with(__, () => state)\n\n    .run();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a builder on which you can\nadd your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .exhaustive()\n\n`.exhaustive()` enables **exhaustive matching**, making sure we don't forget\nany possible case in our input data. This extra type safety is very nice\nbecause forgetting a case is an easy mistake to make, especially in an\nevolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off\nof **disabling guard functions** (`when(...)`) and having **longer compilation times**.\nIf you are using `.otherwise()`, you probably don't need to use `.exhaustive()`.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the handler function: the **branch** that will be called if\nthe data matches the given pattern.\n\nThe **type** of the data structure is **narrowed down** to\nwhat is permitted by the pattern.\n\n### select(name)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select('err') }],\n    (_, { err }) => ({\n      status: 'error',\n      error: err,\n    })\n  )\n```\n\nIt will inject the `event.error` property inside a `selections` object given as\nsecond argument to the handler function. The `select` function takes the **name** of\nthe selection, which can be whatever you like.\n\nIt is pretty useful when pattern matching on deep data structures because it avoids\nthe hassle of destructuring it in your handler.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use\na `not(<pattern>)` pattern. it's a function taking a pattern\nand returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .run() and .otherwise()\n\n```ts\n  .run();\n```\n\n`run()` execute the pattern matching, and **returns the result**.\n\nAlternatively you can use `otherwise`, which take an handler returning\na default value. `.otherwise(handler)` is equivalent to `.with(__, handler).run()`.\n\n```ts\n  .otherwise(() => state);\n```\n\n### Guard functions\n\nSometimes, we need to make sure our input data respects a condition\nthat can't be expressed by a pattern. Imagine if we wanted to check that a number\nis positive for instance. In this case, we can use **guard functions**:\nfunctions taking some data and returning a `boolean`.\n\nWith `ts-pattern` you have two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n**Note**: to use this feature, you will need to **disable exhaustive matching**\nby removing `.exhaustive()` if you were using it. That's because with guard functions,\nthere is no way to know if the pattern is going to match or not at compile time,\nmaking exhaustive matching impossible.\n\n#### when(predicate)\n\nThe `when` function lets you **add a guard** to your pattern.\nYour pattern will not match **unless your predicate (guard) function returns `true`**.\nIt might be handy if you need to make a dynamic checks on\nyour data structure.\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((startTime) => Date.now() > startTime + 1000),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts up to 3 guard functions parameters between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => Date.now() > state.startTime + 1000,\n    // you can add up to 2 other guard functions here\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\n## API Reference\n\n### match\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### .with\n\n```ts\nmatch(...)\n  .with(pattern, [, when, when, when], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  [, when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown],\n  handler: (value: TInput, selections?: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns bellow](#patterns)\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - You can add up to 3 when functions. The input will match if they all return truthy values.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### .when\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .exhaustive\n\n```ts\nmatch(...)\n  .exhaustive()\n  .with(...)\n```\n\nEnable exhaustive pattern matching, making sure at compile time that\nall possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): ExhaustiveMatch<TInput, IOutput>;\n```\n\n### .otherwise\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: () => TOutput): TOutput;\n```\n\n#### Options\n\n- `defaultHandler: () => TOutput`\n  - **Required**\n  - Function called if no other patterns were matched.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .run\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### Object\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'I‘m a very interesting content' },\n  { title: 'Bonjour!', content: 'I‘m a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => 'Its a good 5/7.' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => 'bad')\n  .with({ score: when((score) => score > 5) }, () => 'good')\n  .run();\n\nconsole.log(output);\n// => 'good'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables you to pick a part of your data structure\nand inject it in the `selections` object given as second parameter to\nyour handler function.\n\nIt can be useful when you have a deep data structure and you want to\navoid the hassle of destructuring it.\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('username') } },\n      (_, { username }) => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\n### type inference\n\n`ts-pattern` strongly invests on TypeScript's type inference to narrow\nthe type of your value to something that matches what you would expect.\nHere are a few examples:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","_id":"ts-pattern@2.1.1-next.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-7Yc1dm4iBbgyMdFrV7Pyw5RkTgvACSTX4pj+sF2jdIIQnQe31P37pr6b5D5Qx+eiNl/YbKGK02KWMdbhLx0DCA==","shasum":"817a5e1f79ff6cac4042f9a684f426e13633a283","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.1-next.0.tgz","fileCount":20,"unpackedSize":56464,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgG7EpCRA9TVsSAnZWagAAMR4P/2td7A6VrC9lA+V+aDm/\nPwBbnDeWI9iCsaqpdqcWUbYrz5ig+kl3e7FCuzLEaOETgazMgdd2rsRKP5ul\nMNnq6eUMedjhjOVWF5t2h/G3kJOY+EO3fsxSESb4kUNTPAwIb6Up0iEAG3ZU\nDqRilmw8zuh1wG08jOpSCoh5L8Nxh4JUJtwgpWdGJtQ4zbgBdIw3qiwtqFus\nNLuhCc3hzN9LfCs2OaFlRmtoHzz/z3wZL+0RmZ3Tof6GfB+sm463YwCWIOkF\ngAYmk9t7SVOH38Yf0T+biOBfjW+nyGGaUaXCqiBeHkJAMYAu7bGk70glgy3G\nFQQTniKjXURDbctGtaT3hoqGEabjg++/vYlsYUsnCEBHYJLKuNi7wwI5f0ST\nlOXVhZcBOSNn1aa8+2u6FzXcRPEIbxFIpx11dQmOLdNQQ4HZzEjPhGUdCZ43\nNPTAfrM7LGpH+CEaYeFfrxgTpEMZr1PXWdonqoJE006eZKgdzXufSq3mdng6\nsUuP3/AvkjAyUzOk63QpT88v+JiRiNyUUWnQp0dsoCHQAWPeFtHe3XcZjPeT\nYQ5QFMWUpmQ7Rbe7Px+RZpFfrYLgCLELxVXdxPVaZC5Scd6qP756vtfTc6gI\ntNtSfmrOBoaH/2mgv6Fuh7bum2AIiKuINAKFrQB9TOAEXX4Q50Zjw8rR2mTn\n2WKt\r\n=BjAB\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDsiNxkfLxpxtroRc3Sndf8w2GHr1UeUxj7rF8TILm81AiEAqRSYtVycRO/lY7W0aXRwZVofdAD6aZ4gXZ7s01tZbhY="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.1-next.0_1612427561198_0.03786013696438184"},"_hasShrinkwrap":false},"2.1.1":{"name":"ts-pattern","version":"2.1.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"gitHead":"ff74bcad72d2814449fa8d20bf1c8e3efea445b6","_id":"ts-pattern@2.1.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-2SavUq/QMgB9nVjcD8r5QdUK6ELrO7VYJV1RGmvv3XkxAK8tCdEBgXoQtY47YBaDhRNh4NiiEdTQzJRB8jq+KA==","shasum":"bd30a98e2b0a2517c0544ed6fd45ed3e566c38e3","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.1.tgz","fileCount":20,"unpackedSize":56454,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgG7aTCRA9TVsSAnZWagAAC5oP/jxib1Q+hDy+jPRgoVVY\ncPeJBAnzHXMVEyrH/+el1dmKDSV8x9qyl+BQjh6lkTdW1WrYs3tKF8eh/dwS\n/a6PwzmZThfTuqXNjuOfs5ZMw4iKlHHXa05uZ1su4s9nyJrwgEf7N/L6kxKR\nE4eNUlupKo1IxDHfFNvaS0puqHHQz+B5juuj2zFBz/bDEdcj7BWXv45QKCfa\ntEdt7VfZzh5VIymUdd/rxQjV06sgFqT5cd9u2emYMXl16WmW07rFDhux5ls4\nokLHXM/7RgAW5DrtcTU4ogoD3lRxShVGV8kq29s4Mvgb6QkYeGExyFqyV0BL\nx7S7Pe8ME3UmqHQpuoMHKRbgXVeo6AUKE2UQjKxrkKFpuZRreBf0PSkqUQVs\nS/btg1zKpb/Sc3zYBEk0Ltg1Z+faO4SE1m5YFCPh+AIySYKOLpqmUJQecoXm\nmEHYKEsy3csgEd09v/F57b2KrP+8ayWfyTVnf8GfR3f7aQgBwQ5TrzXBoTGq\nmyhegrwKaH7MJRC+4PO7TfTwNs84ipH3jKQDR4kyIQwfEfU+51foIcNAsc/e\nmaJxErwLVDX/s9kdybRJr4UTi8epAlZk0i3SQ+5ilJrnrW7gBGL8v/qZEnx3\npqUmeZWip7x476i9IrwrGEsgabshTAQUyXUeB4tvhR6bjBCiYo1FL05X/3OI\n1yQ/\r\n=be5G\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIByo1oBssyJhJOfJ+S7vMYdh7hAvfHkOOIAg2dtfp83qAiEArHjuXgROI+F6EsWz2j+pKDci68eWFOAVAOiheXXx9k8="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.1_1612428947326_0.769963792863017"},"_hasShrinkwrap":false},"2.1.2":{"name":"ts-pattern","version":"2.1.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"gitHead":"a12a1c11fafc0ebc5d796623db781f1d6eabffdd","_id":"ts-pattern@2.1.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-AH0rikTe54xQziorTpqaK+QzAhY9E2eTR04oWq9IHpi0uwomUZlRRq9/zEelZGCPTfMBwUNuRZ1k/p2fIfjtTw==","shasum":"c18d3f16ce8ac02f71f8a99d18640ac2fa34a2d5","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.2.tgz","fileCount":20,"unpackedSize":56813,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgIPzTCRA9TVsSAnZWagAAK2kP/1bsS2zdZb6/qBZwQ3rM\n5HFhNONS7r1Kpxs7lQqfXhP4f8aFxaoHNvlCUqyOpo/rCL64eGXbT75m5nNJ\nLlF8lQjmI5UTVAIlQJI0gBcN3nzRU8ecNGGtxYwGR6b6lRYjLP0jRvzIyqTR\nd6+A3EPIqwcBg+CkRsEBo6arzljqwmtpFfGN0ebF2B0Yt3x33lLBt3rbMlkt\np/i3c6XAFzuctHPC/AyAyc2KGp3GZQepr23IWV3tF3D67m0JCU9oQB7a4KYZ\nelvptWW5PGFupvBW2DPE0fKEsiQqqxkudo3rqi9YtA9MjWqxAnQAknD/T3uy\nTCH0gY7d4tKAXVdCdFLYkxb8icIwEqVk4HIpazU6pY5gtyQJslAhM3NmeiXo\nisPnZ8pzxDq+Evi0F7L9/JEmnydat/O8bSphVjCxjTxA4bx7yVZVbjBTCMSH\nk86RfUIWDxFhgEFhJx2l756GFsFAnfgkSDzrHJ5qElvPIEy86Vmyh/P6kaSt\n1+8GxzaK3aNaz4i2ArS3M90lyu/9IQI5mFXii/TCJUdnu9rJLjWE9gIgcH9V\nbzoorijy9Jj9hwCHxtypSFRv8RiBzDejv4rkKmwuDOcwhorlYtYzmDpTWcCg\nngza7Dw+PZGCh7pfhwupW7vhnEc8fY1F4+8BL670ca3CaQEF3tBzP2iq6IkF\n7qaK\r\n=ynRc\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBTtttwtH9Z/jLsRhtNI5RnbWK65p8LeoND5KoDE1RYxAiEA55l8uxZFVHWfSJL/aCycbrOCWCHRhumfcsoj8cwQpCE="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.2_1612774611051_0.7120861261209281"},"_hasShrinkwrap":false},"2.1.3-next.0":{"name":"ts-pattern","version":"2.1.3-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.1.3-next.0.tgz","readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nA complete Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://badge.fury.io/js/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string }\n  | ...; // Imagine this union is huge!\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img' } }, (res) => `<img src=${res.data.src} />`)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .otherwise(() => `<p>everything else</p>`);\n```\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with great type inference.\n- Optional **exhaustive matching**, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name>)` function.\n- Tiny bundle footprint (**only 1kb**).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from Functional Programming languages to declaratively write conditional code branches based on the structure of one or several values. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Elixir, Rust, Haskell, Swift and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n⚠️ `ts-pattern@2` requires TypeScript >= v4. If you are using TypeScript v3, please install `ts-pattern@1.1.0`.\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [match](#match)\n  - [.with](#with)\n  - [.when](#when)\n  - [.otherwise](#when)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.ts)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input (API response) Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.ts)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.ts)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.ts)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.ts)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case were `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .exhaustive()\n\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select('err') }],\n      (_, { err }) => ({\n        status: 'error',\n        error: err,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with([{ status: 'loading' }, { type: 'cancel' }], () => ({\n      status: 'idle',\n    }))\n\n    .with(__, () => state)\n\n    .run();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a builder on which you can\nadd your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .exhaustive()\n\n`.exhaustive()` enables **exhaustive matching**, making sure we don't forget\nany possible case in our input data. This extra type safety is very nice\nbecause forgetting a case is an easy mistake to make, especially in an\nevolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off\nof **disabling guard functions** (`when(...)`) and having **longer compilation times**.\nIf you are using `.otherwise()`, you probably don't need to use `.exhaustive()`.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the handler function: the **branch** that will be called if\nthe data matches the given pattern.\n\nThe **type** of the data structure is **narrowed down** to\nwhat is permitted by the pattern.\n\n### select(name)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select('err') }],\n    (_, { err }) => ({\n      status: 'error',\n      error: err,\n    })\n  )\n```\n\nIt will inject the `event.error` property inside a `selections` object given as\nsecond argument to the handler function. The `select` function takes the **name** of\nthe selection, which can be whatever you like.\n\nIt is pretty useful when pattern matching on deep data structures because it avoids\nthe hassle of destructuring it in your handler.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use\na `not(<pattern>)` pattern. it's a function taking a pattern\nand returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .run() and .otherwise()\n\n```ts\n  .run();\n```\n\n`run()` execute the pattern matching, and **returns the result**.\n\nAlternatively you can use `otherwise`, which take an handler returning\na default value. `.otherwise(handler)` is equivalent to `.with(__, handler).run()`.\n\n```ts\n  .otherwise(() => state);\n```\n\n### Guard functions\n\nSometimes, we need to make sure our input data respects a condition\nthat can't be expressed by a pattern. Imagine if we wanted to check that a number\nis positive for instance. In this case, we can use **guard functions**:\nfunctions taking some data and returning a `boolean`.\n\nWith `ts-pattern` you have two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n**Note**: to use this feature, you will need to **disable exhaustive matching**\nby removing `.exhaustive()` if you were using it. That's because with guard functions,\nthere is no way to know if the pattern is going to match or not at compile time,\nmaking exhaustive matching impossible.\n\n#### when(predicate)\n\nThe `when` function lets you **add a guard** to your pattern.\nYour pattern will not match **unless your predicate (guard) function returns `true`**.\nIt might be handy if you need to make a dynamic checks on\nyour data structure.\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((startTime) => Date.now() > startTime + 1000),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts up to 3 guard functions parameters between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => Date.now() > state.startTime + 1000,\n    // you can add up to 2 other guard functions here\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\n## API Reference\n\n### match\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### .with\n\n```ts\nmatch(...)\n  .with(pattern, [, when, when, when], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  [, when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown],\n  handler: (value: TInput, selections?: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns bellow](#patterns)\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - You can add up to 3 when functions. The input will match if they all return truthy values.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### .when\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .exhaustive\n\n```ts\nmatch(...)\n  .exhaustive()\n  .with(...)\n```\n\nEnable exhaustive pattern matching, making sure at compile time that\nall possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): ExhaustiveMatch<TInput, IOutput>;\n```\n\n### .otherwise\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: () => TOutput): TOutput;\n```\n\n#### Options\n\n- `defaultHandler: () => TOutput`\n  - **Required**\n  - Function called if no other patterns were matched.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .run\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### Object\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'I‘m a very interesting content' },\n  { title: 'Bonjour!', content: 'I‘m a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => 'Its a good 5/7.' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => 'bad')\n  .with({ score: when((score) => score > 5) }, () => 'good')\n  .run();\n\nconsole.log(output);\n// => 'good'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables you to pick a part of your data structure\nand inject it in the `selections` object given as second parameter to\nyour handler function.\n\nIt can be useful when you have a deep data structure and you want to\navoid the hassle of destructuring it.\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('username') } },\n      (_, { username }) => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\n### type inference\n\n`ts-pattern` strongly invests on TypeScript's type inference to narrow\nthe type of your value to something that matches what you would expect.\nHere are a few examples:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","_id":"ts-pattern@2.1.3-next.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-JQrdWDcuRBhgSdkNdWvLpzjHysfPc17Lc1ak/3LYJ/ArpY2WS4RymdiGrdWV0OeKJjbc9GB8XuLL3zwxVksZ0Q==","shasum":"d3c2a6301a82a5336918bd0af1b149042b017fe5","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.3-next.0.tgz","fileCount":24,"unpackedSize":62652,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgMtleCRA9TVsSAnZWagAAOvkP/3JxhHtWNtq51TxMSofF\na/5K4fAwxv8r6iYj7FK5cxtDq6ArRZsmv0ZxHWFiyW0fZZY35OazO26meHHZ\nINa6+awvlznwxRGor7u5rs65E22dEN+KfMUy5WSyHP82LFbS2sjJl7GgxqJS\nNhj9RMGb5T761rPv/W8wJZ7qqk0l2OPNZrPkyxWBpTOmJPWLCcOpE1imQcnj\nHUr7jzHs0000JMGNPjO9UjgSL/1AgyrcZepN7/ffsjZ67g1fe8wVvAYv46xV\n+fIU4fAHbu7SzuoJO76NbL3mHcwj8QKwdJ8goI+ML5zoStuT0GT8efwbaDeh\nJzXl1VAB7pA0nTl0pycXIaK6uu9KF/9P7SYd5RVBfEywmZOY5/wY5/kka2Ot\nCqdAwaMOj02h8Ei8SM1ZYyMpJF5vsM+zF3OArB1/K6F0O+rq5HZBnvkPawcD\nrXS6ENSyiJ1aHmGUvcra/eXRHvovIe9Oux+vQK5OWdi0B+lCt17W1okNjY68\n1/JeDs6fWuElPMNroKWYLa8IhcWP9rZbV0cy7Vus/N5wNGgkp5kbSrR8xGD7\nYDbbUzfggvzsim5rhjlUc+ehHW6pKHJfyFuu8fGCAWj0DU+JJzD/cIBa0tbP\nTjbonAPBIcwpBockMJStFhdKMNC2vSkKF2uJVY8PNDVDdovWUfB17KQ3t5kB\nRW9Q\r\n=YqpQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCDFfpzNZMaNob0YgQw8NZc6xm6XJf3K4m4V5oczTBhlwIgd9cuVoaOPrni+4QP0g4lxHp5y9NxjAXHF9FaAKBlssk="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.3-next.0_1613945182096_0.5204760815594811"},"_hasShrinkwrap":false},"2.1.3":{"name":"ts-pattern","version":"2.1.3","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.1.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.1.3.tgz","_id":"ts-pattern@2.1.3","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-8pDCIhqVEjGFt/TPmGJvkZ8CBOlP6jFe3lOwPrdQZ3PPWPDWpRwkiKddi/L9jFkQjMvaj66HWuUCaI4oMPXe2w==","shasum":"2932d50be371e7027efda6bb06e41e9becb39512","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.3.tgz","fileCount":24,"unpackedSize":61832,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgNLnZCRA9TVsSAnZWagAAcNgP/14lX01cWe9b2tOIUIOs\nttDkGkv3yBcoglX49lvDk9xII3Zwh+thhVoXvCfwFtHHcpGCBAd3xTuobsth\nc7bIk/1cCBafa5WGpYJ3uJao6cMPGmPFiBzH5etgCnhEEZEsrvsaTIE1k+Kg\nJVBGyoCsNPdxgatt5L8KXLCm9RPunvltMhCOt+/WyN33mMKnKrwVAuMtIuzw\nmbTYxrN5q3Jx8vEICv226x+Nhf3bt3YV09JAAuO/iln/XLflfYKt8QDn2GPm\nGFSVPuvKU+8WPPpl3T/DVvyIYmF81ReBWRjxK8rD/SUNaFRmeCoZaM16Rm1P\n3+Z3EAz9C8nIeXqzkrjDrIT2N8rpy+U4jn/RlB9c5jSEus/fOTFYDgGZdmx6\nfKt6esyuOY/69My5OmiEAS6EH0wMPtkkUFnngcvPdFLwZJEBhWmr4hx9HT+t\nrBzzd4x1oZj7BIzcZ7urT9BLPAKXBPX1sOEKESB66UEtnOyRozQptQhdICPJ\ntt/y40hneFYjFVeJ4Q8nkP1dGW0sVlUJssd0reFXOCJDa/WoH+HZfLOzNLx3\ny+K5wMdbMn+J2FXO7z0IQCoavgueAcD9QMfQicmqDm2EfE0RAc+PTPxhpvO4\nbFRXOa9LZdx+4hD0rrmcIQ/OCBYoX0xxyoSezlVEr62MLOIht6VZ3K0Med7z\nthTf\r\n=/Vx6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGxa6toMzCgst8DK+1C6DjlMvD271s22TRSYEKfiLhN5AiEAu4ADOfc/mkjetGuc/ivXpDyDrDKr1wNFPUt3mfxEufo="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.3_1614068185020_0.1253476389675654"},"_hasShrinkwrap":false},"2.1.4":{"name":"ts-pattern","version":"2.1.4","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"5884523d233a640fc0b5a384316af1b8d5ed1e37","_id":"ts-pattern@2.1.4","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-k8MHBl/3JqYoLUZh1Zz0PtkxMC24UP1SoC0b7/OAyivMFssrMR4P9ZDpv8cAC5WnXwP7SSPK60bebg8FrOzhWQ==","shasum":"6c048e9c0e426b8b51ba3ef91f21af01b94ad7cc","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.4.tgz","fileCount":24,"unpackedSize":63130,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgNp3jCRA9TVsSAnZWagAArzkP/2d0nMWokBDW2xKJqXgG\nb+dbhram48/Q+jlLlqC6u2NAre8B37qhIsErv1BomufQ1b+SEundAuElgyl9\nzBlEATqC0myizWPe0gumdMpWTbDMGhoEh74jHGRTX0sAk0u1qm5B6kfWsFSL\nGHQsP6zNVdgX54yEsARl/+Q4r3xeFSqgPehxzyi9OYz8p+2Are9xuWNCwLKY\nfdCbzswv3/pzrU+QLXDLAc9fZRTXqQsJ3lf8gFRO4Ph2Y/zlR9QvAhFTR8aQ\nOGhSEz3Z15Yp+a1a1ZvmEhlesL0N8P2oCWTOSTnuFcduj8SBD8Ak2Pne+kGn\nayaAL8Mm94HW2WkvgZrt47XLtinlWQfKbq1Wa/2jX89jJSzH5ZNo/kfNTiCt\nGchyXNSYk9+AV1YTL8iQhJgcFe2vp+dFKKawEZi+NQxMYagYxPWee3V+nFCL\njfbyfFw6PFyzb2Te3BF6OnuLgV3MVcc2byoso76VPQroVzOOqn5Xt+gjCFkm\nTNA3wRHu+bRN6ByzLzESmlFYfUlr33Dqc3Mlw+3UPTmicb8ve7P5KKXgEJw4\nI3whKNotStHA4jjhfcMrOasCsga638BEM7xKcO2sSNN+R8tfC0nCJZDTnwGk\n+R9lRBtjVDnR6oiLS4Ysf3Y3wzwyeYOOEdqn/QhH+z6Ts0UauqVWwMmbkt5B\nV5iC\r\n=UUD+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCV7sK5pMt5RzQ4dPIDuRJ0TQe52VjmwuOIbmBWq/sDqgIhAKYLixggoXhj8p867QnKb4PIDIhXs+2pC2fu3RW3FjUv"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.4_1614192098796_0.3441397941774762"},"_hasShrinkwrap":false},"2.2.1-next.0":{"name":"ts-pattern","version":"2.2.1-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.2.1-next.0.tgz","_id":"ts-pattern@2.2.1-next.0","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-ElBtFrLtfZRVsL8RriwCGas1MGsqbSHoVXirJVf+wxl9OWrERs+/24AY43FkEhAf4iNoesMDamwuVGww0oSIwQ==","shasum":"87a86023783fa16cd459a726206e63c6b2c457d2","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.2.1-next.0.tgz","fileCount":24,"unpackedSize":64606,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgN1rACRA9TVsSAnZWagAAyu8QAIaJ1NQbl88dIixkjamL\nXn+7v4sbtnIbz5RHthi70EOOH7w9W8ZlB5sDyj+x/HAZJIFVf4slhuLNQFYg\nBYi18cu2JslVKl11unOzvbZ0xRMzXrMmQxhuGphi/azL3v0vj3LedOTZ70gA\nQ9S4Ak+I0AzPd6irEg7/KnZyW+Wd9jzFjboHHAs/VrJnMqTrmOUSTTm5PQQb\n2C4gaVA9SEiktEFGY0jPHs1kvwPUxKrQNvPZVNJoenzhi4i6mLK5Bc4oj5D7\nnGs+n8ulPz7MienDtx2H5O8GJ5L3QEhOhA3KFkDKy1BYkecfOMGeV+q+1wvL\nsLkVm50h/OOHXJscDAq1lFPDRQ8sX1hpprHp4MTQU+FKo6lEb6nKeF8Ufxx7\nA3SjMSKEnMgP6LLSOA/CEfi4ZUwlCx6amzKxqNeFRtQCQVc0grSMzEgMLC+j\n5q5j5eXzB0M1Zc4cXcTrJeRNt7RVf7yMArqy+zvKe9p00sf2q3F5CYexTTVo\n5eitOK3gBuxHyYFBeg0IPxrCDpJBu/x9/5R/Ui8v7/J/EIb8k37+Mb4t7Pl2\nAL1knYs9MzZRMBC2m+0U01TrDLyFPylayiT+Z5TH48RJgYry/Vr6e9SV9ogw\n3ZorTMTRldhexE7Xt51dNsbpJxJAkwrYbzAzgfekxK/jmM20UwysJMeLySus\nHOht\r\n=Zp6+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGnb/kaOhrHpgnwvhB2a+bGjw+9Muj+U3QFUEilxsIGfAiAcg0EsDmDCJCl8OO6+0x0vXLfBNeVvmkz+E4vQufzbAA=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.2.1-next.0_1614240447681_0.19876690564679422"},"_hasShrinkwrap":false},"2.2.1-next.1":{"name":"ts-pattern","version":"2.2.1-next.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.2.1-next.1.tgz","readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nA complete Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://badge.fury.io/js/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string }\n  | ...; // Imagine this union is huge!\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img' } }, (res) => `<img src=${res.data.src} />`)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .otherwise(() => `<p>everything else</p>`);\n```\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with great type inference.\n- Optional **exhaustive matching**, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name>)` function.\n- Tiny bundle footprint (**only 1kb**).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from Functional Programming languages to declaratively write conditional code branches based on the structure of one or several values. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Elixir, Rust, Haskell, Swift and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n⚠️ `ts-pattern@2` requires TypeScript >= v4. If you are using TypeScript v3, please install `ts-pattern@1.1.0`.\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [match](#match)\n  - [.with](#with)\n  - [.when](#when)\n  - [.otherwise](#when)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input (API response) Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case were `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .exhaustive()\n\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select('err') }],\n      (_, { err }) => ({\n        status: 'error',\n        error: err,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with([{ status: 'loading' }, { type: 'cancel' }], () => ({\n      status: 'idle',\n    }))\n\n    .with(__, () => state)\n\n    .run();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a builder on which you can\nadd your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .exhaustive()\n\n`.exhaustive()` enables **exhaustive matching**, making sure we don't forget\nany possible case in our input data. This extra type safety is very nice\nbecause forgetting a case is an easy mistake to make, especially in an\nevolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off\nof **disabling guard functions** (`when(...)`) and having **longer compilation times**.\nIf you are using `.otherwise()`, you probably don't need to use `.exhaustive()`.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the handler function: the **branch** that will be called if\nthe data matches the given pattern.\n\nThe **type** of the data structure is **narrowed down** to\nwhat is permitted by the pattern.\n\n### select(name)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select('err') }],\n    (_, { err }) => ({\n      status: 'error',\n      error: err,\n    })\n  )\n```\n\nIt will inject the `event.error` property inside a `selections` object given as\nsecond argument to the handler function. The `select` function takes the **name** of\nthe selection, which can be whatever you like.\n\nIt is pretty useful when pattern matching on deep data structures because it avoids\nthe hassle of destructuring it in your handler.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use\na `not(<pattern>)` pattern. it's a function taking a pattern\nand returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .run() and .otherwise()\n\n```ts\n  .run();\n```\n\n`run()` execute the pattern matching, and **returns the result**.\n\nAlternatively you can use `otherwise`, which take an handler returning\na default value. `.otherwise(handler)` is equivalent to `.with(__, handler).run()`.\n\n```ts\n  .otherwise(() => state);\n```\n\n### Guard functions\n\nSometimes, we need to make sure our input data respects a condition\nthat can't be expressed by a pattern. Imagine if we wanted to check that a number\nis positive for instance. In this case, we can use **guard functions**:\nfunctions taking some data and returning a `boolean`.\n\nWith `ts-pattern` you have two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n**Note**: to use this feature, you will need to **disable exhaustive matching**\nby removing `.exhaustive()` if you were using it. That's because with guard functions,\nthere is no way to know if the pattern is going to match or not at compile time,\nmaking exhaustive matching impossible.\n\n#### when(predicate)\n\nThe `when` function lets you **add a guard** to your pattern.\nYour pattern will not match **unless your predicate (guard) function returns `true`**.\nIt might be handy if you need to make a dynamic checks on\nyour data structure.\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((startTime) => Date.now() > startTime + 1000),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts up to 3 guard functions parameters between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => Date.now() > state.startTime + 1000,\n    // you can add up to 2 other guard functions here\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\n## API Reference\n\n### match\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### .with\n\n```ts\nmatch(...)\n  .with(pattern, [, when, when, when], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  [, when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown],\n  handler: (value: TInput, selections?: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns bellow](#patterns)\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - You can add up to 3 when functions. The input will match if they all return truthy values.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### .when\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .exhaustive\n\n```ts\nmatch(...)\n  .exhaustive()\n  .with(...)\n```\n\nEnable exhaustive pattern matching, making sure at compile time that\nall possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): ExhaustiveMatch<TInput, IOutput>;\n```\n\n### .otherwise\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: () => TOutput): TOutput;\n```\n\n#### Options\n\n- `defaultHandler: () => TOutput`\n  - **Required**\n  - Function called if no other patterns were matched.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .run\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### Object\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'I‘m a very interesting content' },\n  { title: 'Bonjour!', content: 'I‘m a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => 'Its a good 5/7.' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => 'bad')\n  .with({ score: when((score) => score > 5) }, () => 'good')\n  .run();\n\nconsole.log(output);\n// => 'good'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables you to pick a part of your data structure\nand inject it in the `selections` object given as second parameter to\nyour handler function.\n\nIt can be useful when you have a deep data structure and you want to\navoid the hassle of destructuring it.\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('username') } },\n      (_, { username }) => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\n### type inference\n\n`ts-pattern` strongly invests on TypeScript's type inference to narrow\nthe type of your value to something that matches what you would expect.\nHere are a few examples:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","_id":"ts-pattern@2.2.1-next.1","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-dKEFYwBoBSutAp/QYMMnu7eSFWsUD3ep8MVFEA1L/jpb+qQXBggNMJQ5lpjARWjRM2kHFOAy+MY9tzSBUdWvJQ==","shasum":"c1c5740f6d3b2e8cb84a248d4bc94b70f2ba892b","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.2.1-next.1.tgz","fileCount":24,"unpackedSize":64606,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgN46JCRA9TVsSAnZWagAAxUYQAIwpC7dIN9VjJU6noYUo\n73LatxymrxLITRXdGc9G/x2wqPiGeCPBKUKzNxnXQkVmm4zrzOyq9A8iwxO0\n+U5QHvLVnyoxe++cJ3HYRscx7liumlMQUWdfc85VRhfB4jsqAxC6nOwRpDJv\nCMFBeXCs347KWCeqOMR9pVFsVqjFXMb1uMGyKjWm1rljXEeI1dIqd+Y9c/B4\nFQA2/E8WExi+4l3pKK/fz1BLGRjotd46JWQr6XOMBWUON3xpcpehpq8EF6et\nNaEwECc+irTi/04QPwwas06CPzPIawyQZTozPmg8uhiWy8t2pAe7cT8isz5q\nafzTilmiApV2PdiDsyimZ4VtOzegFaZOcsC6RHOegm05dgemwIvLwAUfI0nQ\nY+7UWLMqf6GeQxAQggWXZmbDic8DHoK8mtPE38FL03+tHCb5JWKkBJneiWVR\nPXhXeiqXO8RYIDf/9D/sIwT8VaVXH52eU/dkf52Esmkirn+8b4ptrALTWjLV\ntZmSNWD/eO8RLXR8ltsUIrAe5g8YfxslttF+uKw1yuzqXtbiyTjvsT8v25bY\nw/Bjq3z4UKYooZShGbUnYOdmFW7UaZDfMUkhcOs5WyDmzgeXPTSOWrLKBxGj\nRXujsS0ka5bP9lwG1oPcqh6oq7NLkt5Rnme5ZNvcrLwp5JQOsoqsaJDb1jXK\nXsDV\r\n=F9q+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCusHyEN7pymmlNqvV8XWohrXJgiBSH+HcCeKRGFaSLdwIhAK3Vv6U0NkW4VJX1KrTeQS71PRzzqvA799JOMB1CYL2L"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.2.1-next.1_1614253705087_0.033431509132170856"},"_hasShrinkwrap":false},"2.1.5":{"name":"ts-pattern","version":"2.1.5","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"f0ff46b9498a754916eaaccabea5bb6eba536141","_id":"ts-pattern@2.1.5","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-lOY9eVqPZ3JImOKdgN1BE2FgTNbioZ77jwQ0KU7puGK17IYgarSJldemDXVTicAJy7LmDCFum5a1ugxCv4Tmyg==","shasum":"51a1a9221880bec754f5fa8dc5c90f0cde1f58ed","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.5.tgz","fileCount":24,"unpackedSize":63130,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgN47UCRA9TVsSAnZWagAAlCcP/jFLYgF7K1JnErii/qWx\nlMzfamcedSJ2pGOyPL78poH8nSf8XdDovcfSPrCmBxuHkVZvKoR5Md5FFM5I\n/w2SN3Fj8aWhBKLWPT0Whos6laa6XZZLrRGfjSHL9iPOeqMIp6/iCKZDGnyF\np8+3+DVOkNJnr053frTK06rImO/XwgADtld5puwj6Xqk5WUrsD2YYBC2q38b\n51RczBzlqQO5wLEfkwU0oTlzaiirp3bKY0WCmFbCZQWPfqxXsb2F4YZAYcXk\nIICK7mHRKLjmFLs4UFBl5ewZfo/Loox0zmpAawPkTQcvbauFxbu56u2kUBvP\nxLZhEINiPMXrTOFf+YLw+2yZsALFFIjnRlM6wd/27EkPtieGeWhJa/U8cK7S\n+xJlluczxreV+UBNiwx2gnTiygEmmd6+o8UtNouRiDWUpzPHf/BpWwPybwRo\ngF/+Ro6gS+7LK4RZs7c7bjyE1D6d40Oe0q0Rvi1vaXrkcKeYXKLswlEWXpze\nG2wpevdlLSrQMBl2d4JwCX5CSIaEH8LivJnCwL7kaz3jk4+2wbgzZuMuOLql\nx5+sd/VGUoQOgGo3W9gpWNDqtGSGWvJAIrhTIKKF/Gy3h575cAs8tqU+NAdk\ngEiuUenQVJScEBEmqJqiihxlN+A7q7JrTj5tf2q5yhmL123gXZ01G+xrmyZG\njMAS\r\n=fC/9\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC+Fr+c01htyFk1TE2/TApfMP3X1LuBLvdA2iYZKcraJQIhAIbUhJvrVJG3HkJoWTXe/rHJoPvOKzAqaSDeQbel1nek"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.5_1614253779306_0.06600015891156019"},"_hasShrinkwrap":false},"2.1.6":{"name":"ts-pattern","version":"2.1.6","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.0.5","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.1.6.tgz","_id":"ts-pattern@2.1.6","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-dxqjjgIMfW0gAmyNEdAEckN6zgjxRdRvxA+qDrojT3HIUC5+kSVq6MZ334vT5gC3/KsZymgdQ4xikXscIGkVSg==","shasum":"453a3f0b4c99b9dd8ac33fe03f7136cecfc31461","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.1.6.tgz","fileCount":24,"unpackedSize":63771,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgPKGJCRA9TVsSAnZWagAAezAQAJISdd8FrL9uK0ShcMCY\n0xCIGMYDAs1CEt20BKWPwpUz0HoYY+3K75oSwGbBVN1bZC3DPI6EOVI86Zoh\nvgpvhIBCQy7h2P1qREaff98CYmFTZA0LFLja5kNUDNNwJQDFS2k/N38XiET/\nZUegoGh/qh9TCxi3cXGjOXwf76Ymr6Ihnb5g4dHBRobpv84iq0xRMXNn3U/V\nZaMEP98oY1oUabfSZ1UEggjNBDOniTQmtSvJosWtu6aWc5qGQa6abw1bpSrH\nm3iCaLgB7W4lkpxjoiPqZquX+g6YGXuQh5qtnOs/GlNKTfqXZ0FK28NbNa4z\nTU96p/iSA5Z+om/wwOOHTof9w9VS5pCYp2enWdkvVFUyRC4eanm+au+7eaB5\nAgSdR1sxq7CGgKCVJG7WSZ2Eugp1fNef7uTnX/bEzgBsD0WFycTH1i/rtRx1\nqjWN/5RTzTrb1i9MkcQ6R/nczWkEzFE3eJA8ygphwiTSLA2EOVV5RIpNctUG\nuw84sk8fmcavsZPdvy3rTa2ZuEZV8EVWcE9ExAr+n7iqiEjOAiEtEy90pEad\n4T3EGHQ52dtPDQzi5gFGr2uEQo2AQdHWh+WWPUvamnPYafU4F8e2UvEURg0d\nH9ZJBsVgKARp3CwiQhd0ZkuiaX1Ij4GhqJHdq/C4AnT5E8PUzyqSiUnt0Xbj\nQhid\r\n=vxvg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCs1uRiZ1gBYrrf6s4spIcCeZqGlsao1xAxcPgjq4hfaAIhAMONBpQO6Q6DmfbWNALRI8OSKzlHV+o8L++589rtsajf"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.1.6_1614586248576_0.6961058115535199"},"_hasShrinkwrap":false},"2.2.1-next.2":{"name":"ts-pattern","version":"2.2.1-next.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_resolved":"","_integrity":"","_from":"file:ts-pattern-2.2.1-next.2.tgz","readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nA complete Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://badge.fury.io/js/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string }\n  | ...; // Imagine this union is huge!\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img' } }, (res) => `<img src=${res.data.src} />`)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .otherwise(() => `<p>everything else</p>`);\n```\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with great type inference.\n- Optional **exhaustive matching**, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name>)` function.\n- Tiny bundle footprint (**only 1kb**).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from Functional Programming languages to declaratively write conditional code branches based on the structure of one or several values. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Elixir, Rust, Haskell, Swift and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n⚠️ `ts-pattern@2` requires TypeScript >= v4. If you are using TypeScript v3, please install `ts-pattern@1.1.0`.\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [match](#match)\n  - [.with](#with)\n  - [.when](#when)\n  - [.otherwise](#when)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input (API response) Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case were `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .exhaustive()\n\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select('err') }],\n      (_, { err }) => ({\n        status: 'error',\n        error: err,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with([{ status: 'loading' }, { type: 'cancel' }], () => ({\n      status: 'idle',\n    }))\n\n    .with(__, () => state)\n\n    .run();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a builder on which you can\nadd your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .exhaustive()\n\n`.exhaustive()` enables **exhaustive matching**, making sure we don't forget\nany possible case in our input data. This extra type safety is very nice\nbecause forgetting a case is an easy mistake to make, especially in an\nevolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off\nof **disabling guard functions** (`when(...)`) and having **longer compilation times**.\nIf you are using `.otherwise()`, you probably don't need to use `.exhaustive()`.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the handler function: the **branch** that will be called if\nthe data matches the given pattern.\n\nThe **type** of the data structure is **narrowed down** to\nwhat is permitted by the pattern.\n\n### select(name)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select('err') }],\n    (_, { err }) => ({\n      status: 'error',\n      error: err,\n    })\n  )\n```\n\nIt will inject the `event.error` property inside a `selections` object given as\nsecond argument to the handler function. The `select` function takes the **name** of\nthe selection, which can be whatever you like.\n\nIt is pretty useful when pattern matching on deep data structures because it avoids\nthe hassle of destructuring it in your handler.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use\na `not(<pattern>)` pattern. it's a function taking a pattern\nand returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .run() and .otherwise()\n\n```ts\n  .run();\n```\n\n`run()` execute the pattern matching, and **returns the result**.\n\nAlternatively you can use `otherwise`, which take an handler returning\na default value. `.otherwise(handler)` is equivalent to `.with(__, handler).run()`.\n\n```ts\n  .otherwise(() => state);\n```\n\n### Guard functions\n\nSometimes, we need to make sure our input data respects a condition\nthat can't be expressed by a pattern. Imagine if we wanted to check that a number\nis positive for instance. In this case, we can use **guard functions**:\nfunctions taking some data and returning a `boolean`.\n\nWith `ts-pattern` you have two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n**Note**: to use this feature, you will need to **disable exhaustive matching**\nby removing `.exhaustive()` if you were using it. That's because with guard functions,\nthere is no way to know if the pattern is going to match or not at compile time,\nmaking exhaustive matching impossible.\n\n#### when(predicate)\n\nThe `when` function lets you **add a guard** to your pattern.\nYour pattern will not match **unless your predicate (guard) function returns `true`**.\nIt might be handy if you need to make a dynamic checks on\nyour data structure.\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((startTime) => Date.now() > startTime + 1000),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts up to 3 guard functions parameters between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => Date.now() > state.startTime + 1000,\n    // you can add up to 2 other guard functions here\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\n## API Reference\n\n### match\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### .with\n\n```ts\nmatch(...)\n  .with(pattern, [, when, when, when], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  [, when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown,\n     when: (value: TInput) => unknown],\n  handler: (value: TInput, selections?: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns bellow](#patterns)\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - You can add up to 3 when functions. The input will match if they all return truthy values.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### .when\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Options\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .exhaustive\n\n```ts\nmatch(...)\n  .exhaustive()\n  .with(...)\n```\n\nEnable exhaustive pattern matching, making sure at compile time that\nall possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): ExhaustiveMatch<TInput, IOutput>;\n```\n\n### .otherwise\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: () => TOutput): TOutput;\n```\n\n#### Options\n\n- `defaultHandler: () => TOutput`\n  - **Required**\n  - Function called if no other patterns were matched.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### .run\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### Object\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'I‘m a very interesting content' },\n  { title: 'Bonjour!', content: 'I‘m a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => 'Its a good 5/7.' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => 'bad')\n  .with({ score: when((score) => score > 5) }, () => 'good')\n  .run();\n\nconsole.log(output);\n// => 'good'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables you to pick a part of your data structure\nand inject it in the `selections` object given as second parameter to\nyour handler function.\n\nIt can be useful when you have a deep data structure and you want to\navoid the hassle of destructuring it.\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('username') } },\n      (_, { username }) => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\n### type inference\n\n`ts-pattern` strongly invests on TypeScript's type inference to narrow\nthe type of your value to something that matches what you would expect.\nHere are a few examples:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","_id":"ts-pattern@2.2.1-next.2","_nodeVersion":"13.8.0","_npmVersion":"6.13.7","dist":{"integrity":"sha512-S/DBRunmeh9gRXqcte0h8Zr32NFxMYtdFX2QpMqeF7HuybRnn3PQGpaY1xLXJTqwm41E+aKEJf8UtUQjhunNrw==","shasum":"23c3acf6e3037f2fdeb369ac66eec4b2e188d77c","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.2.1-next.2.tgz","fileCount":24,"unpackedSize":67689,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgPKcrCRA9TVsSAnZWagAAOpkP/0ioQNhZ1Rd+8oyqolhU\nSjI++Mf+hzIlnHRp0CWP/HPuc5EfZcoYkLprtLvutr9RRqcW7tglgsCtyYZ5\nn0cFinxvlWM8BIH0vykyg8IYoqr5CHFlgpoHM7mfD7vIeT+FnZZ35Vv/EDH4\neC/0HTBlxNYfy0QRjHq/QjlP2Xo/5y3e4iuJL8xi5omRCBIzBiex/xqhuV+j\nL2gGBFuQQLxhW8NZw28rmMXnnhKsiXHz6tYQynE3KDBxCbyGltG/F4weAk3q\nnl3+8TnX7yJaxej/ldGUdd9u/zJo0Z06H8rQhdeGJImVtfaXaA8KxutCGRwn\ntED/GsmSt8BObW5jRYB+vCU3fd5Xhg1K1oetnQZVlPOR8wCEWmXzE89UtsrQ\nHWYUOOJRKS1G27EccdB/5w6eUAEyRFvpfIHruHI7Ns48UxKh0UxiUh1Ejob9\nK2WCdYBRwUMgd5SPvZWShBmK5tGPIe0ig+LdFg2GooO0LlRoKwpv38/4wnVI\neVNPhDJBVfmyLcq92NTzoS8PPigEl4iUpQtFfMkk3ItgplecofaZrGIjGIla\nfGKuYnBh3uK0ZQqAkL6HXESDyxVzTIbSYk+xYZbdBylm9KZHcrl1/nwaigyi\njISYbF1BrkTI8em2fqFUT6iNk2gPjrFIft/pNsp7Wur7lmDfMC+6N4aKCDT7\nLZZI\r\n=VP2v\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFOZMmL/K/oS7EyBNGfPapsGt63Mn1ua8b4wQjjiiXfeAiA2L41ann6+aXO8bgi6WLYIeD0iuH903/KodvfLy6xCyg=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.2.1-next.2_1614587691424_0.24417933862605268"},"_hasShrinkwrap":false},"2.2.1":{"name":"ts-pattern","version":"2.2.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"4b561ad5156251aee0897672322475e95ba6d28b","_id":"ts-pattern@2.2.1","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-LPClYTSOB45yFhou5wi0x43qnqoZ7Rdz1NoF00gHlPO7nvTNGVcbI0lxuqJWq1eRamR6zKR8E56mDOfmiqzsYA==","shasum":"65db3a2025e539abf4db78202a96128b2881af86","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.2.1.tgz","fileCount":24,"unpackedSize":69023,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgPTK7CRA9TVsSAnZWagAAgcIP/3xeyOH+mFT+pxUuRCVz\nYAmpixrz2vjyuPXlrPjfL7/iaQ56f9a8YAzQUf+8ZyKR8hSPCvGl4GJ5tc6s\n7gj/YIBrJc9mFSLMW37E8Zp+7nWpBdfh4IMaT2Nym+WE1S/oQPbIjhYcBegz\nwm3Bi13LDi0rokuG0gj5E6wJ2Uar4bdvBVaLQcmTz+QVW9Lohoew4IJscrrp\nMr2EBPkknYcOQEffPVyfl5+NXIQ45HN3tNE/i4sAiCrTN14wtO37MfLtPBvP\nHmeRnaO9p8jW5TAx+TlsTFQDT7e7WPUYVNOc+CgXqB8myY3Xh6S5Ar+tug+B\nzlGemG7sgBoToMBWJgK3LO9dqnWo85erRRy+GtPNhps13pAT3LrNcgqjNy9W\nZbbd8vRvXapEqLoarJ6R/63qBbXmLZZJMr9vF5Sm01WGvoFa47W64XT/GhTY\nQxXU7QzMa0uMF4oIVMgnDWpSJaA/HH4Mw4yc0YVH0TqKCNjPqt57/nFx7lzB\ndTB4bE4QOU5Ii8Ye0sSmrq234yfY9T+p8LcCWw9HUtKH13VIfgfXlW3Lmlh5\nvuMTzXr3fRYH97xy//oChrsups8nXbXbW36ThrHi0jDCDAPbSoQsHV+gcRx/\nT47QzjBJC0AG70LrsR2ISmC3ILJ+X7XmEeFy9JloEZcCb37IozEvGdJ1zPoT\nF2AC\r\n=oEcx\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBC49U+Q3UN2BOhFpZrmBbCkgJXtxN+FZZHlhm43wuPtAiBsy+m0h3ouCD9LbYWfuDIlGL/O3EvPJCL5BzII4BXNVw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.2.1_1614623419098_0.2541944936450693"},"_hasShrinkwrap":false},"2.2.2":{"name":"ts-pattern","version":"2.2.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"896fd77f12a265efa244ceffd924a360dfe073fa","_id":"ts-pattern@2.2.2","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-v2qDShuNz2DojkOg+Idc82hnsDH+pGRGeWnoRf0DWwangECmLeU5o9r8hx2abyBjovfYYLCGzR4NXXzI6bgsUQ==","shasum":"624d91207de74de695439888323fb457e0e6f95a","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.2.2.tgz","fileCount":24,"unpackedSize":69018,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgPVC3CRA9TVsSAnZWagAAntkP/0U/nJSYUHHL3tDzc2U6\nPcaNQWrzjctdOdMM1L6mbdYe8pFJ8vqhU7Wm7bZ29faNM+mkiyo5cP4tHN38\neJVXOTS3ahHOMSMzZp0slHJvtWwsBPu+Vs3nGijy2zsVSwO7kqXlakVluRXY\ndHPwO5Lz9AX7tXx2kCxyOWA9lnftZ9SlwyQcswRGDNIhcE8WxiF+oTA7drkw\n3rhOXMlTAHqwek55kLKRmOlbnJ04RaXHUpYlOh0oCjqMfbGf4EZgj1PkG6fP\nI9TGCjFxo5Tqnzb2KM5LvrDPaAt/fqGj4VlrNAWgxzOTXR1gQNr9BmF00Pw1\nz8xKExFuI+CpNYCL2Q8TZA0zpn+wzEk4DLYDcwd3m5mgneRfsotVsbCPrjMq\nCDUFuAu1W1DoU4dmH8BaaowMCzvhGB9bqWvtBJ9gUoFHPld4QPDydYaSF72Y\nXvF3QKyTWC5OZaUfOAhgVYiB8KyHOfY/ojVaTma06ZH8B9eb2OMLxURzbFtR\nQs5MxlF49pXhuyzDj9tZMbN2y7wM0JUE2LUEqvcvTfFwrePFZDZ9zZfSpd07\nppIn6sXRPLjX91/oek8Xn5NKd9bQm8BJQa/IT8PVRdvT8YovOXIdR6Oez5AU\n/r5RwaaaUCiUVi2RdDh3Hrwdur10TKssiyjIXc5HGZxU+JP8qWnCB6WlDn/t\nHOO3\r\n=HmAI\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIA9uwSNCpSih+yL8AFZBJl7aG/uKh0Pr0ljy9io251ShAiBQ5VHPMxWtyRHfm3OFBqlG3i/amAB2D1xoC1wTF0AMMQ=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.2.2_1614631095117_0.1722026871757496"},"_hasShrinkwrap":false},"3.0.1-next.0":{"name":"ts-pattern","version":"3.0.1-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.0","_integrity":"sha512-+b/gZPAajfAcUj36UyPu3YOXlM6/05HEwni16F3J2tqnWkuFyUmQ36ZzmjROCQqMGIY512geVa9P4FF8iCOEHw==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.0.tgz","_from":"file:ts-pattern-3.0.1-next.0.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-+b/gZPAajfAcUj36UyPu3YOXlM6/05HEwni16F3J2tqnWkuFyUmQ36ZzmjROCQqMGIY512geVa9P4FF8iCOEHw==","shasum":"960ffadfa44354a74d36dc52e37a56f51715a185","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.0.tgz","fileCount":24,"unpackedSize":68297,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgQkPpCRA9TVsSAnZWagAA42oP/jAzPH9o+IBsR5eM/NVx\nXqiMoovBE+Buj4On4VYcPKV6zOc6CuvwtYCG6cLxOTypsGcJOrnR06AV6qg0\nR0eyc0Lwiy5EOTAVAS+FWbFNVT4baD+OY+bzwO69tjo1GlqFMWniLa57CmIh\nKTyetRFCZs543BZMcX0kI+Wxk3S5fZxE6/bNLnM8d0jbINtMS8UDXHPjpgPl\n4ER1enDpjt+huT3lckMfYcYQThCcQMrRTnkYW/2itPN0ChD4EXriR2jJODPY\nKiilm9LXLWFhKlslP6+jhRBv9ibY/CiTufgc/RQq94ae5GDoU09oKBeY55Sf\n8kHI8PTnb2+GLkyRuHyq8SMuVLg8yoh0VIw2MdI+alsS4F+aS3TE9YxlxgnA\nTK5MY9TRGVedZNY27AcDe1YEqY+VmfOCRpgUI1rhChow8RScTvOhOf1kxCIm\nZvbH+Gc7IImWQ8U5ZeY8qt+Z4q9p2XxlFAMdNu3FlmZNZP8Uo/gKS8KpnkJg\nmbhuWn1ixJMSMVReB3Q+18xoGos3368VNrI4U6o2l4ycLyp2ZPQlC2j9/mJ/\negL/KMF4F875GPgCpvEErjUgPw44QF1GFp4a8oXwrV5hEjXUUJiEmeWipZPI\n9pdD3pEV8KPWUxVxnzUUJnUaQgFI/fMaftL3IQN8Fhzc/lD8cNvfmn5pYs+4\nb7lG\r\n=0JcY\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIH6oG4owPgnoVsKlKohmhWT+rrRshdUpmMsL1ocDTNxCAiAeFljATTK8m0zHH0YcBeEpRu07LZwAiEplMu+mXqAcwA=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.0_1614955496887_0.3856365804931765"},"_hasShrinkwrap":false},"3.0.1-next.1":{"name":"ts-pattern","version":"3.0.1-next.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.1","_integrity":"sha512-hAES0g7u+ge8ePP7tDu2YbkKd56hRlWRmBGjstis1yRlUFvWu57gNIp8stPhg0egRvK5+I10u+mcF5vlFQtZPA==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.1.tgz","_from":"file:ts-pattern-3.0.1-next.1.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-hAES0g7u+ge8ePP7tDu2YbkKd56hRlWRmBGjstis1yRlUFvWu57gNIp8stPhg0egRvK5+I10u+mcF5vlFQtZPA==","shasum":"62346d1fe0708ab06ca88bb56b8336693a933480","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.1.tgz","fileCount":24,"unpackedSize":68701,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgQ08NCRA9TVsSAnZWagAAj4QP/1h4yTE2kiqCUA0XBO20\nZo+JIv2qaKigBkTkWfUB8zQP7Y8Fz6uAbHckrpasQILDGCrmrK17bwmx1xXL\nUuXzUmtDVyEFqgbbM8Zwi0UxKLqnKyDO7XVzSM1KVgJ8J6TineCKYLGAhgMM\nUD970PAJh2RKRPf2yOZqVE6+imMNHFpsh6PpIsNpjyzA2FOSKj+4Fs17mtZn\njH1wTe0/Mr8h2RhnRdsIQBvIAFBwM7qyg9MFk8saFf9Wd/LwMLWn2ZEd5kob\nQc7E08hguhBAmd8+mkoAY/3zo+2S2EdHwnPoqVZFkwzXRCkUqNM99FI01uDv\nizwxaa+veQ778Qxc3nNDbhL0WZ6WrYJZ3/zk1WLyMj3Mqol4p5v9DGPzWpP3\n6rZk56ioCGeW5clSBSIKXl0CJ2zRNkPYeMUozdlXKx4oyd5BVGQjSdr7Fbbw\nskdqwQ3cIV1cA4ntSINUWrvxAzJuHEts1MYENVydICVQr9p1tl4VWwdznaoD\n4v6hRWmXNjMsumY6b7RZzyR4cP+BlrwUXxkkZ1oNdW2RR51NsNpA/6qYYwZQ\n1q2Nbz6jSQZ8J0HkjNW1wsqsRYe+7Wd8HqT84cs5LittbmV+nqst3uEdr+jZ\n1nffIHb9pLjzsCZ98EY/+5lecGxX9R9+CupQonMxO/HNb+SLyZYif3YXLshd\nFCfk\r\n=kSFP\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEHdeSizbHO02+iUZB0Av2QxM3ASp0laeAzDczpKQ92SAiEAsZ35+IYSWoJDQW1gxhV2bmCeXX+HnycmNWWs2l4VO4o="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.1_1615023885333_0.3049563990516504"},"_hasShrinkwrap":false},"3.0.1-next.2":{"name":"ts-pattern","version":"3.0.1-next.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.2","_integrity":"sha512-Om/Ku9unD+Y2asHfNpTvxyvxOu2CHRqEhBUz4eJDF7GYK6snZGGNcOPmy+EjmK4cUSJYx0sMlXrFv0wyK+Hbug==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.2.tgz","_from":"file:ts-pattern-3.0.1-next.2.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-Om/Ku9unD+Y2asHfNpTvxyvxOu2CHRqEhBUz4eJDF7GYK6snZGGNcOPmy+EjmK4cUSJYx0sMlXrFv0wyK+Hbug==","shasum":"a2bb39caf17fe4dcd9b26dbb3d176c60492a205d","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.2.tgz","fileCount":24,"unpackedSize":68660,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgRKbjCRA9TVsSAnZWagAAWs8QAJ5zCjKivJdVB7aMzgSF\na6MD2nK8Xgppf8iNUpdpv5rVCW6mEpccOtf5mfrd8GAVNEGsFufqGPx6/hWu\ng6CumzMFMVhT0ZdzQSstUKIj0xuU5i+okqaNesg6W5Zw/rOC6EuOmYt4KLQb\nHPT6D8f4mgBKBepjbn9W+YUx4lpUWi9tD7qX/F+syEDPwHJ4vgrdrZoq48ks\n/ocUVOKPDWlzG3oPm7UURFyU8E4FJIVjR5PumGuXPXhJRRy+pWPfuOtWQt7S\nxr8i4iTviXLyFI4nO+C7qweRtRwAB2m+C0XFxwcDTFGZJlDZqQ3zYlmBd84H\nUildncVdM4YnVo0+2/JKMQRSyVT9Pf9j1ogXFQr+vHi+tRZUTxUZ3dWf021q\nQRZuthRxNOZwsPk+kN8QVuVQxCBoxzPye87XqRfv/QNX34uRdvU8UQNwuYjv\nIduX/WYp9wAFA0nqQI/G52bNdjr7hixAf+U9VhFhy4pugdKtg6eI8hMnBUzf\nX8XbkOTvBo7UA5UYtuAxudMI1GCZy7jpnfNb0HNs5if5Kj/rOnrfPTa+609R\nKVKAktvcMKW931m+FDJI/4b1DyCoDsYovMysALPs8oyZJF3PyXo0F+o1AcWv\n9LyR8rh6ZLWjDeWbrUqEkhVIzRHpBmo+0SqQ0GQtZnuIfHZNvW07JROR0Hv7\nj7Ng\r\n=V7s6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIC3IVXQw4JbMkT8qa5Xxg/muzQ0JHxifVkyvx36Rr4FsAiAzxeYUxURfDKkBGmc3gbRMTcQRn3EpzlDPUUSuBNvMHQ=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.2_1615111906565_0.8271974162035212"},"_hasShrinkwrap":false},"3.0.1-next.3":{"name":"ts-pattern","version":"3.0.1-next.3","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.3","_integrity":"sha512-LW9WZ6Ueg/nowklcJo3EwzGUvNULKplFsUzt8qjbXMz7sG93RbJVPB3fhWFYmLkpZgotRY+V3Sb3w6yIE3RTvw==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.3.tgz","_from":"file:ts-pattern-3.0.1-next.3.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-LW9WZ6Ueg/nowklcJo3EwzGUvNULKplFsUzt8qjbXMz7sG93RbJVPB3fhWFYmLkpZgotRY+V3Sb3w6yIE3RTvw==","shasum":"79f02fc220453539c486635866e23d1e9669cd28","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.3.tgz","fileCount":26,"unpackedSize":69045,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgReSLCRA9TVsSAnZWagAAgIIP/3AVxkkE/hpvkuC9JK73\nEuFbvsLi6E2eLkS4C6TcPtOZyB4pSdbnL9Lv76eu2XwtRbCQfw5i19N6hKz1\n7quevVexuzrAYsGMH80triklyTfq4Ng3Kop43fTSvyoF106CGBnMvR/gvh4X\nZMf8bVOmQpFl/hYEWItaQCUpJiSuNpaQ4Wrko2MPl+CbkpvZYdZkgs/duQnb\nnFGjFOBp0LZHhxEgYmMscq0U2wZmHpBX5PyE2CVD171Onv4uYP1fbiQmwo9m\n8kLH24FxM7AviLHWceptmMAkmsIizdYuWH46riie6IBMpBvZo8+lhjlOxN/i\n9m598DzHT8t8iBSrQsCYoEpbPIBeN6/QfWqIJK+pdBKJlQfNvBgE4TyTPqjH\nL60OAJq0RldCI/BUr/wgixc/vmAqGep5OV7noa0UUk7F189n3UxnHSHYKRSO\noucMU8BOk15NXuT60AX980pkPW6+yNGQrtBCOha7FqiJV75ui5eLDcghghnR\nOpyiOpfE9DjE/AvhgqUMWs9LpLDa95EG57QaGvEIjzwsfuTawm8L7t1NnRhZ\nb57dg99F0eFcOs3/jiQoO8qXzPDIJfMB6z8sJke39uB9eGUhjC4neFl43R+M\nq5eNbsd8OxXNNOj8ob9nWJiXVh/q4mz7eOwOWDIQQpfIJBw1Iu6tCrU1gH3p\nbdBv\r\n=lqA3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCtT1nCsVm9bDo5tJr/KxA7qrfwyxkZFNQem1l6IXJahAIgHNE4L5TIj7yEastsKECtq3cjA9OA6X0LY71SCO4CCVE="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.3_1615193226995_0.8504530370953096"},"_hasShrinkwrap":false},"3.0.1-next.4":{"name":"ts-pattern","version":"3.0.1-next.4","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.4","_integrity":"sha512-qDVCCBM7aNaA5pfxSMd3b4brYfl1FiNrTw8qH3IcfcpGnbrDv7DJ7oM9MR0fVvqbRNRYVK3XfAeje6P7Y4JO3Q==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.4.tgz","_from":"file:ts-pattern-3.0.1-next.4.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-qDVCCBM7aNaA5pfxSMd3b4brYfl1FiNrTw8qH3IcfcpGnbrDv7DJ7oM9MR0fVvqbRNRYVK3XfAeje6P7Y4JO3Q==","shasum":"cf8d89a41fcf2d8edefe65b33d28023f37fc0630","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.4.tgz","fileCount":26,"unpackedSize":68967,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgRetyCRA9TVsSAnZWagAAyjUQAIMF994V1Mdl59TpfiXW\nqtsjN/ThbFmc8LrccIW/QbEWduHL2xZVhtetXRP/EcnmmRqymBhUnp6TIAp6\nRNK1rbXTFjoHWJWu1dIccjAaFYHIQVeIps9I204U5nx0lcxFQul1vlmVWQ0A\nACa8xIgpZKqy6hYku6Ami+0iJ3csdHBmeDGAPosSyLLfmBxDp5YcbJXx3AWH\nOfHzKDvvO4P0TPhHjqmPLYAUB/K/nUlZ1aQx9WZcfcnzZj29l/9IIDQnKRMy\nMUBC679X0wLVgCIeldAg6BTNWD4DrTDOO6YSBi2E33rMqNjW11eQNtq1oYl1\ndgT+30F7478EFsUK71Z0abQnxCU/SoUUxZ88i/7qB9E+V7DlEZzJrL0N2qlT\nQAZRKoslQbSseTWnFsx31geRGSSsKejnc+Vzc0vxsK/adaqAtSQltVWxDcxI\nx39mgccAvzqtNUA4bSGHZI1oJ9FnoMHv/IUVm/ol6nbpQlROtOkgcis/ewdK\nkM23OH3zgWscucNi1DskmB8jHAsXXFRpA/AerC0618esI6+FMc4vtmmlpA/l\nYVUgWnaCOXhgKozHOMrXh0+AIDw0Y/YmxULpDAocHAUtXdC8qwv2JGTrJ/zT\nDNCbIgDF3Dbr0mLmw2JLfBVLQr+UEp/5hqe9pPlB3eqpAZPo5kpHvUZtmJIc\n+0vr\r\n=3a3p\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEhamnc0SOhCKD4WOkIoY0x47R4y1LW+1vQJuoKjmB7jAiAD+Y3srZMsbebgQ+OipXqKKRZayPR3JWEPPcn1AkpDVw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.4_1615194994414_0.3154178978043247"},"_hasShrinkwrap":false},"3.0.1-next.5":{"name":"ts-pattern","version":"3.0.1-next.5","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.5","_integrity":"sha512-QHTbvWIYTBqbTBdWwSCItv6o2Gu8MOX+hhC+D2XE7b1BXP5Bnv0Aa3RJmXc8fWYpen3u334c6q00L9FVaeLy5Q==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.5.tgz","_from":"file:ts-pattern-3.0.1-next.5.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-QHTbvWIYTBqbTBdWwSCItv6o2Gu8MOX+hhC+D2XE7b1BXP5Bnv0Aa3RJmXc8fWYpen3u334c6q00L9FVaeLy5Q==","shasum":"c656062e05c8352cd2576cdf3fcbd6d46ab64ceb","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.5.tgz","fileCount":26,"unpackedSize":70368,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgRmknCRA9TVsSAnZWagAAuZMP/19yQ6CQS9txMd3eHCiP\n+W3FfFqcbqA7x5jdJuvvehCOA/nrzq6f6H+qMa3+tl06Fwa/DyZcVzY83lAl\nOFYx0hagMAM1BY96fIXNJjPhBtWQeq4VYLmsLthfdTL4++M3j14Tad4BuhOJ\n2Gv8DRZjb11DrOFcnJvFSXHMGcv0su/TDvgNKAnL5my0ukictmlZ/3FPrOHK\noIN8SqmhyySNpguMnXL8KU63ufZiEX2Lbr0YD4/H8P4ts9svPCs8BtuEUeJy\nNcdScmFFKTq1enVzATMvuUAn+sknkfIGqvrKMNWKQxFIovqbHycIK0Qbbfdg\nPMjKlNyYCmX5E65snFJJkO/FzWivU8lhLVeVkZFIjodyU/Jb8+GZPzUXhbIs\nLsasGP673tWJ2+J/r8iv+5NB3HzEdA5fqdymRelwJ11LvD4NVFQq4aQf3izy\nIIh4zS02CzZ/IQbtWimfj4vVzoz1bwHLWd9uafwxeu2iO+ebBftUf0EfqYr3\no4DtcF4tVoyGillkJiSzcFv3QwgQh+hL23OvTo/oWMKJZQ4ZFTePxoAQmW1R\n4nCKlU00u1ZbdjeyC3fMu45OzbXY9bJLZiGkYeJlkzjjSzKo/7kp7QXJ15SZ\nJZUdXTwDNcMsrcggCYc++HwSw44Ek2jSTR+hmqZECTDM8Hp3VxjKZOIo+12L\n37uc\r\n=hGKR\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHL1BH6TAAs6mofyo6hm0ubnR04I0jD5cuhnRsB3mBBXAiEA4icdVcSakNmjhQzLlZaJNFeWSQEcpWpuw+c55188rR8="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.5_1615227174671_0.571084620812707"},"_hasShrinkwrap":false},"2.2.3":{"name":"ts-pattern","version":"2.2.3","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"1f1ebc011eab4c82f9e282cf844b758520e26ce2","_id":"ts-pattern@2.2.3","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-y8igTfl23okqmuqFBjfW7SnqiVHu9Am1B5+TLO5lp4NEyjZXEBytmNUrbA/cOco1tzsQ9pb/lcxu9UFVj7n61w==","shasum":"6405738745d17f8d62518763b5c71194d7ec9b9e","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.2.3.tgz","fileCount":26,"unpackedSize":69900,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgRm4gCRA9TVsSAnZWagAAImsP/R+SFhYwpOH1zksfUIuQ\n/DcZIgnfOYNzD0+9wKF8H01KNh9H3cqeP9OpUtf531eOwDG2ESJaGALczNUz\n/bfkBUwDofhtDaTIVy/KTxmEKHXfxOqVzihICRJ5vP6g5zhGnIz2rNgO8lQI\nvDVqspVcDj37sT7aQPQUXtEA8f3Vhwwd19hdIPSGriBNx+02efkOYAD5ItO9\n15b+57fwjReaaM+LmaCu6FBYQ299BRIuuLr0l4A06c+xwkVHqX1mTbpbOi3t\nb2gTR476NdKSXKMVem/KBqpD56EpmoRKGCEca1/oiytydsX3mtsSTZW89IvL\nOeZ4ZbGZxkM5DwpKP9H00KU+3ReO6vv6FNfz/ukAd8yP0eWfNn0J4zubeEQ5\nB2E3fCeYl0vYSCba+HXQjBCL5dPFBJ5q9Gg5gwaz01FptmHIEmQ8FUXHLrou\nL//8x15tF8lqe8oDeFXsgAHCA93l9yoaY2XL0cHLAIVZqB2QnQaj2xTH98Ge\n0t9CVkdgwvrkukFwccMMDT4kH2HgUqiE1Acrl1OHbCkXWhxEQXz4nMoSI5h5\npXdcEc0zYby5O4vSIyVptGhX2QqMlpN57BbZnVQFrmMY9Sx8gN955uczBnQx\ng4IZmgvdjJuFU5DatK2brbNlMYInV2RdZlfy6eh2HUYeuSQTPbvSL2gP4iup\nFpv6\r\n=NAky\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCtuAcUZondTK7xQN++WU2K+xwLhSxuE9Lbtn66NI+5CgIgODSNM7dFnj1SSz8NXz2uvA+sL12HsFhSGPXL9JskLuI="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.2.3_1615228447958_0.5740604886405898"},"_hasShrinkwrap":false},"2.4.0":{"name":"ts-pattern","version":"2.4.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"ebafd5fa7ad34db5aa2895fe8ce7e4c46431ff0a","_id":"ts-pattern@2.4.0","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-DaKcS7nmM+yFpLjyUj1GDc7seLDtQpKUSAuB9q47DgmihMtabQuM/locB//HsNpZ0bMb3rR3UKtzICzIEPE58g==","shasum":"638442d5df86a076bbefad8e4762080e7d5dbb4d","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-2.4.0.tgz","fileCount":26,"unpackedSize":68282,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgR3huCRA9TVsSAnZWagAAZN8QAIScWYtuFEAEKvQ1TYXy\nVwMJ//Jn1AA371kL23mXwZWTHrHAWbOnxFe/cHOKzCKGpnN2P9PPyD1wB+Lx\nq17khk6JENT0J3GYbPWAqTisVHaSXDT6nH9bMwVjBQgs7QpFdsiQwybv8Ma8\nLzgCHpy7ooyKUUv9SyNG0x/mjpPW9EViwd7s1MEOPZ/+amCru+fmdjg6okZd\nU5TS+iiq7nkBMCFBUwT5bYxV2jSCP/nitluYx0vZpBSqtNRDlmTfSOR0pRSN\nGWCYsz3BT5b2kNiQO7jvU0MXOOLJY/eYJKfDDZD7UIUVXL/3jLnAJKfVXRaX\ntpS8CJwT+Ie3GY13tJWmH8FCjh528qEdbt0lPqGmDZstydlSSLMbXB0u14xl\nOEtcn2j41LuJP5pBoYnEXWRiF7JhvNUPjMP0cJllYw05p31HaOoKLTRRZRGy\nZr3lum6S98fwa98+aGzLUs800477WhYHKa4SVZ0zRnAAWhZduJs+KN/zF36D\n17LpHCR78/uH0s9ytu/E/v0keI7xuodd4FeHC3uLh2o/k6UFF6tu1UaW3ZY/\nbHr9UjtTSMzG/RMzaPbCCFvFJJ1RhGVXdPA/UPVldxG8WqFqag7SOO+tmzRM\nmXpj92//B+ETzb+On4WM2LZ+az/PAk6rjTgwEy9C1zafux5DMcfl703Zep12\nKLNY\r\n=hK5b\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIB19zJfu8HTTEoKHu/D1U6o36205Jp1nc1z+9ft9XzSIAiBtH7bMen0kofvu5LamPH/aWHD6JuSi2F+uM3cazHq4ng=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_2.4.0_1615296622402_0.3690603781229882"},"_hasShrinkwrap":false},"3.0.1-next.6":{"name":"ts-pattern","version":"3.0.1-next.6","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.6","_integrity":"sha512-rz4iTn9PggK/LxEuRnZEZ37vyKkKeMbWIHLi6vwuA+3IV5G6+fXGx3dkDlaNopHDX5++wgrfTq1RmNU2ye6kzQ==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.6.tgz","_from":"file:ts-pattern-3.0.1-next.6.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-rz4iTn9PggK/LxEuRnZEZ37vyKkKeMbWIHLi6vwuA+3IV5G6+fXGx3dkDlaNopHDX5++wgrfTq1RmNU2ye6kzQ==","shasum":"13ed951f1dc42356a943c959062c01492426209d","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.6.tgz","fileCount":26,"unpackedSize":70171,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgSKh7CRA9TVsSAnZWagAAUEgQAI4g7UOklLrycecASfO1\n9fnVtf2ifWWRv0UHoY6INox6P/CHZ3tJBULOXBhD5F+oeRc6zWGfnUdiDeRK\n9a0y3DHQid990gbiIh6O8EQdVPJ4//HgJZ+VVUzqE/se9XYJI3AT3tNqF9NR\n/VmJ39HWFdgQ6P8k6qhMu3kxtQXhnfeTFUcs34weByfk8ve1DlfSjpGmjnIa\n6hcPVaE519i3xb45eBAfV762unGsMB2rVCj1xZJ34+uzkYJXcH4ovIGhkKfq\nvo7M0ueaiESSzM/8VCYFoqiWswgW4NFGD2DXDSxRWxg9HqsOeEGkF5iq0nRk\n0FQPSniBbhCA4CfBSb40RQtiahzi5DBC0xDljpHKUjTgPoWoWocytNN2jm7j\nUrivQoIdsfG7BmHW543cxz2eRMTfTpqFOmWnuIYSink+zGHV5uGkEQR9LMZ7\nbCbb0mE4s1ZNfNF+eKDn9RjXBiogkItUU5zF338x9MACX2TV87dATJlwEvkz\nfWcEBldaPnGcsE3ExUSlpf3Ic1wSgpXGkPwpqquRxQPkOlZEQnduahEBBs4h\naMXgCt0mT6KSQGqgmAHe0X/wNjKx82RpZUmfNKbXzpXAx+a0ZnllbxZGX9K3\nOlqQckNjjccbCfequJv6UbJTrYlZiHWd921lvdMk94aoG4iVaJ+VmtgFlzJB\nYR2E\r\n=FVui\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDAULAD3n0jpQEuTjTRBP/wGjv40CWmXwrOghZAK1SNjAIgOqgdY/0EScV2gFmQ84fp42/oJNfP23oR1dcPZYgnFa4="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.6_1615374458414_0.4034987473326137"},"_hasShrinkwrap":false},"3.0.1-next.7":{"name":"ts-pattern","version":"3.0.1-next.7","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.7","_integrity":"sha512-WkD7939dJ8W+yC/DWY2iVosGMy8TlXZWMkCbLMQgGJw9iaON0tSkZoojS3B3jnO6vUXnDOLMBZYuzjfoOT7YQg==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.7.tgz","_from":"file:ts-pattern-3.0.1-next.7.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-WkD7939dJ8W+yC/DWY2iVosGMy8TlXZWMkCbLMQgGJw9iaON0tSkZoojS3B3jnO6vUXnDOLMBZYuzjfoOT7YQg==","shasum":"1884ad67434720a3373e80e71a5d33d162e37941","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.7.tgz","fileCount":26,"unpackedSize":69638,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgTIKKCRA9TVsSAnZWagAAqrEP/2WMa7GGze9eFGdSdbU5\nCYrgLvJ9G9iuXtxBwgddA3eTOgb+r1JdIx4Gcu0TMb6OGzqyR9gp9Rm45/o/\nDIvAihg4bOLL1bCfOLKh2XuOfs5z+T7UDE6GcwTsp51A9iZNLn4MlxV3tFDe\naXwb1OeFDMReD8p+rxSu1UZ6tf9hkdkW/q8gEGOSruJ9fYjJBXMmB8GaiLdn\nmhSyvxWHjNmYkrt5No5LyHkJaudVSrI3mXJhdiYQzC87GEczbTKCE6U36yW4\n4ryqcfOSAfhnohYmulwPk5L8MTEZLK6GKAJudMdIJJdBjWsS73l/9T1ElSpH\nh1ImHu7mg8jOSwgMZAip/EQn9oCWpddW/nYUghdCNHv/7bq6DOMtBNsUOPsm\n6KXERb0X5potdSw6VwLNBwgp6xnoWyJyCUJVwHOLdW0PGScWWWUL29Jd2/FZ\nDVDoWl7FfimhKP/oBfL00/58tsOl77s+0p3cTfkYbUMOqrsLA4anCYkJ3J/i\n+EUd51UGSdqAH0V8kslC5bkKvfDOA+CliAahnScrX2A5sOauei26GXctlfHm\nZG93wx9jgFRYXSh0CLN/39yjyXnENKD8Q6bHJaAhnM7NfA2WZea6E5lxtZJI\njWE2iVfkYOOBMPBnAcbYyF+ORrSYg/AtWbnj5n7sUdTG356n8Av0zDilsLDC\ndxPb\r\n=Sgew\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAcaJhr2rzcnrAJFZq4boWM+y41266DYkS8wsITUcCCpAiEApr3/wowSedOTjVJgb+pY4j5ft01ZjyfnHNQupDm/Ea4="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.7_1615626889525_0.8378018757050341"},"_hasShrinkwrap":false},"3.0.1-next.8":{"name":"ts-pattern","version":"3.0.1-next.8","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1-next.8","_integrity":"sha512-hNXESVoL9hJ0jUAOogPW6LXQByzEYFbkQmB2/x/zy19wBdkeq9yU1zrhXNaG1mMfW8BDe0sPBSpdGgCg0a1mjw==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1-next.8.tgz","_from":"file:ts-pattern-3.0.1-next.8.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-hNXESVoL9hJ0jUAOogPW6LXQByzEYFbkQmB2/x/zy19wBdkeq9yU1zrhXNaG1mMfW8BDe0sPBSpdGgCg0a1mjw==","shasum":"9031db7d564705f1a18fbc4af10a385ce266d3a7","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1-next.8.tgz","fileCount":26,"unpackedSize":69212,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgTdfxCRA9TVsSAnZWagAAhroP/3mX1vEPNyuVRlTcmkei\nbRfTiJnRO50U5/zdy+6ef+Otg1fXjSfDAhl//3Py27zewLp+2KgifDf4D8Jt\n22y9a2WFsvfqmgoaOgxZcMuh93YKjmmJHzqt87L3jtccc4CNNGlZOdbsTm5v\nibsQ/2AyQDpf960G0eY3T8YxBlOl8IVhL//DmvHhH8a297yqi/4jF5tp5bTK\ndOGdJNYRYITHjros1RYg0qLe1m2N32AC0CMZXqiRuvqsJUhMBEDjoR4QSKMu\nLmgRxToZMZ5LQ79xpfPOufHyGDSrpjm4dNv/zEONE63HGVvW8CWpP/IW+mpr\n9qzvxF+SxMXEW7P/Gxbeow/QrhUYpNKykExiiNAYMrTmTT75MK0Jzxt1TVbw\nyXwmWpD6up1SGUWfPY6t/L4sZT5FxQSuqfQcDJn9SkuyIv3JnYDXuKX5p6LM\nm4c7VknK/T2f1NR4wP147R7Yqr3341zB6cqzvHlKKUHzgy2n6lmrtyraIj1h\n8x4Nit1dzieEkEx5SekiAjVv3s3poSM6FNbUfVuukBKoWnYx7gjjr8KPbskv\nCqieAOE6uJvblCEcsgEpVEz+51wzNbY0PVr26B1l1EPW6zroyySL0gVRoVdx\nYns8Q5CDG5Gj9rpOe26bLBM3MMIbIA/5g6nRQ4F1o/X8vaPAK0bhb2gOEqcG\n4o0J\r\n=svlD\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCBFiN4eyuK5usnLRPOqWDhymjQPZohPb0jXQAhX9KauQIgCEzQMfg9/MG4+LNtlME6mbNvmxqnK7fdJOXFOZLOyw4="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1-next.8_1615714289307_0.7394423813153166"},"_hasShrinkwrap":false},"3.0.1":{"name":"ts-pattern","version":"3.0.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.0.1","_integrity":"sha512-DU5Zx/w1idwnRubNmKerIPJpqM+ByPWD+PMTt0KGPx0PkgkvCvt3LTl2EQ+Bta1G1mLd+pbtMggk3v008QAcXg==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.0.1.tgz","_from":"file:ts-pattern-3.0.1.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-DU5Zx/w1idwnRubNmKerIPJpqM+ByPWD+PMTt0KGPx0PkgkvCvt3LTl2EQ+Bta1G1mLd+pbtMggk3v008QAcXg==","shasum":"097e893c4c5f70e50596937598682a7d207e49ff","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.1.tgz","fileCount":26,"unpackedSize":69175,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgTn0TCRA9TVsSAnZWagAAE9UP/2mz6DWmlXUUTNlc7qRv\nXrrBW5pAwfwp1ALLJ9TVHlGHqsUfQn8WdZAx96LLTMaytuqVkpDVvxPmpusT\nw8D2FsGq9U6VsHp9r4oeGofHDe5AuEF57U0TVmif7KEzoqyB/5HtKsCJi5ep\nP17lbHAbp8b8zEYKgbSzmmOD0zpBh3RfZhaaImi3uuFX/6lXxXRPuICtvx8U\nMUY3dQwMcMl1nl6r8R/l6TVFjegIyY8gh8ALohLMWlUxsYAW7U8iuU6tl9nQ\nB/a79h9SNTb692LVii/KJvQMMefCDlK5roHZjEF1TiO2y/TRC1DPWu7jKZb7\n1q+SrUedu1G5ocHvjcC9zTwIlBRh5m+kIFdslGzUYkMoaNYbccfwqqrV3x2C\n12jVNDnLzBak2Tpd4WUXMJKenkGyTK32jhRNFaDqL5Yp1MAxUbZIKhP2i0wK\n+QN5V4fJhIsRljVG7o3tH5Hc6KT1s9K0s/MUvJIaCOGDnLB3wsHUJIbLQWCH\nVl4epSkJFKP3bereTZcaL1tiZ7H5A4gssYLCTMzkXbUgXkT8NhX+xvD3gcrG\nrge9kHva7dD9kbpWPnA5Nlb1ID5viKD1KEpCv/o4qMHepI2xF56DhJO1RJL9\nSrF0XIf2gpG0tjjjGIYtlZhGJZK6epvQrCAKxjwzMD5lKhmzBIkm94XOhPLo\nSquw\r\n=hZmX\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDncAtr0JKpj4gt1I6zix1Uvv00VBcDQZa/Icudz/iumgIhANq7usca6j1hNp1CHzDeHe46tjK4OsKukLMDlJGezPAu"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.1_1615756562281_0.04923360240150165"},"_hasShrinkwrap":false},"3.0.2":{"name":"ts-pattern","version":"3.0.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"a2060156d5dcfe9973868fff78ee0dbc290415a0","_id":"ts-pattern@3.0.2","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-s0kJXh1g67Y/qBzqXS5YV+e5sf4dVE+XbPkI6TbL8ViO9MHs8GMhYJjRlH1jgOFBZLXJsNKtqQ0IkObiyaHD3g==","shasum":"03f476cb66d89ee3b32607c01e5d676872cd1a07","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.2.tgz","fileCount":26,"unpackedSize":69175,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgToAOCRA9TVsSAnZWagAAffEP/ibn1GV4pjchrv48DgYd\nyH40PoelAioiNgfFB5BS1bg0x4R0nQ+9uOeVqD4zD9aXCvT6rbZuFFTlwll9\ng0Jk+4dmHenFa+WQSJlQdrTPDbO6wJHMLkGC5DMXw4jtbxWITuZPtdF98ZQW\nE3lMj84jPUTIhQ0fzKn+rSvz1IUkMZut1qI//HtXp6gD4sEMihkJiZdfXD6V\nhfk78FDltkGWt8i1dCN3bp7j8Pfh177/Az+Xi95iDh7o2TImB/QZtrU6IuAX\nZl9rDV5ckyHDURk76KLfdwS0hi2b3mW9rF1AJyrEhVXMqnWCZhBKcYFCh/pK\nWBez0qDSwoWiLOevuuS6hskPiAvSrPOyrEWaTkxqUMZiSYaQnuxq7BPaXX/v\nRRgb7Qq54ubiCkmiMprTr0bIruKPoyc52aszx0rUYbQ5G1vyjj7rGmZKSxWx\nGUkYLHb9IRYgkj3EqxMktYqyEaaUb7mRCngvKmjl1tcjY0fgjcxmmoA+KIBT\nRn3cjVQxodDfDMeZ/xLidD0JcV/2qZlIz6fZEEB6A+ihFxXbY3EJI12xajMU\nQSvo3PKwwoEYNC4MPRVxQYJwHgOao72YHYg3hNZEJeEgb5r5ZHUxBcoDVJW9\n24hErPJRFyjkXTJtdhCOICS+bp5MHp6pQuVj26DCLlfrPxxlLSk0lpt40yyk\nf46U\r\n=RZII\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCGzLBHuIabThfq2Xz+xAdwpC5EWphlSwEKf2QxIF1CigIhAPbW6V+ewycGsAT4nJyDM9EuO3IGKBiZoQwN/vMEmL0K"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.2_1615757326045_0.4731270868783648"},"_hasShrinkwrap":false},"3.0.3":{"name":"ts-pattern","version":"3.0.3","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"38f6bd70485c311192a10b7d4f3eb8dfbbfbf06b","_id":"ts-pattern@3.0.3","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-e9Pzlh/KuoKuI9ZA6Uf1Mbb2ABsbRNMcGyjyBqtksHPmO2aM2hLfn/bBSV2BzPHg3JAjxFopH4nMwA6wDwQ/lg==","shasum":"d13585e9bd2f46325b350d49cd3cb190b00efe86","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.3.tgz","fileCount":26,"unpackedSize":69449,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgUGu3CRA9TVsSAnZWagAAVMgP/ipaQnX8S8jy3RSYmW0S\nOyGkWeycw0IKDTgbOsIMHK5ffo8Ne9f5ruy+515QIPOOWr7yIPWxGq3mzZbj\nnS1CxBBQC/hBaQrkf+M+w2wP4P7gVJ2k/9oIqR6XKnARMlxEjQZ8Zj+y1fCS\n217DeZ3jo39KpSbrga7kGMwjThqFMTInbUB7TA44elVBBblaSEUU2lL29j0h\nQs5zaE/og06GXJlioudoNeH586sOCReTE4EAwlSraXf9MnCvfRLXYkL9x2iM\nhWVSxw2kzbok8DneFPRTCpMLjlCK0FhA8Gv3VJX0dpLDnfOOelXymUhAspxe\nijxvvJTN3b4LXpOPBQQjALh+gfVmH6Bz0H0wrUunBBOeRv/qCaWQC1s89RNa\n6Q/j4DONDbV2jNlkkDtTC072MNEy4AcrHTMo6R6SB+7J7UFpaLv9BPJ6VZUq\nyN+xU+bq8QYBn4wHOpGo6JedwpocPzP1I5vC3yZGUG6NTEXKer84VRphbIkL\nARbij79fhWKeI71bxbXOFOT9Vl7ZMSY+PlQ1nnp0hr9qxUueoVwcqaTooILH\nVVpAIDPovlDjFlIz7mtOjfNw0b3oqbsSffO3CIySHGx2H5TLEa4pWeJgo4NC\nOP+p2O+XTLXhIDpMD7eIbCJOtyZf+CtiipTchmCoov7JvMdhDG6j47hhywm4\nqOl8\r\n=h9cw\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHOaHjjF0V9urjPQBYeZY0W7sSsUPADz4Pp6IVUCQ1s6AiAI7Lg5uYHCxrbmDzLG2cxytMZ3CJEHzt914pdH2SRbbQ=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.3_1615883190529_0.27291718741222204"},"_hasShrinkwrap":false},"3.0.4":{"name":"ts-pattern","version":"3.0.4","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"9e3ac6f0760b525599c51a4793a3cd1fd3d82350","_id":"ts-pattern@3.0.4","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-YQQSR+1MMsUH8WBuh+LrHABmGN9iVCxAI8I1wkBCtAWfvJkOPpzTdSAAbtdehSnUiOh/fjdwQRjpHK0Eiv8HYw==","shasum":"eb1cc9039408bdfc77abf2fc9a2b6304dc50f764","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.4.tgz","fileCount":26,"unpackedSize":69468,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgUPVdCRA9TVsSAnZWagAAqnMP/RMSJeUqvsLoU/EY7oGX\njI9gudj212WERQLE9ScJqYYCas4HmBEpYjR8nOXK+fl5drnK8YejvZ1GzSix\nDI4QGlh8fqfi124jW8HPAJkBD6QHv1qaPjfxwLZhNCtteAzcM6gVaiLQSaMB\nNNy1reEtJrwCfTi57gZoW+0U4icJuDn9chetfbzKVB2duK0wONZ1FX9sOsL+\nxYrePQyriuKu/Wmx/NnqKJTdQ2hGRuv8d6ovLI+13qluPXnvs9bEcmYmoqRV\nzjxOMLDMY6gIaxv8TdUU0uhp83sy2nsq14g3J4KuRq2lKuoGGXQRLZoychTO\nSKOngIKeno8mF8vqC8eF4YSJ9mPh/U04u8vHJDYbPJrHhh6GsCyB13a1DTSX\nd6FLser5yOXvzS7VLN4vTewB75pUVm4+agiXgWBIrfIarkQ+LOrePOHFlUXj\n3vuKx4nhNjio2Rydf2pMwILd8/o+V/BvxYId8ZakSA1WlVQN3+FKtWehOPEG\npVs4vfJgwN7tPRKHmeAX1XNJ2dhpV98FJmYadqXh5ps7SCHll5JfbH7N+J0I\nzSly5i+KNnbhkzOueWLxGMypQS6sMAK2SQqYP88wscm5tfPcdyUWZNjLa/WJ\nWYlEz+0Y4hmHregd1g1jDaqanrTZdbDehNeRXTEAhudkxoKn7rWVMqmF432d\n4Wes\r\n=yj8a\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAy0RsReRKWBhS/ZfVRD2TzPA/PR827AgFo0YoXVe5+MAiAdp2ohozWuqEcBfIBboaZQDGj844HZHGAxk0BYlpsXvQ=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.4_1615918428711_0.6868798748877816"},"_hasShrinkwrap":false},"3.0.5":{"name":"ts-pattern","version":"3.0.5","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"94b3a6e14d7996c2f47582121d3f9ad8c4070b18","_id":"ts-pattern@3.0.5","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-rUI3oEw0xOiyj4y7k1VYstCYDjGZwSy25/lta+Wi1oo9vHqmWRHff+A5bFFEc0X7AGljV8bYgf06ZtLG0H+F+A==","shasum":"eefc36a996c6709f9097ecc88141a2b3e228ca65","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.5.tgz","fileCount":26,"unpackedSize":69550,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgUPhUCRA9TVsSAnZWagAAXhYQAJtcIIgGlQlHBSIBRgEe\nZ8mTJ3aqvK69AigkhC6n9hLQHQGparqQIa+pZFvrh3mgLHadSfM9XNSpI8Pz\nvrjQZJzsQtGvhVRtI+f/sXPf249yKo2evJRBbax9IQLE8DRTkcogVKtQFvye\nh0sg35GH0ujcPAWZS2X7vCJsWRfxLAsdZM6dIjz7S02bntTE5+7WgGOrduoj\nNPZtwZUQKd6/yLJqsFgSZJa/KRYIxODFQ2EbI2xjW6ZgN+LnJOYPQJyTnYts\nylRZcxjuU0lNTmE/JooCM6nh/Qvwbq0QATQ2tqn2HWLCUX9obZBXp4VxfbmT\nHEMJHXb/btx13QwPnOTvYFEXSpvqMcPqiMCcciDcLDme/Ig5b7P3Xyc3xRhW\nBp+Amqw0AC5DMFhMkkL5lRTtkM9dZCHztAwL7VMACMW5V66kks8VfuOmjB7w\n5IYsQHe+jxAYv4xGw1IlDbE2vIBIenyQWb2rDnBLUjrU0T2PcGS+cUtayNRJ\nOackL1RNdoAoeVaabxYj5LwnlVmjzUsLRjMGLnrxjB09evgwUT5XxpPrQTe6\nSAC9PQYjyXspb9KkLXFtk2G9W/nwkTljlHbYF5dKBVPLl8nJ3g0sJR96wqNM\nq2zEbngUx/L1Jk80ZPQhKquvl9ZsxBy2xWpbxjrODkxF0/FJ65Fm/PhIZXPh\n9L6X\r\n=NshL\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFdzC57I6ZQAJ3Dt+VN2pqM/ARINEXT/4qkZ1Ey5bOcMAiBfSdAgGhUtZnPZiXEzzw8FDkG0ZPMb0pe39vUZNJNJUA=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.5_1615919188360_0.906643330185529"},"_hasShrinkwrap":false},"3.0.6":{"name":"ts-pattern","version":"3.0.6","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"3548fd32e6dde9eee60a772d24f237c96496c900","_id":"ts-pattern@3.0.6","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-QZMUqelQFCaT2AQbZh6BVmGARcIibT5GaBLsvMs4CFFzLkLbE0vHS7Upi3AczTwfbC92jmKxKpja1QXDrhWhHg==","shasum":"b837872e9b34175dab3dec626cbae8c299ba80c0","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.0.6.tgz","fileCount":26,"unpackedSize":69929,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgUdL2CRA9TVsSAnZWagAAkPcP/R7sgKqzCASsIYyMRvMe\nCkGY7b4Pw/mJRJk48yGeYLcMkICqXpBv/N8ckbtDGsvHfIko4EP/lTAIurN1\ngMu/20pba6a7zwODdEm8OSkee4S4BCkAzkjz6MPQZ85HNSIYQyleDdTL37fb\npmjMgtD4kL+vrbmjzLhuYzEU3FoBo1r6cd2083SwummIAD5Ws2mIH685Qo6t\n2VYkF0RR/xXB2UySYjtBDXbpzdJQcdScg92O7nDB131Gnrx989cfSLoMDFBN\n0CZNNk2JShHaCWmlbzMuAou4Xxum8RGlRFe68u7eSyUUz/gAsEfw0wjwM9bB\nNysWRaV9hLupWKOAl6J9dXFw0ZFfUfAkU+aR4g5OeeyD12qt1s/OUTgM89Bq\nZuPRNpkye/TFIKUD4NM3HWaoo1Ipu4TWQYO7HQp5Vy91zmzyqGE8qN3jwM7e\nqVZlq7uIIrHZPxra4u4fQRdR64HhQ+Ka5KLqdDK/ov+1TWFsKGnIxCq/oVyn\nE+dzwSevzTTJ50qo6FWw2stNhZkZineS0O3Mc4EqGqFw58Zku/TCeJOqtcRF\nS2DylExKf5k241FWLkT1/ojVkB2ggAaNfNk+xuNDBqz7uoDWI/rY98yr521X\nHeZF96wUbh3TP05EDCOiFho2JI+KOvJ+vQDFWvulVoCbPx8P6CdJCon70lju\nnbrt\r\n=oEUi\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDRU8tkTSsSKxoPPmy53+VYUXYG462y/+8l3LSR9uds8gIhAOka5UqUEiwSmo6kNaGq1ywLq+T4dptgRNJ/a9pvY9r6"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.0.6_1615975157618_0.47873584386234125"},"_hasShrinkwrap":false},"3.1.1-next.0":{"name":"ts-pattern","version":"3.1.1-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.1.1-next.0","_integrity":"sha512-3D1VNh3DVl2rTodMNF+v9iqaWDB/PBcK70ILqrNfFgUQ3XefqqMSpamFHGoRq6gVnc5vraFur+HSTCd1CoJqgA==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.1.1-next.0.tgz","_from":"file:ts-pattern-3.1.1-next.0.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-3D1VNh3DVl2rTodMNF+v9iqaWDB/PBcK70ILqrNfFgUQ3XefqqMSpamFHGoRq6gVnc5vraFur+HSTCd1CoJqgA==","shasum":"d1555f89ab9b6178de5c5de0cbdbe717df6612ed","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.1-next.0.tgz","fileCount":26,"unpackedSize":70186,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgWaj/CRA9TVsSAnZWagAAyzAP/14unCVG5lsLlPzyZp+i\nNLkcQHop7vzTxo59GK3gyzR6ZybR0+xhKSuFtONNJHf3GE1YBSgBWVxGNPkk\nsLC6Ebz1wnSaJN7YD9cQXJLYPfoF9DOpb2SFN2hSzsP9EXME8VXUk0jmxGG+\nP0OR761rFEHfdbQS6oWAH/+Y72hAaY5BZn3qtv0Tu01/AlZx08otQwt9t10r\nQ7X88JtweEGZj9r4iC2AvRwv1Nk01oGEq96NAfd3y1LQlfjlo4OoDTTPqpyB\nqMrl+IUms0l3vrGnY0iUdU8qfTkg7vAuZI/PI/OCDG/oTtwnhaxi3OcuWPwY\npl6Jn2OjaW+BlOXlH/kUHU0VdlBaT1zlOTIiZoXPtrMwV7vCwxKs03fL6cqZ\ncHh5gAMTU5XDRY8Gi243TB5zXeuN5V36bjDdLLWozKeaNEmXfcIM3gSbuoZL\n9nGkap+4l3tSb4P2MVl9oIacgQinwmXIWWIAKj6TkfBaRyxBXaw2f8j8WnK7\nGTsZRVlUECWcpaadrLEu+0Za7nSbKny6g55NNDE1Tuhzm/CYwwBLAr5ubn/E\nNPenmi3fV9TNZMgdrYFlm7GAhsnnxS96EdKQZ59pIUe6iMv9mmG311T3U9kB\n96EBCLMfok7BX0ZPGCbWqrVulxnKTpcl9tC/Z/wnMcbABfmfnhszEEzim9i1\nzivT\r\n=u+f4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC60G29Qhjss2ggXKJgTf/GMlueWrdsMxX+AkqtAOq6xAIgbCv1fVAkGj9jnSunjRUuHkfug54hNRffFt4BA+SGJ4M="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.1-next.0_1616488702810_0.7558280547757474"},"_hasShrinkwrap":false},"3.1.1":{"name":"ts-pattern","version":"3.1.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"_id":"ts-pattern@3.1.1","_integrity":"sha512-R8rx0ejGBNP+r6xCqPcrneBgluHsWMWtQ8O84lVo82GblxQj2590Y1F0yGTPqcScf6BWzN5B0FdmhSGwHPaxjw==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.1.1.tgz","_from":"file:ts-pattern-3.1.1.tgz","_nodeVersion":"13.8.0","_npmVersion":"7.6.0","dist":{"integrity":"sha512-R8rx0ejGBNP+r6xCqPcrneBgluHsWMWtQ8O84lVo82GblxQj2590Y1F0yGTPqcScf6BWzN5B0FdmhSGwHPaxjw==","shasum":"45e66a15b1e7b2f66713e5e85ef7a91318794cae","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.1.tgz","fileCount":26,"unpackedSize":70173,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgXFEtCRA9TVsSAnZWagAAFhMP/3JtB6rFYAZW8Dbi5oJC\nLy+gfOiU7PUO96V9h6H3rvkyS6qaachgbOiZ6L9Tr4Pp8IQDxnUH3sa1NLd1\n7ImyLtvNNsdkFz0f0B4N/UumVgZqNhpKYNDeh81YN9xvhIavkWsXxxEriOgh\nMX8wLIm9SA/1QWSfbfEEJbMTMAm2rcLBjmWThh+YS28cvO0OiMBkqaxHM+OH\nGzXTdoFQDK1oNUXOw71kKiUbUHJcmr/nJTZ7amU2j5EvV94y1qg0BNyPtEI1\n+v/WpoFPZgwH6C0YWVAsJvBr1dWZT0JuzZEkLiVoOPZ082X1zPYbZS4L2Lzz\n2v69Wa4e013+FWhCIsTA9oYGZCmkibm1tBCPCZFpq0euAlHWyFJLHmjxhUYh\nMCE4fd31uhhyy9IuSQFrAInVotcz2lxAGMYXGuVbmQZWLgIeC1CG5OM+Nzea\nipWPC7l6S1ji8gVKXUwBgw7FyAJmurk0Psh2qeFEdlJ3NkyxyYT4+/M5M/xd\nQ5ovIp0dEpBGnz8IaVqBHR1DFaukE3KCCrKjAGC5YhdRG2d/wVWFE7tGYz2L\nZ26yalG8IGo+h9bex+rTROQv4gljR/265wIFBeL1alulVEXYfVqk0pAqaEpc\nkZZgwYknro17nZP/fGFtmcyh0hW3T9MumeNm9hMLuTFzogKhXj5F0ppUbX74\nHzUq\r\n=3T9V\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGaJslA+mtciSk91xDfYB1IniVJeL4Y+0cBOKNywhvb7AiEAw5imbepvy+f4/U9cwqb+7QFjszS6eGkuJjIFDwaWicw="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.1_1616662828907_0.3035243903751481"},"_hasShrinkwrap":false},"3.1.2":{"name":"ts-pattern","version":"3.1.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.2"},"gitHead":"14f1ba2d9429ea936cdc9a792b53a9b47df7326b","_id":"ts-pattern@3.1.2","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-yHUU/u7r5Ehgo/y4YoUBPnXyN3fXcV8J1jGVRrge+sd3XJdD1t2rkhSaOFbpp8eMhwdeCyOkDgyGql6GhFnxcw==","shasum":"2208b921cda558374ec71df2750bf62be12a1bdf","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.2.tgz","fileCount":26,"unpackedSize":71135,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgajw6CRA9TVsSAnZWagAA4PsP/378GVxnX8J7HANqEprd\nJcvANsBnKDGrowfJq/VojZpLN2od1RJE4R8JroRDG8f+oiKkVCxrBI1N62eg\nSi+IPYc7jWowAg8x+R51s7QNR4PlMDgyAuMHjR1Ixdi9xcBzTx5r2whc2Nws\nC0sotOZi6Z1TmCMukbBGa8N6K7z4FZ5sCwpDUi3Vd3xwXN9GXNz6zS1/mkU/\naSPrv2haq8PxLnLxQnafHTJl899cbvRgaAC9OVG9tbazBu/c67d8U6BngRCk\nkLBgWQceId5zW7Rw/TrSWZvNmyveO03jOP3lfblLUnbBn/Qw9hiYi1chqqQE\nfsBZ6rLM+TFo7qWaNIqXcFQlbyd38bI2+S2Mj81+mpJnxSV+3q2oeSCXfKQQ\nbOXARt8m5llQoMVxVE0dvXnQbhQsecqnVtjtDFzIc8nQWYNTd4Zw2crw3an4\ngo37Hu+SCjEYYfHYK40WTBP/sPxyh4/Nyuddd4U3Qk2sXdjlF1st5seMVD19\nSe3lSlzQjlIAazmsmXAYH1NkppQHNJRDYW+QWSkVmCgybUne4JZDxLGi/SVn\ndpWdgcugEtzJ6WmQ2Pzldtgzevd5sfCby4Y+mYC71qbdHk+Os6QuoGVMiJiJ\nIo7n+pF6fprwfPBQ3SeDVb5UQcZZVJIVEKhf5ZcviqMTcfzYorqUhSfqng3p\nfY31\r\n=/2Tc\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCs+8mTJ1bvHNMwHo+Za6btQdJwAJzQLLoqEiVEaGPXAQIhAPLim2Rv9PhtbAAMXGS9QZPY/CUk/Pq2Et8hYv3uA1jb"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.2_1617574969637_0.9317150977790642"},"_hasShrinkwrap":false},"3.1.3":{"name":"ts-pattern","version":"3.1.3","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.4"},"gitHead":"79a57c44ca1631261e1e37c9e9b3ec159fb29ba3","_id":"ts-pattern@3.1.3","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-eX2RriauEK5JQjunuGDItuYtXyKGfVjSBvKQBYIFnfzMVoUYcbj2V3B1QGsmgO5QNqTQfgQ8pA8qMg0eyC4qSA==","shasum":"fdb8df311dabfa223af0662c6fd3ad93a9aa54bc","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.3.tgz","fileCount":26,"unpackedSize":71270,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgmOsmCRA9TVsSAnZWagAAlwMP/iiu7o9wZuPEH88HILuL\nWpV9ZBrYyY0G9xdcvgdKkWDnUalUE2sRZGW0Wo/34LVxfj9AyVCIp3ops639\n6cURuL9jE7aQzYNHkmsv+QTig7jumSTtLUJHsJkW+IHANiEwrxXRVT84L9Po\nO4/JQrV1DE52V1VebAPPWH8WH12kePNDl253tj9XSRdZb77gMN+WWGQPC4Y5\nHmmZrdENAMb2RGqUjQaycr1LZiLsozN7mnALdfE9DuOWDMrzccp4VDUPT6vE\ntmFMf99/oufo8swZ0jGENuFtw31F1T78NKqeEKMaDiagz3/RKSYLWoInKtr/\nLpYnxErDLfzbtgi+QIlaktucTU3olur/rMEK3m/408aK0PvufIh/GiLW2iWF\nBIuwy5ngamYafabs0Fs6UkHe3R6wWSufptb3Qj3Zy4xOStpgTiy8bYcNQM0i\nAndWQLCY4CP6o1RHe4i8fE6ojAWxGMTeW+o6ZAg0V/jCUxjApj500E+T3kNc\naFRXdXJqhp6EVCOB9W9wVMBVU/DRAETrqxi1fGr3g6ZcH4G6hUMGq5zeHdMG\nv1pyJCjzSiiJdk3tuGpHF1/L6X+VXkS7wGW8kn3naFklFRmpg8FSlxnUGVWq\nUZWi+ETf8V8UNPa6jPzWGx4IpzSclU81SRwwYIy/JdmfWKNNd9a5lGiMngPd\n6b9T\r\n=a6oJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDXZSvWCmhmJtFhCn7ivJF+kC0AZxQYL8ka4gAA4PyldQIgUo/eGG/VBbIgUFXBF8ln5cihyVCMVo5JTG90I3Czgog="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.3_1620634405862_0.09316672501761936"},"_hasShrinkwrap":false},"3.2.1-next.0":{"name":"ts-pattern","version":"3.2.1-next.0","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc -d","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":"Gabriel Vergnaud","license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.4"},"_id":"ts-pattern@3.2.1-next.0","_integrity":"sha512-WUxGvs+mzY2XXiDC3BbpCBHHgCByisZF9yoPDMqbN2+K9XT5/uNOKV8cIKNeNR9Zzk7w3g5jTB8UCDkUum0QUw==","_resolved":"/Users/gabriel.vergnaud/workspace/projects/ts-pattern/ts-pattern-3.2.1-next.0.tgz","_from":"file:ts-pattern-3.2.1-next.0.tgz","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-WUxGvs+mzY2XXiDC3BbpCBHHgCByisZF9yoPDMqbN2+K9XT5/uNOKV8cIKNeNR9Zzk7w3g5jTB8UCDkUum0QUw==","shasum":"8d6830379b763176b586a802373ad1e2228d3b89","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.1-next.0.tgz","fileCount":26,"unpackedSize":71697,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgmO2BCRA9TVsSAnZWagAA6K0P/RzYWR5t9I/V3NxECkB1\noH9zZ3w8SMwmQnbzF1ug9EmIZCvD2ddnlROGQ/PURMC/UKpidu9yk5cY/vW9\nrSKytQMsEymttYSe+3/e4XTEL9nBQNX4Gne37tYZ1fHC26ggYgeXXSyujdQB\nKItRByghrKoOfsA0u7E4+7fG2srK6BqbmZxb2PjDfr643a5UXFCBYZnvjAUD\nf71HMGmgneUvZQaz/aYDNRKdKDU1h8RhC4NpBqjfzpKppxbA1iAI0GeTy0Dx\nyvmQYCOvmoHAXC/+N87CdrDWgia2IrF0Dm8+xklbX8XVT9xXLW6kJKFNQI+U\nuwt3gGVAq/4KG8texkmkSNOOzY00fIoiOxnntDPfrUbNBx23yTPgw5nIVVvK\nYjt8M1kKxJFXsDWOTuhHCT+mC9Gq8zwi823WrXKPwvi7g9+MPXJsd7v5arxg\nAyOn8PiVU/JMfeQ2SeBhqmnI499iLDcMEnGv19cXfIo2OKiLKTejRZ5qRW4k\nu/8mD8w3SbJ5wnJPs+34QvEgwkR21yBykLPmm83oCEaywXOHmh5vcUSlh2v6\nGx/e6pN7wqyZQaCyaptPZ+25wmWHEmB+opJZX01uv/YJ9nsc9JK9Kx+oZiv0\n7m06tAOSXBeTpqcmAG/M1ZYi1thSGaeydnwpoV1Vy+tEajmozD7rCT9q9rwQ\nZ9dq\r\n=IYM2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIC+2Groy8cEEiXwU23PAhhbD+wYTWcPUjfsteec5AiImAiBDQ/nqkuCcaVcw+d9EYo50LnwMx58L6Qk+1Up3RuoFbw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.1-next.0_1620635009503_0.9292285848652841"},"_hasShrinkwrap":false},"3.1.4":{"name":"ts-pattern","version":"3.1.4","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.4"},"gitHead":"4df9a8797755ec0ffcfe745b62c9b0a75340208e","_id":"ts-pattern@3.1.4","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-54tevaEmrDOqjuo7ECjcp1lTytcdgusWqtkvJwPnjGV3MHM2eh8ADHIZ6AmQOa6s7iacuinplGWfF0bgai4qYQ==","shasum":"554871c0f440643e5c972454d9c80e156ca22368","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.4.tgz","fileCount":26,"unpackedSize":71967,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgmSvECRA9TVsSAnZWagAAwTgP/AuxOxvNadF1DH+2WsD5\ndDcWA7Iyw5O5dPfiENL0XSdxEZjJ97qX050T6tj6gOs7m4m3ZVNEhSIUq+FL\nF0COxPRLZDCCta6aBgenpgq4cR3oh3jhD5Cf9GTNJzhR3ok/hyiY3LRnxOib\nTo51QRA9ZhYzokP1dM5mJvhdSS324TbQcKja7ZUgu5tiCKfjjokmeVv7giuW\nhgV2tGe0cNK0nxqkBJfrsa72f75c+TmjgMQGHxCmLnl2hJZP25KxhOg3+QVC\n2MEJJDliFtUs+okaskB6oIQi4I1ahQFBiIb8T8YJnz7j1eyTdO4k4VX7RZOP\nvX+kkqShByOv2ao0jnVVVcv8UvhOqKc+A1HnWAgva+JMw3h242JMY5hZ39dY\nGqUhXIjhXVr8IkIOy+YSq1lJpOxCaTbs9OD9prmKuZShQHE4wNCmqkw9x/ws\nMweEYACo0haERagmFGQXmH5e/Z0U6HhLV2MheV7SFDfkUa9apBAdsLOnhjFJ\nJg79ALUjP63Gisq07R9tJ0J74QXZK3i47FdAzGrIsv+HdpMHIv207J+aEFks\nXdc1w3+q89Ykfknuii7CYEhkGcEvJgDHl90YdjTSb51br9ACV2mo0kna/fJd\n+qiECdrFLny7MI1R/pwPXHbicf6XJy4e7UYTuHlqmlzPFISV66Y8BOMogYcq\nm5/4\r\n=2gx3\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEpYMXFB9qPSzaL6BRsIFy48RYoJUzZLQsSr+nU9zCVIAiB9SZcFbUfi6SuUu/5azvlu3aiGNMoHNQcpocOFE9bd2Q=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.4_1620650947678_0.10480012303281994"},"_hasShrinkwrap":false},"3.1.5":{"name":"ts-pattern","version":"3.1.5","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.4"},"gitHead":"d56608f388fbfde7a427433125e873327f3e1405","_id":"ts-pattern@3.1.5","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-ojhRVEZ73rkprtjNw7rgCQyd771TM2NMp8Lit/B0PZSwM4X3tDdGBxuk7TYR2jee2fDU0HOTzxZ3twkUsFiDUQ==","shasum":"fc212ff9809e5d811d3954e34e844fd433e73417","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.5.tgz","fileCount":26,"unpackedSize":69973,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgm5jSCRA9TVsSAnZWagAAQy4P/0pWQb+qu4OYVFXIJ4dv\nrY5z1MgCd9IbuYOpQLtMRCQjkaXl8IxYBGTIA8pknGq5MBQPnNnMiaRTLfse\nuehFDNe+76K2MqUc4NdpCj69HXnSAgQKndtQFXT/JOgyJCdm1rtr5zAF+3gu\nbEacVgJYlDdI2dbsu2DWTk9YFO0mGuWoJRv02ARiS+Ypi0bdOUDHJBvHvp9v\npnOj5ZDfH8jLAHd5bEXrFYCRfSeKiEyG7yFbm/htabWR7JMjeHOGKnit4CDe\n7BRvXBQgCNxA3oOUFX3NjaNO0tdcwsUOkqhlGNNgoVKT1QYg3w8abfvUkwvy\ne9U/crq07BrCCBtcwjZEkDwsWOnCYpbhs3Mus1Na69PCvLxg2KPM7YCVscaE\nh3L47PSlVR6culSLb6ISyMyFgnvJ75DsYwIDDKVgtmojdanOiONxaayZOC/R\nbyI7/fj45wamfjLQFKevQdUBDdSdLQygeVP+eksiBwCA2EBDXQUwAbj2Om9K\nnaT97wFRPKYseKpqktDRb5etPlHXVbIHzyY0bFCTSEJYFeHdY+/YPGWICYT+\nhW3SqoUF89IUEuEwXWbDHIILbr4OLynVZgeUIy8E9P0HQzCeMQBdjPI5n1Y5\nBBmnZTYwjt/746GPObYwCOC2oAO7/xvmKfD8NPEK7COCyGWVuBnHA12y/cW+\nkEH1\r\n=/jY8\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDrgnK1WuW6ciMOz/X6fnz1HcPxqetwewps4qxOfxb5+QIgTf3z/OrRrdtIjztlGxHANdjrxEhY0VAQCeiTMOJ/O9A="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.5_1620809937906_0.6979141925765424"},"_hasShrinkwrap":false},"3.1.6":{"name":"ts-pattern","version":"3.1.6","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.15","jest":"^26.6.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^26.4.4","typescript":"^4.2.4"},"gitHead":"9448bff84490afef641b9f4f28c53aeb4e77092d","_id":"ts-pattern@3.1.6","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-7vEPubZHZXCcVP947hiHV1rOZrRlMaN+oRb4jVhHUwbOYfxeDRGuZ78DBZ22f80bUiDLceMLN7ltbvx74hWIbQ==","shasum":"04a955743ce9c81615f53ee3bb2b14a8333486ae","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.6.tgz","fileCount":26,"unpackedSize":70122,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgrlNJCRA9TVsSAnZWagAAQpkQAJ3DmWoEmXV1fxjTNvHG\nB3tPRTnU/pWv6m8UiUV3N3vtk/C9TNSWCROsURbZHMGJvVl4zxkYvnVRrG+3\n8xABhWRN7FPQc4VkO+gHGIo2UCN45I6JJADaZkPzE1Rg1AilmqGVKToqpg9g\nURB2SOFo9Zh1AmLxY8WEqXeJJYkTgMyuMJPR8UZppgn/ebeYSgORfBktyX/S\nT/HVZCLpwPNxCMxyid/a0QR6TJCPRcFrCnUrcez0ic3u+1WQ2AkVHOMODPip\n6bMdPAAXfqXCFUh+nuQ68DmWO4wdd4eHpSAud5C8NtUomauv4zqCIemoZWiz\nXTvVq8WFXZZu/VbSDucGYmYRIJtYpsZmIw7HIGYPtHNowDFEAQtqLQ5TOLKa\nP/sZ5rt1XYCIw5fyB1P9iZ8+1uAjTzjSwIGPBHU5/bUhJFhZvtZ32TBG9KMS\nVYROGupFRoj4lEJADQgZq0ZXLp/42IVC6WhUxzzdCxqDT7A27hu6O9d4KEKq\n7pD3UuUjZjYEBJqrPnOWJ8E/n6Js4FXm/N6IVyHYLrqbmGa7D/7sAgmE7+X/\n/++a4I8UXE9qiwi+hyojt9jBVZipK2jQ2wCn75YCXCw52oghRAilnFUcfLiT\nJTwwBC8KHNmsqg4MucpYeWsLNymPURHCi4zN1h7xuVe8U5x0/dehRUuETUWa\nk6OL\r\n=nJK/\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDxbV6GihR9/5ONKZVhJeL5YuaAnhjU8rcCGEvTPipa+QIgEkvMNPS7MMKsb/kcRm89DPODtXnxFyXmiHA3jaJzG1w="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.6_1622037320850_0.35726209294652556"},"_hasShrinkwrap":false},"3.1.7":{"name":"ts-pattern","version":"3.1.7","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"8abd70eddce26cc9b8ac6c4e45cc2328be5202d8","_id":"ts-pattern@3.1.7","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-HGItgT+nbmBqnj5Rp82QT2CaHzSfowwkX0P6tHZsy++VsdziWqQDJ8lCEqd00GlgxJA0tDwYKOD19pSwD7jRMA==","shasum":"c4aa242235337a82c37707fa3518293fb659ecdb","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.1.7.tgz","fileCount":26,"unpackedSize":69879,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgtJBDCRA9TVsSAnZWagAACWIP/RiA6DMva5EcLAKvS8vE\nU1RR8Xy6PwP6xYNh4zLDOQ4T4/wpUFQOz1296nXcHd6mrJB52zdjS5Hf73vR\n/Ndilz+qhl2E9Zydm62uJibJ+OnMkPA3zfkq7N/G3AGZBcIWiXeZc7mucc+L\np91lonb0bZHJWZMTUP7qRDHm5NXyXkXNLx+vuhpr5wgvKqhAxVUA/KleEkEE\nsUVbxKfv3sckWbUzvGB0jg0M2yRfn3AHkbe1jmFM1HyCp2WFY1K5T/7pOXdG\nB8gERtGTwWiE8Tm6rSwFgfnwxjKSS3jL7g+VofQ4BjnNidpyCBewMvs0zFLw\nmR+YJT55sozpiLBCfGJObU0YC2UR7kAo9tgQnHp163DiYllkGZveYvwO3vsa\nlNaAOunNgaDW/Jx0fILBSxl9I7/u/g4Ev2+YOs7ZP1sW6IJxkMl30R7wkJs5\ne/45eGHb6g1shOTxMZZWtDf6bxnQE2hQbp/UAFKzPIxQ11pAx8u8HziXvqFV\nOBw2wIDlmkLn5EkveHfEcwN7iolnH/o9C8GTGRHB7FAMj4GtS4pQ2JsQMNY7\niaA4tj138QbwKNZ/zYGD+/IROHl5UfkGh1/JHCNqML9Ca/ujpqx8sz+G5Q9Y\n6vW0A+agEsZeY5AQucU747JC6UI6he6MHdpXUYAByN6sNZg3ulSK3HB+019B\nGe6p\r\n=gjPB\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEk6RaQGwBzthrE+ySNals+Jwt1lbPkVtXeS+GTOQPdcAiAsfaaYO2LDG5GswaQmbKRUTvwCw3WsIufN8PKA3goPKA=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.1.7_1622446146684_0.43539014056205816"},"_hasShrinkwrap":false},"3.2.1-next.1":{"name":"ts-pattern","version":"3.2.1-next.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"e27c4abeed0d06bcbe53e65297b4d8b20da7a123","_id":"ts-pattern@3.2.1-next.1","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-ovEOKEoYTgibLCY0HBCfdHQDBgGOM8pHQ34R3lPC55xN4RoN8cVyNWITJ1rsbkzNNnh8nXoam447OrHTCzfNkg==","shasum":"f0e9bb30e0fa4d0ce6750495a43bf7d2ca026426","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.1-next.1.tgz","fileCount":30,"unpackedSize":75406,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg3iMdCRA9TVsSAnZWagAAOoUP/2tldliLzVYPtvP6kHB5\nutYH/8fUCjp1xb5ymZWZEnPBqWLAshOYAx7PA7p8DhDjla1VgBtPc3h84DkT\n1KPmdUEXWReGO/WX4KWgevZcih2lqKXn35j7HYJO9qE9CxyE8GgoR4pTNM2T\nl+NazHT51N3yli+rH7Ju5e2r4sz6E/fP5aLEvcSDYzXK8BcAmab6gLmlHfRg\n7G7SGjwyWQ3GI6tBeJSRS2lx/EvEMbbZsqRuVksdcv/uMta7K84Ia7Hn65pr\nnBZUu6aLD04dYFZmEZbC1em8Okl1Iv+DNpjs93/GC6H9rA/wJxRJ22wGdrGc\nQl+il3C1ylvTeSSUrm31SfVjplVY6Am70OOBge+fbxjl/GOUjW3kpFsleY9Z\nZx4iXUAjZj60rlsysa2qTXdgtzaB9wmN6skHXwZVHVIHeQKxDQ6Q3fIzdD/s\nBnwY1PPWpNMK0Y+3OhPpqRCjyORrDmVxdvYX0vgZPbkWY7HOBFmzoYPTH6kC\nkPpHf3qJ4p9dO/x+EYpUKKPNuPb1frh/H1iCrqfzN1CbxL6LLN1plcaOGMd+\nPDhkXtd9YUZdHoEOuVayq7QdL3H71cWrcbdIj8/5PKIIcQvo2EJv4ztj+2a1\nmO0kZyitcJM87IMhBxVdKbdkBuwEQsWhoFGEyPEuUtavXuoHE4jsU1xqmD/t\n9YGe\r\n=gYrk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAwnS/I5Gbd9CCyFwBpVWf32gD9C4XTbrVY9sp23tS8gAiArq/wv+PBGMaTGQQM0qjADcY3yEacAOpbz+0WDLEbrwg=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.1-next.1_1625170716935_0.32331674214525363"},"_hasShrinkwrap":false},"3.2.1":{"name":"ts-pattern","version":"3.2.1","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"7050af0897a97580d77ab3a57e065f762c418ade","_id":"ts-pattern@3.2.1","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-JmcPe/0c9yRLyMga3nxyjEXOB8QXJkjJo2OAp78eHVD0HjWU9WWtKiazxF+Uz6ZFrBkFnwFZFEJrxT0uEo6Jrg==","shasum":"92eb3cf6589579c3b9b7124bdda0557b5d485f7f","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.1.tgz","fileCount":30,"unpackedSize":75399,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg3iX4CRA9TVsSAnZWagAAw0EP/RKl9cWZoVHiwU0wNpDp\nLto+aiAyjm8CM8d7dIXWtRZCZTOhu7bkGhegtq7pnz721+4ccCKrLvWsrEml\nGFhVZ03ds9RlLlUQC91A6ulJX/ISTVxcGgjfk9Fb6fR6h/+qKZh+FxVKH1Fc\n0mG1scm9UgT8CH0+B/MHboSwNSGlYHERTBUWn6W66pm9tWzXHzqaRlxvN9ts\n2MHuoZJ4lYWfwoBxt5Z2gjlBUG1Y0evJjgQASa/kwadiyiUuYqO9ynygmbzg\napURQEshagMbZGXsS2FQR2LMV++2uY5X09k3n9Qo6Q/8zYwa+a1vIBPUfmtY\nl0UW2VRtASwuTf7SRgMlFFwnZNDcLItgW4BrDp3wqPrZK2ZKhY2/RVoix4HP\nedL3pAVrSk/ayIvRPJW+Rrf1XCU8QFSxNY+pPgPjHAHauuyINS9AFp+DgkPe\neiaTgYbBKdhuMSwc6N4Vkv1kJJ/Ut2led5Wqx8OTIRDW+ONcqOaO6PZD0Kjw\ncG2c55LE8beFdUe5EM0ukLEV8LPAm22zM+jVqWL8dDKUl/rdLCqrIMz1ESAy\neq/UBSK/fzMkevnW9mtMQ2Y63e2kb5rCBamNGNdasTndOObr4xwYj4nTys3A\nfBJ8Or8913eYfXdS/HjTXabu2bHz+xWRYiflluAsNN8wIIP3UOJTeyFvHNmW\n76/1\r\n=95PC\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDOjzJqbaidoCtxASUt+zGiORP295xmERndtB0zIbO9GAIgfVj8GCuTkVrH5+TlE8i2T6TjccaOcsd3NlaDxPdFdQQ="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.1_1625171447711_0.024112356083834108"},"_hasShrinkwrap":false},"3.2.2":{"name":"ts-pattern","version":"3.2.2","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"8b7ed3378861fac6d718088f42063f3a67f9e8a2","_id":"ts-pattern@3.2.2","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-ezgweMdIP6Me7vzR6fT0dwBkTDJn1d303nTk+Ej8TQ1wHSnOTATwJzWf4ObLUJawrH2tXjbNtgrGcS6RJLNDAA==","shasum":"8a1c0bf16d15c69096dc404e6be1e4b76b1ede28","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.2.tgz","fileCount":30,"unpackedSize":75467,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg+B5zCRA9TVsSAnZWagAAYoQP/3+rDTCPNC+Trj5SwRT1\n59JNUNfoUC0NtP4HTPA7686JXB/TuGQGjohUuJplAA26N/T1s9r9THpCEF4T\nm299G99tfDgVRRuH17+OgJNPTbnO9YmW7+pF989MVdRqvvq/ji2/wYRniSc6\nqWavqXPKMWiIG5z2McNroAwnjlizX/fHxtutZW8b9kPTpzxe07lezhnxEiZO\n9U1ItEqIISERh2++j5CqgTc6Vd7FugQz5wURR8cpGlUvq9aAjMIrjwqnm0Fn\n4g+XY7QnOFJbktFlcTDq1TppS6g1HL0hkLttNNPnjqtbOIlF4j/jeryajb46\nxdr2iO4COC/73gTwkhxlG/JEVR2mqoDEdC5ePIVyJFac3YcQ/aSYoayi7Wfh\nFETFS7tOB5QGcOAHRPQXrrrwPPrnoA060xtfU4NqAEz4KNTFqmeaL3h/ojYo\nXIttPU4vBmVqUvnNf/a3GJ5coKhGnL35/F9+Aq8kg6KTvPDQQM0LEojxVKaE\nARPgl5BAVGdzM+vqkEtwAmg+lWU2qMoy97T1M9tI4XFWU1oZ+tABXemek6p2\nmNmq4Eb4KTxD6bQitxOSh3UF1pCsWZ7shcPek6TrzH50t7Ant/aTaKHeZh/L\nXULCtBYrZMwhRdC1Evyj9HInfvm3kNClmF9FelIIrRUp1NmVHOPdbHu4jYIm\nUnxv\r\n=j8xA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIG6yH7MTDenDNLAN+pYU+yW4vPo/a6bBKZsm8bA9g6sJAiB38ZCVWLgYcbN+9gAMDMFBxN60NrYsyiycwPCor7gtpg=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.2_1626873459294_0.5528238605297657"},"_hasShrinkwrap":false},"3.2.3":{"name":"ts-pattern","version":"3.2.3","description":"Typescript pattern matching library","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"5bfb9bc54df40a8af5eb52bf8f4ddb4b2429f771","_id":"ts-pattern@3.2.3","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-+diLi6NLOb8eDvehZctLVMvQzLjBLVYHRIh8Wlb96n8r+85ctINHLG8mTDRQoxBZZAUipbeGloAGeGg/VgI4QQ==","shasum":"7a3a73a4af1679bd8cb8b2a8b534aef471cae84e","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.3.tgz","fileCount":30,"unpackedSize":75459,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhBdLhCRA9TVsSAnZWagAAVrgP/0Xvaw4Maw/gTwXysfSB\nc2eqVHq5S5EiR9JtO5hyEt4+B2vSRwls73jQ23KE0uRsheJuifCyFU0SHCvj\nxnvTBvPTTLG05fZ10GRkJBLhQxbS0OiamTVtE2+swj61L8FZd0dQM4G1N2Br\nIzbdXN9CxUETVIHqL2sWzP4rCR7mqx6JrtVS97VjczMnsv3Z86JL2c/gdwlX\nsKm9Vw5qZo6zpefOXhdEh76yEafbmx1iQX9DWKmKNwP6NjhYoJi0EhKKFcql\n9KYIgy82OC+DF02YmoIoCES1pg7agkfZfEGlX+c4MjrfxQMhb2BQ1nTXKPDT\noGW0CJVRNndg54KAvV9wiMdaXGNALlnCs+aeRqaQFpq4f4jqevULxK+orZTZ\njb7lQT6N4GKH1Zj17peNjsC76+iFvIoanBAFJhtd9AY9pCsJKiuvSnNDCCwp\ncNi5NMdzywixKZIH24iQIAszCw7bVpvOPZ6Ml0AXAbZaIog5C/eDq/Vynk0t\nvwO9KaGBwJxOa/LS2P97f6bhYOwyweZSJnBH2vhDIKigQBEcBy33scjdGxED\n5r27buVWySeDNB4V4nVi9nT8ZFwEqy/GOH70q46pGrHVCK/b/rS3Cf+4T9gW\njSTESvD5XnzFUUgLtOUka2f6lr60CXXBs/vbizekDkQcJ/oanubDbHHCvcX9\nOhiQ\r\n=jdht\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBoeCB5GX3IaCgBuV7Ejmk8B0XxctpCSd0RSZZ9PA8ZVAiEAqPp3QtxpT1cRYtHesjvqe5eHWuRxSDKM31HC94JGJjc="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.3_1627771617483_0.9398637996092101"},"_hasShrinkwrap":false},"3.2.4":{"name":"ts-pattern","version":"3.2.4","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"2e830a4beffd3a7edd93eea5df688f9e7c0a7d97","_id":"ts-pattern@3.2.4","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-sDZfdG1f8P2y3d6H6HOYn1HMlpjYslyK0wch9VOgdpjiXJ40Pkd5oNjXzoN+8UblTzEK1SW72fJWk+h6vaoNIw==","shasum":"b89e57579ecf1ff58d21e70d7f50743266e52777","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.4.tgz","fileCount":30,"unpackedSize":75517,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhBpCmCRA9TVsSAnZWagAAyBwP/2ujK2Z2R0oqEcX3Tb1r\nH5I+Iuu18m1fRS6n/Mv/P4+yTNb0+qvXOtA9icF4irC64ObCmL2Y4vmL7kn+\ngISGz3O4+aoVtfYJ8T8mm15I4krFs1WMFE1XnotI1MlUMzqUtvsa2gAumgG1\nwF59gOvnWe9nptwUh2yKuQP1i9MSUIcsKlH75YnfCxBSk6zxX+sVzMd4ZEtg\nhPlRrjVo7BS/X0kA5uucFw0QwhnMlx7QDsjQrRZkUJ3m1OloCK+ETpiPHuez\nI1eEsQJZloCoSv600oFT5MNuhtA6oOovtUftXYM5/yRq88CAW+xgNlfdueFG\n3LUXRNrGmfdQFWdcKQqtmOKBZRkWnMUfhDfQw+laGxzZ07Cm6t4dtMVgU+mc\nSfjnktMmJAJRDl1Kq7Yh5V1VaEZgXStKusfa1SpbZyoiBf0hXcShBsTEO3Eg\nwt2WyGkvcsDqDi371yLGrQGwp1TS1nFI4ciuT1lRIRk7WnOrekc+SwEUfF78\nf28cSWhsP8fi6C+aQuqOPv4/WMdqFwAlGTv1BBaD4A1GJCzRv4hIkIJavNzx\nbpI05m/hWHwgUS4jymlbuG4+jLP8aLGq1PMZ58TnPNl/CQDD+amrLGWpBuWN\n8s9S/ubR1zy6jlcVlXvjZ+lR7UG2GUROxqetv6rar1Px+xbe5iG4TM/ppJCj\n3qir\r\n=D2z+\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFrJzAw+ew/vPLJaIhiKkq8dPwlRsjS+BxfQOKAqAgaIAiEA7sNtb166sGNkl05KhX8UdUpMIYq8sBvalg9uRNIrq4U="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.4_1627820198346_0.7998884344335839"},"_hasShrinkwrap":false},"3.2.5":{"name":"ts-pattern","version":"3.2.5","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepare":"npm run test && npm run build","test:values":"jest","test:types":"tsc --project tests/tsconfig.json","test":"npm run test:types && npm run test:values","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.3.2"},"gitHead":"0e0da1f0a18c5522f78654ee85241f7b6dcd0fba","_id":"ts-pattern@3.2.5","_nodeVersion":"15.12.0","_npmVersion":"7.6.3","dist":{"integrity":"sha512-MTA3NkxMxyDX3IPx4jcRYoSF5UtZ2tveWT+e83pT7E++j+MJGQzu6+WNNprnBm7tjYGcD6n7pOcbUP5jy+MV/Q==","shasum":"54e60641e38f089cde47bb8f1921c56f0eaf0a58","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.2.5.tgz","fileCount":30,"unpackedSize":75427,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhINObCRA9TVsSAnZWagAAgNsP/0f11UkmXNHfQglJIkA4\nLNsKaST3UGA/q2Nb+zkYdcDiTyZBihdNJoFYM3aJGmKcpVFl46nh39wm+0B0\njPULUACrT0LRkBuccaWc0kMhng7q205GS4r+S4ZAnLLsRaUis33umBLOQFS7\nJubUQf66PN5GpyeyHdasnuZI60/q4MjexunTQHRWWOk2wawaBe+Z4WK/B6RA\nmTcHwo2E089AZexEOkgajiw2Qeg+G8fhj5dG1RJWAOy5/hXASDs3qU+deVFL\ndAbsGEr/P6jDiXJtJt4gmgVk8g61qRGJC081l3E5dJh9JsVw2velymzQY5Wn\nqxkIpcPH+ftHiiDjWDJy0uqCcfI7HJtg/YnensesvVKEdpvRVi6EJ/wvyRtC\nc4WGZixN7WFB0Wp60mk5kc2kalT9iwUran9eCF8JrOmxs43MeuS96kPVy6p7\nSdVFzbDU10KaEjCb9n4bmWzZsUUpz+JIThAA8gY1oOmHph0RmGxwUuYYEVXx\n0GKJHyBQhsiJdJ/tX4+CJ0QgHeelifMFDUt2SfY06lHx+Zp7zmrj/67TaHRk\nlQzm7SeeVj5mY/2JJ4clZZCQkNFVcW5DDPUZzDAgRBpfDqdgPMeQVAXzVCYa\nTb1oQYi0jRwX06dGvaOe0TdSFn1Sy7XWyGF9Voeog4ymzeuxEvI1PnnGMrkr\n9kjP\r\n=ACoQ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBgIA2p3JgJ4Km8Zs4U2/HY8txEuzFUPpnza9XL+5/raAiA0PvQbilw2KjRjxY1yTV1Tku+k8XloVwwb4SzEwHKeyw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.2.5_1629541274983_0.5198259645176118"},"_hasShrinkwrap":false},"3.3.1":{"name":"ts-pattern","version":"3.3.1","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^26.0.23","jest":"^27.0.3","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.1","typescript":"^4.4.2"},"gitHead":"6f80b98b79a481d43d678a510202bc3ca845fe4e","_id":"ts-pattern@3.3.1","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-E1Au2Biw2j5T6D3WJ1HISJt/nBsrR+zoQYLEODI1JvWTkE7QY2K2wtYbiK9ZtxEFTZ8PnBqj7nbl2U/TzW2MtQ==","shasum":"cedd39ff9a5ffd7787de5b3008618bd0c50c62ef","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.1.tgz","fileCount":30,"unpackedSize":76508,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCYPXY+8xVzF9+ey0sBqLFr5NtNdxo5SO4kw6qoODqiJwIgSmGWZ2qSv6T3NK/e3u2D1/OfmQXwpotvHk7hX3uB9F4="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.1_1631898219526_0.7982405077382042"},"_hasShrinkwrap":false},"3.3.2":{"name":"ts-pattern","version":"3.3.2","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.2.1","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.5","typescript":"^4.4.2"},"gitHead":"e0fbc373a09f31a51bd5f3af4dc507778677a76f","_id":"ts-pattern@3.3.2","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-Wsnpinv2ADatMLPvdk2s5RKrsEHiUDo9xH43006IwXavJYQUoO2CDoes9/BmX2iXfIdxGV1IkXNZYhKsufPVAg==","shasum":"4245a7af84ae60cdd6befba17d47d41be9db4daf","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.2.tgz","fileCount":30,"unpackedSize":76598,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCed1FDDSDQTguBO5eYdBt4IkmPjmacGFqrpYb54qOFRAIhAMwFMUlV7V8HRvUJGKRCJlLbWfuuH8kpvUa5jPIi1VvD"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.2_1632428267631_0.5041471117834562"},"_hasShrinkwrap":false},"3.3.3":{"name":"ts-pattern","version":"3.3.3","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.2.1","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.5","typescript":"^4.4.2"},"gitHead":"407e62e2ae53a13c70d7cfd153b1e52d1604630e","_id":"ts-pattern@3.3.3","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-Z5EFi6g6wyX3uDFHqxF5W5c5h663oZg9O6aOiAT7fqNu0HPSfCxtHzrQ7SblTy738Mrg2Ezorky8H5aUOm8Pvg==","shasum":"d15f4417b3f9161089da945885771c13606fd06a","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.3.tgz","fileCount":30,"unpackedSize":76609,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDSlj/ariuKi6JKoPn29LzUVGk1kzHuXpeijV42wFRr/AIhALcdcLY0O94ByE3vlz6LwR/tnEyjbTBxAugj3mJeDa2q"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.3_1632431126602_0.49999216726602236"},"_hasShrinkwrap":false},"3.3.4-rc.0":{"name":"ts-pattern","version":"3.3.4-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.2.1","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.5","typescript":"^4.4.2"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [`__.NaN` wildcard](#__nan-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `__.NaN` wildcard\n\nThe `__.NaN` pattern will match `NaN` values.\n\nNote that `__.number` also matches `NaNs`, but this pattern lets you\nexplicitly match them if you want to handle them separately:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = NaN;\nconst output = match<number>(input)\n  .with(__.NaN, () => 'This is not a number!')\n  .with(__.number, () => 'This is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'This is not a number!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"569d73cf824ffbe19dbfd8a70653d9d51a7c2fba","_id":"ts-pattern@3.3.4-rc.0","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-JTlGdIuA2v/dALPjCaVtWe2F9BskCNaYSCQ7Tv1+1rDW8SOyr1BGJK7yisovB2iRy4HooWmk5HPErhFMkplukA==","shasum":"90d83144846ffed7215af52fe9c78dda47c08545","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.4-rc.0.tgz","fileCount":31,"unpackedSize":78073,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhuw0+CRA9TVsSAnZWagAAtcMP/2jzdzqtRbDYEk37wfiM\np8x6An09TYpfjI6jb1l43/gQ49AL+gFg/98qrnxAeOgjxGrELvHWBcdqZppc\nzm71kmhYdjNnCOyqvL2YMAtn6gsFtgRsb9f+fZX6PkcifLbsUurJAxIdlS/1\n5Cb7nQLuX/XL4WyDWudpcoxm7EkVy//9xv1Btap9ttHXsCMZC1qlywsX2Xzy\nrmRlGx2fZw4HyfDD3WNeme/Z5or7mfq6DuUo4gnlA+4RTs5b4FzWyaGYbsGk\nAqsJCyMSOWvobaIto3wKFOZHBIG81Np3GMH36vdwX1txIBWURghC/AvjimsJ\nbInHovVu2R8QaJ6h9yGCz5AxWlTt5tX1XJCE3Zv6BYINjuE6RfllPw3tN4kR\nI8ZUWM2OayuNyP8r3FXwWgwdG587VD2eiCz3hbMSbRKGPCgxS7V8X4AQrqsf\nYIScC4vZ+bSRyo9VoHL/dChciiuU9NZ+F3nkjx4H+kxbk24dPEN3g70u4/2/\nBJ4nhOgqHjwEtNt1Y+NKN4gFjM58N8t9EwuvAqkNyxrjpSXM4F9Q1lPrHRoE\n3OdyEnWbKzRmAxfqENeX8HDi9nPnKI71evR+1huMy98EqKEklfDP04DRExuO\nq8Pd5VQ0WE8glaPfNFmHNpnGJmvs4cktEAEHQoHPdcOFVL88j/M6/66Zg0g1\nvG7a\r\n=VBER\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAiaK+wbKzcHi5x55I+727EWfjIGaaqZZvlm6tOXttcKAiEA6Lcws8AxLmwkpGnXkP+6s1g23D6aksgRlaBCIlQsalw="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.4-rc.0_1639648574173_0.629160256981288"},"_hasShrinkwrap":false},"3.3.4-rc.1":{"name":"ts-pattern","version":"3.3.4-rc.1","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.2.1","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.0.5","typescript":"^4.4.2"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [`__.NaN` wildcard](#__nan-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `__.NaN` wildcard\n\nThe `__.NaN` pattern will match `NaN` values.\n\nNote that `__.number` also matches `NaNs`, but this pattern lets you\nexplicitly match them if you want to handle them separately:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = NaN;\nconst output = match<number>(input)\n  .with(__.NaN, () => 'This is not a number!')\n  .with(__.number, () => 'This is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'This is not a number!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"32582bffb7983bff6bf247b9013cf26497ebb2f9","_id":"ts-pattern@3.3.4-rc.1","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-8sqXfjG0M2+TD7ppWDJPMgjiHxFMhWDrhaYE7otxFleZauJmiuhnasM/C2scZ5RCp1+ppQpFnqb9Nxf2ipO3uQ==","shasum":"25ce162ba89910f6637cc2a7cadd591cc9f81e83","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.4-rc.1.tgz","fileCount":31,"unpackedSize":78073,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhv0NMCRA9TVsSAnZWagAAzTEP+wcdE5csKXZ47I10IRVS\nqq6VwD6Ir64lLzAfUJY4XGDnL5uDoOAkYDhuJVYKVP/6E/oQPqBzbtHspwdy\nb8kVf1qVCETfeLNs3MLRhrnX47Z3R0RxkNeJx03Nfsai+sYjfFK74Eoo1U9Z\nV77Jmgsy4VxJtEuD1JscG9vYch4a1rXzPNb9iZa0gbzvw/x+g9qsXlu+Xpzj\nce4AZS0NPMdAv5eatxoHOU63tjzsRrtLSMEquqBSNY0G+4gNIVgoQ7pqG669\n/dHHG9kX//3+oHmrVJBdS/XKmU6Z6Jrjban0I/juvjbzVK0gGlqQ75Rh6IoJ\n+AFa6dQpa4xjZW78dbp6igX9FkWXDv6NjM+eEs0pz1qEt8GyypmbtjzQIJ99\nLmmJL8TuGA/O8WiCrW6w5BTAV7QZUWbA7wKJrPQgpMgScTvwsfyZSuVGcGXS\nu2nkyp/czArmWlBKj65rFtPbQsvZUx++kX1r2OgMvxI033OzBEAkKSEmPNbq\naAj6mjiHFZi8MMfOOZEbsni/2cbolCeVj5bFrlzFTuVg/ub8iwy5HouS7HpP\nCkyZK8wcL1uKVA7LxvjO3LrW40V3Zd3RSICAjWWfTRMAlTRVkKZs2wihgPVF\nvmRbHjhCOIABF0k5HpyM7jXbSF7BsK6eCaGYCygCVYmVnF6ZDodjXFoVshlC\nTfcV\r\n=/cdg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICWE4sc6jhGSdUvndKPkssKp76+4ZU4k1lar5t/2ZCevAiAzx8BTUWZ6uQ8F8wE9tbFDRD5cB9Tvm/cW56hhztg0Fw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.4-rc.1_1639924556661_0.5753060419869742"},"_hasShrinkwrap":false},"3.3.4":{"name":"ts-pattern","version":"3.3.4","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"gitHead":"88c41a297973e4ca209eb2d07aab6d3536de0ae4","_id":"ts-pattern@3.3.4","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-bZFReX+qF6N6c9SyycqBmYeoOgZCBep0+/M/kFan9Ujf1t2KqJJUhruVXWyeOVJrHxGPKbB+4xA7feqHS2t+Iw==","shasum":"127f51bae9c29551f8fdc7c588ba1ec65b8e5c24","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.4.tgz","fileCount":31,"unpackedSize":77100,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhwFvXCRA9TVsSAnZWagAAlqYP/3tEqFxnif0W5LpzG3Rp\nACARoXoQCF/fr7u0RDgsM2J5zzdYliBrNjzYvOyiVEHXz4PRSUcTKsMd8m2D\nFyuvtZGrGHwIN35btmOyR9ts0kbOXadysKu+qJiHR527YtpWI/y5Uwct9FQA\nQISsGkTCM6cPEaGH7tvc7qlJ2G9GL3Uf1bkaNu3sBlPjR9XCvWACCyXTtX7t\nPEnEX6qpWReHfmLUXWwQy+fn0G5ZnxwmypKuoVGEMVHfjTt2GlJxfQp0+1b3\n4VVIZkOjFCzk2uZgthg8DoCM7jQznBsIo796oZSkQ/OkUggUft3N/rwiPZYP\nY0nLFIQgyPES43fb1Xjt8XKVGA9Es7pknLYs0Uwmx4GxTASVx0/nGY01Et7q\nHRLS9wLmmOwIWR3BQ3PehwurOWoOTPdaqBFMS5uPRsVG+G45OIX4EXvpuL8n\nc7p9NFb9gAtgDmvXfSpOcUydS+UNdhOIaNYPH2NjPA5WXgrS356ql7jllBBY\nNNEz1M1+0pCspcYpCa9+YXrk3qh9H98J6LXVa8jRCuiiUwmRknlOFZtUjnbY\nRu0itPaAv9M82AHJ4eSeB9LWr6NSsl6H9F3lRJ4JGkk+VwXbpPdZ2X+pEYYq\nBDBKVpPBQDkzHfkSvEtvyeMmQA/5aSttpdzG6ZnL1EZuBkr1TGI6hwiCeg0z\nzsxH\r\n=0I/0\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDMSb+wu/VB111XJZXt7v2H/BrfjBB4M6BGY8NHkYoRYAiEA+SGA7KtOkSd6Iaud0SSGmT44w5zNS6X24hDVHJu6LXg="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.4_1639996375352_0.47017194166582654"},"_hasShrinkwrap":false},"4.0.0-rc.0":{"name":"ts-pattern","version":"4.0.0-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","module":"lib/index.esm.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && rollup -c","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier --write ."},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@babel/core":"^7.16.7","@babel/preset-env":"^7.16.7","@rollup/plugin-babel":"^5.3.0","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-node-resolve":"^13.1.2","@rollup/plugin-typescript":"^8.3.0","@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","rollup":"^2.62.0","rollup-plugin-terser":"^7.0.2","ts-jest":"^27.1.2","tslib":"^2.3.1","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"4216af02879add05c808a1d4fd46c27ba03a7415","_id":"ts-pattern@4.0.0-rc.0","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-UPe1ABTHw6d6y4G6MVb7RE5NxehIxQK6toEXonDkniagsdCvTGlUpgqjJJbGD5YSNyRGwZct91kENouO0rh/3A==","shasum":"ec6673f0328fa17ee3fc405c815bd64234e61950","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.0-rc.0.tgz","fileCount":22,"unpackedSize":102090,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh0LRbCRA9TVsSAnZWagAAwrgQAJtbYuTxrYcqvbgk4oU6\nCKbBfgN+r8NSbkCCUE7mBs1NPx4eAAX9QhIXfuLLP5V1eRGwdicMwDCC6CUX\ndiCNMrQUUIZmUV9GOdbLn1QMMNkfvN26+SY2tqVPxne3Nd++9ww5zB4myfhu\n1kgX8t4mbR3fKRiSsp5nDbCXPuC/v+KMeV1lcRuKkTzwycSVpCmV8SAFNwFo\nbDxKIR/UI/6+zDpQoiXlyBYURID4VZ/dslMIDLEO28Hr0QczxIlw4N7oomul\nZctkJTRgOmzbTiZUf1LP7vApnI1Wveasl71DEBJNwtbF26TQ7bKoUlkdu55y\n2irA+kjkIxV+XGXqGLX+1RmUGZxYfoUwxRiYYOmNPN+6mt1Cuq7it0/I+11E\nEwLrFASkeOl6QQjAbB3NzSo6KJwxO6bGzgP5pNuEBgLDTOQgvExqcLNoq7P0\nG6ROyM0sk2w5KyJ8fgyRfJjBCdGCTcL1/F4rNjMxsa/E1Bwf1ll/upcraBMb\nImwo5GtDervBD2Hr7oYAyiLzRbl8j5FcubSIGjKm0yQPhlRRWMPEHAjHmndj\nbGUbr8QQt1tkeMuUhDd54UhHzR2t9c20hldr8FUIPTzxBqgcirPzayUMx5AK\nVQvQNs7NnY1aGNphrVIwd8Fn2GHXxq2GW591g+yHMGoV2HiEftd8OT0RqMMm\ngYG4\r\n=18Oi\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIB4OpwBbXneZR3zfQpUwesK96sGRhsfbUPMawvb7QMzRAiBWTPsJEp9akSWZNh88NrVQCqWY3be5mp7ViUdTbV/x7Q=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.0-rc.0_1641067611834_0.11638163256894218"},"_hasShrinkwrap":false},"4.0.0-rc.1":{"name":"ts-pattern","version":"4.0.0-rc.1","description":" The exhaustive Pattern Matching library for TypeScript.","main":"./lib/index.js","types":"./lib/index.d.ts","module":"./lib/index.mjs","exports":{".":{"require":"./lib/index.js","import":"./lib/index.mjs"},"./package.json":"./package.json"},"scripts":{"build":"rimraf lib && rollup -c","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier --write ."},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@babel/core":"^7.16.7","@babel/preset-env":"^7.16.7","@rollup/plugin-babel":"^5.3.0","@rollup/plugin-commonjs":"^21.0.1","@rollup/plugin-node-resolve":"^13.1.2","@rollup/plugin-typescript":"^8.3.0","@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","rollup":"^2.62.0","rollup-plugin-terser":"^7.0.2","ts-jest":"^27.1.2","tslib":"^2.3.1","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"0cb274965357e498b01c85bf0f0b095d005d7734","_id":"ts-pattern@4.0.0-rc.1","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-NpDxkP0XxPri0ODwNdu9zreeQFTQVg/SVUAgEeln5jHY6fUFXUnT5Z0Rimk0fQO61+WhwqlzfL+1JcF9ilr8Hg==","shasum":"91afc101cd4cd75937fb1946e949fcc574137fb7","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.0-rc.1.tgz","fileCount":23,"unpackedSize":112696,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh0W/BCRA9TVsSAnZWagAANvQP+wYzfmHB1WIhklMCOHV5\nFC3qV9IRRbQco3RU6Rvc+O2cdPFq+qkiMfPXeVIpW3IHNZAtRuCrb/l3WO3m\nIYP7oHnK9y9wokF40+15oaxxciPT+IzScSfrLnLz59YcNdTQDAnjzvSO17/W\n9/NsLY3hevHu8DE6ksMoICa3vKleJ2xPA2O6kafMpoOWPldqqHC/QzjHSVdP\nn0D/1tFoSnt2KGGcYwLpOIVN4panWVGUFlM6nBzgYfRhZrRSXiNOU9Eic3QQ\n1YAWOlHN242MGOlkbhlazKBY7n++DaFI6c7JQ4snsDOYgKigMtjEZa9shjek\nHGY4dh35BOzRYbgPjPZto1Npn2kvMBBT8EqDmKWMKJ12T6jmPHgld6refOL5\nqyBB1UT8ffHpVpGID7GSOrs4cSfGe93vqFcYQ59wr/HL3KDIS9bxTfx3UsQm\nPpFeeEhTLm0uLcYzYE8Yrn/3tJUIn97AbWZ7TWI/7O8g6Y05JjP/IrfuLVl5\nES36ezIQ7fhWQqmdQZsf4SqAw3yQBCgzaZMRri0rqVJ4sMgDZHp9Nn1FuNvI\npBrF1ZRkXWwpyyEbMT1tBxIrJb1JzHPhx5s2LM98VCRd+OVmMA1VCzmGEwPR\nd93WSxB0ts8euPcSjZ3+PkZd4Gk4gJDrvqPFzkO7tbd01ThvzBsBE1r4LBzN\nuY/T\r\n=NDky\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDy9+YZqa+RVf70hBw6My0t3T5ARKw12M0T0mwZWwlQOwIgSjv+qwM0ZaXqof9W6fd6NojdZ4V3RkMBTmFbWiGDK8g="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.0-rc.1_1641115585277_0.5919169271692368"},"_hasShrinkwrap":false},"4.0.1-rc.1":{"name":"ts-pattern","version":"4.0.1-rc.1","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"ae0864a3e2527016c4e11774c6b53c6a0501cfef","_id":"ts-pattern@4.0.1-rc.1","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-eztY6f2zQFcipmNh3+08+TEg9FOfQxtALo0Sa5Qpd6Eh+zSv8lm56myLmOITwIEnU5LWWRJ4S4rTNBGo13icJQ==","shasum":"0c3521b7ca2b5b302369fadb3fe96068dba7dd06","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.1.tgz","fileCount":35,"unpackedSize":93332,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh0X5MCRA9TVsSAnZWagAAAqkP/iWI3qrbuATa0MlgImBu\nVuPGYB7bOoCDw5Ou8pICAoJB090mhuaZNfJNPKauFOh4QxBMzLHSGi/KRmHn\nAXJe/qWFQrKzuvXaN13bA9FchpyYr6w5cR1qYaAWvEOrBJYHIirRZuHZVjIp\nOV7sqPYiek8s+SY2zk5vIIY4l4DIwhTs/kU12wvBOp8D09/0FmHnlVTbfhqG\nT0Hn380PCHYM0nk73oxCIhyy6rr0gOGO6FDZY9+S1/ucmutIl5PhSMmtvNhK\nBP3SgK1iS2rAxCpQ8fsow8EMpOWHIfuzpLjluKk/N0p/7TWLo7D/JPpxC6Mk\nRm4aDUTnpGOzxkj3wTkpH/CPAHebK6+N3ERFPaCZZKvtF6Z3FESv4YOJ+fW+\nwVmTg4eKxYPmrMz5HQzbokqRaFNVbkixYM8hZBKZoM30Qxjd4QOd9L/rLDXr\nqCuo+ppNNr7MuOwdyP7l4WKfVYOaCKzY68fi+JPqu+x5FaIsOgeBvDJWQ3Cg\ncqI2hNHMJqAtWXbpYfVXr04rH/IXkpeY8kNV/EJ/f+oNcTh660jjOEtoF4jZ\nrTK39eYy3liXRmL+MH1whmtqVJe/k/++TKLQQSMcqNzfVsdHv7wF7E39wdGt\niJ2uBxqRaxomtUTKPLPD/PM604ucf7y0XZpV8gai000mWp1UXCUpskWoJ/gQ\nThYH\r\n=6EEC\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBzugz50cC8Dp8cE1k+oCVGqTRO/pcLnKIA1x/zswOs5AiBjLLBEfEJSM3Ai8L2o5VkGlwJpx2nmAhMMIQpS2s6VKg=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.1_1641119308266_0.6951762068303875"},"_hasShrinkwrap":false},"4.0.1-rc.2":{"name":"ts-pattern","version":"4.0.1-rc.2","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"e264b8a7819d509ce4a6a03ceed16e49ce1a97f0","_id":"ts-pattern@4.0.1-rc.2","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-mZsq1yFp03OYSoZvJsqIXzBo/ieSmR8ZOfNvC7vPVeaI9cn+2/XazLELPhlX4mNjdK2xJLHeV3xKaCUsRZW8sA==","shasum":"74f13baa2fe25fd3820b073fbb7a5d6d877e3726","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.2.tgz","fileCount":35,"unpackedSize":93064,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh0YDvCRA9TVsSAnZWagAAOkQP/RCJLNy6HOJUSYw936BC\nZAg7ruLSy4In1t3iY3LHNz9EEd1ogZh+xnqeJgTK+3G3vKLG8SivqDe55aNs\n7QMy7BIvhpnXES1fjks/CJRAOXiMTrtDkR1iQvMMcr3TlV+C8Lkjz3PGCLMi\nSivc3cOtA7aZoGQpRMHx5GQOrGTHcUfQxhBZq/L8tX2YDKZxCulX9h+SLgWM\nYrcBd3l/Fue8dSj6EwaT2nxOw4oiKo/PJtzKnv/Y/SUwoaao1sbuI8HSdvny\n8TNaGDPapnkxgoX1iUyUgS6vnjPWY1SeDPhNVY/I5MfbBmvtfVXZrDFrwaiJ\nwXaxvFeHKvzpXtw0aVLxiAf9XkcWqR0ccSstg53rpfSkc1BbQHUqDiqkdSJf\n+Rgnf+jn6YnH8Ojt80qd6lFni1PtMaZT7YuAOYQg7dEUz+Ahn4ewzjs1Ehj7\nTUghXC8eanTibqHRthEZcq2z8LkEQYWOnp8axYvWRZL3YoEtedwsJXHFmq0u\nUgwyzW/fL/GZ1ksw0krwHx7oLyYtkWr+ZyEEN85wN6vJ81J77hNzH+JcoibY\nQ0ytAygiqFhHnaJ5JwMbBzEu26KDbwVH6ucCwuXpOSKpfXWTE0UMgXwLK80v\nf8fmP0GgkrPILc0oJQksbNOkszkk1zZh6bjYHC8zqjHlg+pwq5VgUEpcNXoH\njeQu\r\n=QkRh\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEEcmbcc1BibHUt8LV/ZVsbzn5gAJuU7HFZDT8eF1vflAiEAomYfBE8VkiO5NO62dzfgAGqTTOz66zdSKeuQgDBzHLc="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.2_1641119983772_0.944924225827334"},"_hasShrinkwrap":false},"4.0.1-rc.3":{"name":"ts-pattern","version":"4.0.1-rc.3","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","exports":{".":{"require":"./lib/index.js"},"./package.json":"./package.json"},"scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"a979e4602eb50e31b5c79e7426f1b6556337d3f3","_id":"ts-pattern@4.0.1-rc.3","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-pZBuUmjoWwQ+mgVOf5p2KbrQgIS0Ti0KTKNBrCCaUmhU2Y+aHu1OkEwN4+D3K+RaeZOgz6xDOdl8kOJKRBSj1g==","shasum":"04ec41cd8e101a256139d9bda97c2a40c59f85d6","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.3.tgz","fileCount":35,"unpackedSize":94995,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh0fgWCRA9TVsSAnZWagAAxBEP/ifCBa+OW+TxbSjs8Uil\npoC0sOZuc9sBMaiiSGZCnZSpp4+ERl54FA+qNsgYx0YR6xfK/4By3gjIw0Jo\nn+NpdKOb51puvZ+NlkQnRQEfX3pMYq+3h3yBquJkOlJTrC72M0v/e6VPuIDF\nIV5G1124bbgU3qTOopjEVU0myJJXJ6sdAS3zMXArGYZCV9CJK2meoqGAAC58\nIWizSVxyqDg4v1gkbVWXCipUftgb9K6GmGdL+hVCTxd6ycbROihx7Xt+D02K\n/Xx1Tojs2sOwc+QTIFH0BtCqQd0Vxm7Y8HyR6rNwyh+yoS3FJHNW466iIDR9\nb89ukwEJR0ugn6xi+7fUsAW7reUjR1IQULa4y3QSZFrh7pBh86ypz4haBcut\nSwxeJwx/iaeRhd05pdqirnCAasTGv10JjhRSnOlVeb1pNwDrcp/aK1s+NGXF\nkLjhvCNtyiGh8hnJBQp+QnojZmkOtWyk4VUzp1NVXSGy7iRsN39r/eOn4UGx\nawsxmNoW4zvvHlFx78Pci7C+Ekn6fxmagFJiMwPy9V7t66L80wlRNoVmk8gn\nn+RIIVRLNzoOxsRIU56p2vxupqx44c+eg36f5MtJeoXtmjy4FCv2tVAuQeWE\n7TZBzD287ipkcbWB+suUQ5muhMlFNeGVUXS8wWrVTFm2qWMw6fKNLKc97ik5\nlBfy\r\n=B9dg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIAHpHN6y+t1Z3sVHVm/dP9mg8BXkAYIpNVTU97DDoVFmAiA4YhlClQHi5Gflo1X7lMG/0y59ippo/zuxYBLhcGSJnw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.3_1641150486433_0.2465270601757541"},"_hasShrinkwrap":false},"4.0.1-rc.4":{"name":"ts-pattern","version":"4.0.1-rc.4","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","exports":{".":{"require":"./lib/index.js"},"./package.json":"./package.json"},"scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"b0c10899c19923192a9b233689a3bcf5cfb205bc","_id":"ts-pattern@4.0.1-rc.4","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-WlXszQ2I5jghOe7tPi4TkmhKYrnNoPh/UjKxbxO3Gx7cHbmqMhgFfUV/cyEwhe1Q2YF+EdBmRvCLj4vJ7JzOkQ==","shasum":"9a51546302187d646265b3f1e884094075ea0191","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.4.tgz","fileCount":35,"unpackedSize":96440,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh6HOXCRA9TVsSAnZWagAA1LcP/33mwAzoGegrz4Wmpurd\neSghHsaHcQUNeOJLyymc4N6RfjdWSKODfpSM6monA0Flkyb35+xx7GWzYo4H\nQUBI+jcQg16MDUwaOzerd+1cpQHZ4toAAxnuH9O0DtcEB9TgYeGAOWlPAR2K\nNymhLFVuiaxxVdDnHwPa3xnlcxvoXsSXkAU/sVeUroQV17zIwJeQ6Q6YdbVx\nhsN7GWmE/Mao/8ES4Js9nPY3gJ9Z+6hXsE6gZCgOKqmvYuudrcqwIl77XZu7\nKnTVw2cF9IV71ppajoKXhkSHDyEmc9z4msklTzsgGVqAc0u3Gw2zAmJ5YjWU\n/Xn/5BDZP8wWU8VlY5uGjyFKGg24FHVAP8jPCZ++TPUbGdESlg/Ex8otr9wj\nd8KOIf/6+wmUq1QK6jXtDWFatTY51OpnuegZdaNUrRVRCGysfk/Cqe/WdNSh\ndFVLfg+Mo+0MLhvPSmnPPLb/qYG09sXthk9hGZBwMuqWJHwYAGH3EJsqvjxc\n4n+ySHBd5/va/qhSAV19drVJo+t3zoK1d8CT0WdwMS4/E8AwL5F4oQ905Q1s\nxOBgC7eYjbVFI5BQBocUrGmjr7z2Xb2v6cHSMOymWC+ZfNEl5REVpXJ14G1j\nnWP1H/dvannHr/r6kD8IAKyOLTau51ALP9cwDoK39GOsKtVnOedi9xFOqWNh\neWdJ\r\n=XpZg\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD3D5XIjVH86DkN1bOq6cIu3OItu4e3K5mQGrFGUGDyEgIgbwWDZV1quc2XTvXwMcUVED4hNMv4mnQnvBSI5YkOtqw="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.4_1642623895232_0.22664830080067522"},"_hasShrinkwrap":false},"3.3.5":{"name":"ts-pattern","version":"3.3.5","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"gitHead":"bb4f5fc53b1c633f4e35194c6f3a8d64f3879d56","_id":"ts-pattern@3.3.5","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-LD+wFR/RNckk1DrKV0LTH4KIT9wRqnnOjtEf77ovhKcVi8gf83Uf6U7OdywEua6KD9SbHadUdfolayfIUiPxzw==","shasum":"9a4bde1d44f9afe7e82409820f68790232c2544c","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-3.3.5.tgz","fileCount":31,"unpackedSize":77130,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh7cefCRA9TVsSAnZWagAAfTIP/Rf082nS6ID6DfVELy4/\ny9GA+mEN0IiclT6LI+emLemEUnf/D7f0dm5teTWASPmuDSLLxDX+Plvxu+bp\nyduYHne7nm+8WUhmZmyOIENE9JgdH0ar/6RiKCTf5odMtITcX9+xn5R74q0+\nWSCRltRepFEcMUuYaBSVCQDFGuMDr0ReyKasQDtvDj8/nhcj8uzuLjiE6BAk\nJ38rmWw2w0YL5Qjoh3sln5LW1Wk2MHOt1q1xo4ubxG6uQ1Vbm4jHoIpWfxDb\np9tU7LflLuHvf9BCAEgh+1fWDMo0QFxVCcQGwhyXdHP28REbEYBYgTVykfZ4\nteNPjhvbWc2Gfjx6Ugep3uSNGDcytwrkEmvMXCwGy9sUY0aXPbq/0Pf01fmQ\nMBrgjsCENAd5QZyBBakFpLlFcXcHLoLq2WtWfwJI+LSgjqFreq3tfWPrvyBW\nXwJ/I6dDjkiR0yC/13RP72uCwFdZlaBIKOno3+oan55gy/eBZe2R8JsiJoD/\nEN00aRL189k9I5Rci+ySmF+TFp45q1rJcdr0cB00TTS14Ru7mHeUIxO+ecxd\nshsKMS1/jtsxzG2HkwidelMfgtYYYFrAtZ/uqUok/LHV1VDiBnwY6T04vDJU\n465XfYfDSX21bDERuqzOOgu8gtN71W/1Jr+WOuUHMBNb4+/D+mA1TdIXwkA2\nELEX\r\n=75cl\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGr2Pqg5snBn5rQ7hIBKAGM7JCDV/IS4nnIL+j6nT1sCAiBM3K/GgngxTgO4UQmXP510YksVctkfmUMD1Z2qLmHbjg=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_3.3.5_1642973087461_0.9932812244226292"},"_hasShrinkwrap":false},"4.0.1-rc.5":{"name":"ts-pattern","version":"4.0.1-rc.5","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","exports":{".":{"require":"./lib/index.js"},"./package.json":"./package.json"},"scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.2.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"e32a8b33d46e3b90888201ae391704b6e7022da1","_id":"ts-pattern@4.0.1-rc.5","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-0uaMc39fv4EE5kk5ikdpBKXR8PxuUQk2481tVaiEe25UZis8+VANdfS9pHOgu3cFX309Fj7Z2m3ie6CitsMzVQ==","shasum":"3c1bd04cfa0b28cb2cb2c1838dfe85f9ebf4e9ae","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.5.tgz","fileCount":35,"unpackedSize":96458,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh7oeTCRA9TVsSAnZWagAA9uEP/0Ou4wFir26F1nrUImys\n1/WMmDpbkKzfsxO8hHUpkX7ntZ0n1FvMDFbRduGBK3VHHYcoRUoNCESCo3mS\nce07FwW34OgIOfHatCsMlpoFTODMGpkJ6/ucLa8yrupklqEULoQwj+NNIxyt\nDpAwO+rztKdaWxG+YVXzgL6zKr9ql82PS9um52vNbtYsZqyJFuN0Y/qspG+t\ndGLwVfVsQLEcO219kYB8MnpsaVW/zIt6E9rLRLV2QHtLA1J9Ui0StIpytKyA\n4fMs4CEPwg5l1UnGvuXktpwzFoeKk+3VpLNYF0JdbwkUIXB47ZlfZJvj/fV+\nILfkU/ZaUxtcZPOXLdp70QM/S2OVtdngey8JbopC92nyCXvKviLKW7/ukfpH\nRcdbemY4mrbbhFmRb5kd+QpCQdX1MktYYpn17Up/EpVXR1pCsABPVHG9bWM0\nahprzAf0YM5G0D/7DNiS/CIeKciNQ7w7V8H/t/+RUdRYMCev/xxiKmpaK8Z3\nIgEGpzJ2LBmmDCBmK0xqn1m+eC1m1gD2NWHXZ98funl1U+qfKZeEj/ZL4Weq\nL6+bM7v9uXyJ+kTnEj5yJ19HRSiq2ejeqgkvgvwX7v+XP5yarNxZsOMEaFd6\nFOiVpStilnDOInhQ9/eI2QWjwHYMqiE6IApk7f68HUIVI/2UKKdcV3feBjUG\nvMx8\r\n=3moK\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDgehZt0czQsjEwRrWejNQJQ3wvDwHnq4c3DbMum5hTUgIhAKc9wHLQ+5K1kGDdjpYACVK6VFegFKCeSQXdH6+L5xW1"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.5_1643022227015_0.9778001352905539"},"_hasShrinkwrap":false},"4.0.1-rc.6":{"name":"ts-pattern","version":"4.0.1-rc.6","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","exports":{".":{"require":"./lib/index.js"},"./package.json":"./package.json"},"scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"7d4097f3a4a1942a55e0755ece8a613c95fc4ec4","_id":"ts-pattern@4.0.1-rc.6","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-JXBIqvo+gA7xVuC0U05dDXGDYZn6ZtFHT6Vsd+gp8QN0PL2ioPhd1xsV1WEF0t3DAcoBZsFu3eHkuzJ/8+FaSA==","shasum":"7f00fe5cbf7775405818dbe03f86bd3013507ff4","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.6.tgz","fileCount":35,"unpackedSize":97116,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh+B8dCRA9TVsSAnZWagAAmEgP/Au7X13KmTwk1EnvSLNL\nxsfIqhyrDwOPpLSzvDf/R64Mvh/9OwP+K1FyYU2EWswEhA9qeg9re/D1xYWE\nHGHBK1kfCzTz5lB0rQgNWm4Vm7XWS8ShPVuYUYQBOgL9EvfutUE1Fn+VK32P\ntYipiqJp+balJtv7bqWuk+rFKf0Mdq+4E6JU++bdky7TAYtVhuG3vrjwtlM5\nnSe7V3OkExnOU9RmUJzSiQjOhpeMB+vvMx/X1dNPb9XsKhP0iaA2w6zJ3igq\nUl2Tl2pMFilfF40A7ulbqGaritElqDOqBInhOQ3+pgtk61zPLPqYwnHvVMuH\noHLtXmlDKhFQa2mWFkrPeOADl4kCyNdjp/0BrJoV3PNO7UkOEal38/FY9oad\n4UvSzNwQd5Ug15NxpVNcb9yi0gWX2322SOCCaVOm4MwbY9BMlyhye0D0AR+e\n5sRzBOT8bIW3Lx/K5xMpUMPd5sPt7fuCLFn12OZ9KOjk93ny8bh2U7tm5otv\nlh2K6oxajpdW4IIPUaL+wDp5zL8sV4N6IMlgawD8evBTvdmOE4A+ybe8Bbo+\nb5OS71IQaxgn9FjaL+adqrUhVbHeeKZgSban3gcj4E7kPYWdVaie/DzypUr3\noIWce8TddifOss+f0ltRWA0ctkcH5Wqg6RJHQOIUV3kAXvtNvfEM4Vbm2hWn\n6LVK\r\n=mBYF\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCr9vj4IbOFYPBz2S57x4thLNtuJDWS0whr68iDsAJ2vQIgSjBm6gcNyf2w+4153jAm0DVM82BYbfvI6G/E6phaCE8="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.6_1643650845459_0.4277185675059174"},"_hasShrinkwrap":false},"4.0.1-rc.7":{"name":"ts-pattern","version":"4.0.1-rc.7","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","exports":{".":{"require":"./lib/index.js"},"./package.json":"./package.json"},"scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"8dc0ac5f9dd3467fd47d95717dd3ac169ba2249e","_id":"ts-pattern@4.0.1-rc.7","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-NtDfMyNdF1Czz8rBrre0N2AOSTXL/P4NHoM8/fD5NhgiRFzxErExTVwcBp9+UcNvMuNFg1Mswpv6qssNN16aHA==","shasum":"44736fb449170fa8bfc04432498a4d621a4f1ea8","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.7.tgz","fileCount":35,"unpackedSize":97116,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh+RZJCRA9TVsSAnZWagAAZz0QAILH9W+LEia4meY6SX/K\nNkUJRfcybfUCnuX0G8X7HC7k18PxSLn0YjJUiR3sr/cCtfe6gOcVx7XZwd8W\nGmS6mTHopOX8I18Z+1HjLX8tXCdshaGTg29Rl/JuWJmNg+u6tyrr5bQ9GthZ\n9p+BukAXm4ZOzh0qKoMYdut9JhpTAueT1sr0RFHQ8XBxzqI7OiYosE5/iuMx\nAVBwuuY4jxUtHK/lIMTD4ZXkL9uY5NkLg5ZZwjx+q5u1SC0jNofixEwVbDH/\nxHlKsr0n0H3tw2xVWa8eG2gyJrP2OjEhz+2e19frn1hw3wuPJ/QHsziMCz/Q\npm9UHetvp1zxS1fLLXoJytCRhOHI1RsfrDes+7vMhVrgSpFdoeltEAwoIPl+\n8gHFpY0bDt2ayO43lW1jnktDZvHqI2MYChNBSn5sDyizuJifC5RKRpcyUevt\nbsiAQzTZ3v81V5cUaLMQgFSI1nTJoY9ZVt5xOHPs+iIxjrCuE1Y567LOWEs1\njeB9A0Y/oE9pmfk9oJaUByXnaTkelJZL5p13aTbHTDcw4PrbpdW7nsv2pATA\nUq1w05/EPHv33iitnqPVcraB/KhyRCVWkGr1e5I+SUwuIxUfpJd+9wLZ4y5t\n+uw0HS+Kcrsbv7GO8oZ9mvP6/Z/WrbVM17NCMqD9BCQ2KqOXNvVI1a7Yzgqs\n/z5D\r\n=6bGh\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAKLWKiwHb1guTxqk57yAdTZC93btzYPi24X3AmwDphOAiEA0Wyl+EAuxXfrZKgQMOBFyz+GcMWO/sK2Ast+xb7KBGU="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.7_1643714121668_0.842577263724966"},"_hasShrinkwrap":false},"4.0.1-rc.8":{"name":"ts-pattern","version":"4.0.1-rc.8","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustive matching** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `when(<predicate>)` and `not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.4kb**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern | TypeScript v4.2+ | TypeScript v4.1+ | TypeScript v3.x- |\n| ---------- | ---------------- | ---------------- | ---------------- |\n| v3.x       | ✅               | ⚠️               | ❌               |\n| v2.x       | ✅               | ✅               | ❌               |\n| v1.x       | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [`__` wildcard](#__-wildcard)\n    - [`__.string` wildcard](#__string-wildcard)\n    - [`__.number` wildcard](#__number-wildcard)\n    - [`__.boolean` wildcard](#__boolean-wildcard)\n    - [`__.nullish` wildcard](#__nullish-wildcard)\n    - [Objects](#objects)\n    - [Lists (arrays)](#lists-arrays)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`when` guards](#when-guards)\n    - [`not` patterns](#not-patterns)\n    - [`select` patterns](#select-patterns)\n    - [`instanceOf` patterns](#instanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n- [Gif fetcher app Demo (with React)](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n- [Reducer Demo (with React)](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n- [Untyped Input Demo (Handling an API response)](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n- [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n- [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n- [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, __, not, select, when } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### select(name?)\n\nIn the second `with` clause, we use the `select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`select` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: select('prevData') }, { type: 'error', error: select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, __ } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: __.string,\n  description: __.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: __.string,\n  description: __.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `__.string` wildcard\n\nThe `__.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(__.string, () => 'it is a string!')\n  .run();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `__.number` wildcard\n\nThe `__.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .run();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `__.boolean` wildcard\n\nThe `__.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .run();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `__.nullish` wildcard\n\nThe `__.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(__.string, () => 'it is a string!')\n  .with(__.number, () => 'it is a number!')\n  .with(__.boolean, () => 'it is a boolean!')\n  .with(__.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Lists (arrays)\n\nTo match on a list of values, your pattern can be an array with a single sub-pattern in it.\nThis sub-pattern will be tested against all elements in your input array, and they\nmust all match for your list pattern to match.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    [{ title: __.string, content: __.string }],\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([__.string]), (set) => `Set contains only strings`)\n  .with(new Set([__.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', __.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', __.number],\n      ['c', __.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `when` guards\n\nthe `when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to when.\n\n```ts\nimport { match, when } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: when((score) => score < 5) }, () => '😞')\n  .with({ score: when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `not` patterns\n\nThe `not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, not } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(not(__.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `select` patterns\n\nThe `select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `select('someName')`) or anonymous (with `select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, select } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: select('name') }, content: select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\n#### `instanceOf` patterns\n\nThe `instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, instanceOf } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(__.string, (value) => 'ok') // value: string\n  .with(\n    when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(not('hello'), (value) => 'ok') // value: Input\n  .with(not(__.string), (value) => 'ok') // value: { type: string }\n  .with(not({ type: __.string }), (value) => 'ok') // value: string\n  .with(not(when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: __.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: not(__.string) }, (value) => 'ok') // value: never\n  .with({ type: not(when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .run();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n\n#### how is this different from `typescript-pattern-matching`\n\nWim Jongeneel released his own npm package for pattern matching. `ts-pattern` has a few\nnotable differences:\n\n- `ts-patterns`'s goal is to be a well unit-tested, well documented, production ready library.\n- It supports more data structures, like tuples, sets and maps.\n- It provides a \"catch all\" pattern: `__`.\n- It supports exhaustive matching with `.exhaustive()`.\n- It supports deep selection with the `select()` function.\n- Its type inference works on deeper patterns and is well tested.\n","readmeFilename":"README.md","gitHead":"592720456e8b7ebffcca287d65f20005cbe1e443","_id":"ts-pattern@4.0.1-rc.8","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-W7LyBdYv0okTx72r60SCddh06Vb2hYbl4W0s8nDT3qCWmKtIw8U3ewEYSFWhMsBNQrYjBHRkx6PH03Ib1j7Zmw==","shasum":"1313bcb0e51abf5992e63ed02418e9fec97e7212","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.8.tgz","fileCount":35,"unpackedSize":97120,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiCOMTCRA9TVsSAnZWagAA0gUP/2JwIBoG6jkY5MwOozLV\nCQkz9JeyWxcgq2l8DMFUFTf1ilHcvU4IklqjSBPSTdTepnzHHLX916aV77DA\neBw2xQJVdKdwRu+Pjh9+KZ7bM2k1y+B+IQknj0kFmMeVYE5WqydN86Y84L2N\n+owi4qIV9uobnCPla9KXkOOmedxzzlXvZrszHYixqquwbcn6fA9AScEW1M0D\ngE6qunyjgFkz9Ag1LrF37KusUnusrCNhDoP6f3kE5k0oCY9DEXJMSMYcrp18\nfPb5uBCdNBRPQo5byDKeA/W3nO3zXNaYxPS87ZThGJ2bHIQW+3N9cY6L4x+y\nRDytmF5qSIsDQMXrmAYQEJmYtKVXosXLUWHU2KHTBubQ/71ocq5XmwfZVUrk\n0DvFVI8LOR70DXQAkuOqSz7pNLm2swbebnGzAZ58ZtJ0upu+15D6uSsMilla\neiKqfnVtTPO+CDWOhyC9G5lEi+nyUrFC2Wzi2qxsw93Ti4jzNc1ZFzspXkSt\nDCe1yqb52hw+SLfx3j1HwyJQ6Z9GMPaG7khqEpEd4xueVGEmuLF33Arg4q7Q\nGAkbIr9g+M965M5S1X3CYDmWJJb9i2GE26FdCfSXGTGp/Sz6aidzXNQMupPS\nqgJU8hPbu6icsWY1ZjsRhQyuYW6Xad7UDmrwBuxWjpyHuqh7NrDWcL6t87aC\n4UA+\r\n=znKW\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICGp84bXU/YYx9VixZrzFgdnHPz+rH9KK7AznNvZaZwnAiEAo7wjz3sAuE25TTT5Qk07LtaDmLE0M8eXhhpsMBUOQ7k="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.8_1644749587151_0.8979262231082956"},"_hasShrinkwrap":false},"4.0.1-rc.9":{"name":"ts-pattern","version":"4.0.1-rc.9","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `P.when(<predicate>)` and `P.not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `P.select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.9kB**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| ------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x                                                    | ✅               | ❌               | ❌               |\n| [v3.x](https://github.com/gvergnaud/ts-pattern/tree/v3) | ✅               | ✅               | ⚠️               |\n| [v2.x](https://github.com/gvergnaud/ts-pattern/tree/v2) | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\nNote: This is the documentation for **TS-Pattern v4**. Find the documentation for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n      - [`__` wildcard](#__-wildcard)\n      - [`P.string` wildcard](#Pstring-wildcard)\n      - [`P.number` wildcard](#Pnumber-wildcard)\n      - [`P.boolean` wildcard](#Pboolean-wildcard)\n      - [`P.nullish` wildcard](#Pnullish-wildcard)\n      - [`P.bigint` wildcard](#Pbigint-wildcard)\n      - [`P.symbol` wildcard](#Psymbol-wildcard)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- TS-Pattern v4\n  - Unfortunatelly Codesandbox doesn't support TypeScript v4.5 yet, so v4 demos aren't available.\n- [TS-Pattern v3](<(https://github.com/gvergnaud/ts-pattern/tree/v3)>)\n  - [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/basic.tsx)\n  - [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-n8h4k?file=/src/App.tsx)\n  - [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-c4yuq?file=/src/App.tsx)\n  - [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/api.tsx)\n  - [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/when.tsx)\n  - [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/not.tsx)\n  - [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-0s6d8?file=/src/examples/select.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.__`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n- [Wildcards](#wildcards)\n\n#### Wildcards\n\n##### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n##### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n##### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n##### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n##### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n##### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n##### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\nconst output = match<Input>(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n#### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n#### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\nconst output = match<Input>(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n#### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\nconst output = match<Input>(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n#### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"2f656c6a26fcc834bfb400647c11c7467633384a","_id":"ts-pattern@4.0.1-rc.9","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-1gh8yVmXpcmgDr7H7KQzWvCSHn7VXRBn+E9828PGi0uu8FbsSU69be1mLXONbg6LJ29uNZFMxqF4GGDXEcJiCw==","shasum":"bb0cc3ad2ad69bbd8adfbbe31fcfcc5e756a97c3","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.9.tgz","fileCount":37,"unpackedSize":103646,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiHo0CACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmradg/+KQqhQZWSnULElxuq6Epl/6AfnYWF9dW+BdhpnvETH2JmV5TT\r\nPKTPA7ijVQSIW0DLLd8xcY825ohQvEosxH5LduqJGKdW+AesjId/290Z9s40\r\nThP7wcSwL8jNaGnYETARRDqcEohPZEyvnAiiPxT4j+ajmc9qD/0FbK13AFTt\r\nJBl3kujH7e0ubGM6QvPzfiGzS/wj9TU9KUzG+9s3sGSmVq6Cb4NA1SVE89Um\r\njgJdWNcYopfxz86bERgnmJuClqXGM7WoP4Z5faScePYJQ06NWq+prHl2EhgO\r\nhPwu/UE+AIjWwmt4OLK5znhLS2aoLKipdCn63TxJdeajOKeUADuaJRqZ+DZG\r\njmq+CaEgiEkiHoVMgx6mcPVk8s2tZ+hRjfXajnqiO95CDCwZnEyc5aakhA8q\r\nGd4Zfxp1NathGFcsofWo8uqhQUG+VzS4ipwvydp1FEoqj3NrUjfC2xhM6FZS\r\nKIkatSYR/rHkKt/71TX/ohpTgq4PJucAjrsSsW5uNBNRBcJStUuCWhPlUjJW\r\nNO3RjBmZCvisqAMzLBgnMef8DvFe7SemnPO7GtRcSnjs1FMSZeTi4dw51vqN\r\neKNk1WMeOMBkFSmnL2UpVe3aUJsjpFmmWr9CQeG2n58kpSnmYga3p0NHz4KU\r\n46JnY6LH443PJlPxSz5EnUpHqwnpOQao3kM=\r\n=qOFt\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEHEoxUSFk3qDR8r1GeQKEYgLTNphpHjvnR9VoeNH3O4AiAlTiyWhicY32qw/DBqYRwtSjfC1e1/qREtm89Lwwxy1g=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.9_1646169346590_0.6951919388257923"},"_hasShrinkwrap":false},"4.0.1-rc.10":{"name":"ts-pattern","version":"4.0.1-rc.10","description":" The exhaustive Pattern Matching library for TypeScript.","main":"lib/index.js","types":"lib/index.d.ts","scripts":{"build":"rimraf lib && tsc","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","prettier":"^2.5.1","rimraf":"^3.0.2","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports `P.when(<predicate>)` and `P.not(<pattern>)` patterns for complex cases.\n- Supports properties selection, via the `P.select(<name?>)` function.\n- Tiny bundle footprint ([**only 1.9kB**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a technique coming from functional programming languages to declaratively write conditional code branches based on the structure of a value. This technique has proven itself to be much more powerful and much less verbose than imperative alternatives (if/else/switch statements) especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years (if ever). Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| ------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x                                                    | ✅               | ❌               | ❌               |\n| [v3.x](https://github.com/gvergnaud/ts-pattern/tree/v3) | ✅               | ✅               | ⚠️               |\n| [v2.x](https://github.com/gvergnaud/ts-pattern/tree/v2) | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ No support\n\n# Documentation\n\nNote: This is the documentation for **TS-Pattern v4**. Find the documentation for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n      - [`__` wildcard](#__-wildcard)\n      - [`P.string` wildcard](#Pstring-wildcard)\n      - [`P.number` wildcard](#Pnumber-wildcard)\n      - [`P.boolean` wildcard](#Pboolean-wildcard)\n      - [`P.nullish` wildcard](#Pnullish-wildcard)\n      - [`P.bigint` wildcard](#Pbigint-wildcard)\n      - [`P.symbol` wildcard](#Psymbol-wildcard)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- TS-Pattern v4\n  - [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n  - [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n  - [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n  - [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n  - [`when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n  - [`not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n  - [`select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [TS-Pattern v3](https://github.com/gvergnaud/ts-pattern/tree/v3#code-sandbox-examples)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is infered as { status: 'loading' }\n    // `event` is infered as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.__`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n### Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n#### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n- [Wildcards](#wildcards)\n\n#### Wildcards\n\n##### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n##### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n##### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n##### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n##### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n##### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n##### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n#### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n#### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match<Input>(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n#### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match<Input>(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n#### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match<Input>(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n#### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n#### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match<Input>({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is infered as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n#### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n#### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match<Input>(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\nconst output = match<Input>(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n#### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n#### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\nconst output = match<Input>(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n#### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\nconst output = match<Input>(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n#### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input = { value: new A() };\n\nconst output = match<Input>(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"d62901271d3ccf64721c91fe83c7fd82c6c52b8a","_id":"ts-pattern@4.0.1-rc.10","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-iaS7ZT+k1ks726HKKIGyt3aiRt+uesPhR+XKSFa8FoOqrYnK2N/wJe4faeVmPlA/Jd/g7arFDKnphl4aCNnjjw==","shasum":"4b088702cf4da2036f9aee568e016f5f32ce0f40","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.10.tgz","fileCount":35,"unpackedSize":100279,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiIJWVACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmqbsg/9GXEFxPDur6l3HdyRqL1o6D4p+oPP+qcmCKkMzBQjxjSPL9sE\r\n+Hk7Lnmo5HuCVoY5y1oM3Q+fndbzuqxu3MrKrFyTAskMR8YCIfyf9DDkDVhk\r\nYEhjcl8aB7MIBRK/piMsEV5WuxfOWUn2+0rVQ7IWnf5ZQ2u6g0uNKEsX8W0x\r\n+NplAtTWRYiOZntbh11GppncbYxRFLWX6nMRn1MWrIY+wojLaEiNn2kSBwQL\r\nwucamueBoczDo1Rj3Dd7Eovq/bAikXpBsv3zzufcSy4rlXqKf534swqMm/0L\r\nDbKdzhXkUiLN1w6Zf1SeshoON+mM3W+ofv7DgXiP0i5XvZ95qk47DPzShmAT\r\nyvuu0tNyGlO5RfeEGi4LnJ4CCLpXVsIO3v61aRcm3/A2Ln1xe1hHEG4kDXRR\r\nwPG2blofRh+ol7Ra4g2Lrc/xdd8ai90HqN9DYOMidzcGSPNJ2uASycnNB760\r\n1hrqGXfSN8bO+2tSQnutCHDrF+WDhOyvlvowyYU692DGy7GKcCgwRuvQRsVZ\r\n1mbF3I89hyzS8auWn6cJxu5TAZ+CyHSysUKqMT9ejmJsD9Iy3bIgkydv377d\r\n7fqhnZZVapKpfaNgiDV4BqlitwmsTs1DpkKLIt6bU4qXelSbfNyWLszxA6iX\r\ngpqH+Y3ysXGGB5Rsg4E/MHHp4KUgBwC1ypY=\r\n=LevG\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCUMtyuVVK/80rWmuh6Ph8KswvCsYsV722Edrofmna9wAIhAK6p8WYkTLxp3MEEx4lk3ZhQFy2TFxXRgxlgmEV4YPR2"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.10_1646302613780_0.620671593073211"},"_hasShrinkwrap":false},"4.0.1-rc.11":{"name":"ts-pattern","version":"4.0.1-rc.11","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports **predicates**, **unions**, **intersections** and **exclusions** patterns for non-trivial cases.\n- Supports properties selection, via the `P.select(name?)` function.\n- Tiny bundle footprint ([**only 1.9kB**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages which let you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| ------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x                                                    | ✅               | ❌               | ❌               |\n| [v3.x](https://github.com/gvergnaud/ts-pattern/tree/v3) | ✅               | ✅               | ⚠️               |\n| [v2.x](https://github.com/gvergnaud/ts-pattern/tree/v2) | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ Not supported\n\n# Documentation\n\nNote: This is the documentation for **TS-Pattern v4**. Find the documentation for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n      - [`__` wildcard](#__-wildcard)\n      - [`P.string` wildcard](#Pstring-wildcard)\n      - [`P.number` wildcard](#Pnumber-wildcard)\n      - [`P.boolean` wildcard](#Pboolean-wildcard)\n      - [`P.nullish` wildcard](#Pnullish-wildcard)\n      - [`P.bigint` wildcard](#Pbigint-wildcard)\n      - [`P.symbol` wildcard](#Psymbol-wildcard)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- TS-Pattern v4\n  - [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n  - [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n  - [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n  - [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n  - [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n  - [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n  - [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [TS-Pattern v3](https://github.com/gvergnaud/ts-pattern/tree/v3#code-sandbox-examples)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is inferred as { status: 'loading' }\n    // `event` is inferred as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.__`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n## Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"325715413fbeb1d9cf8fa4748d6e8d344423fb1a","_id":"ts-pattern@4.0.1-rc.11","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-TdEH1BLTQvgT7DNl7eo1XkMdTgkmkVxBrf6lcITCqZ2PzPU+Flqkpf/B5CEchjX4nXqFP/a6PQp8TaEmtuXH1w==","shasum":"1aa7b79f83a12d46a3e3ae3efc5fe5babe121135","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.11.tgz","fileCount":3,"unpackedSize":37624,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiJ8NCACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqVNA//U0LnLvnk2Iw13cNoRYQW3UO1WIMsFmDi3fo34Lw8/BqKPIox\r\n9PJ1pu3WVdAXe/hURsXdqscmSqXocKgr4B7JfwZGiTv3tSFEr+eo4CwAWj3k\r\nhWOY3e5UmBOsAg3O6DMB+Rah6bM/kHvHWdpT9OahsYb62JMxY+sTDjH3KmuG\r\nqz0SrDzeYdjeijhqNTPVp8rQYsMiSg3TTIg2tjj3NC82IR4SVj2ILPngb++G\r\n/Fx0vneUZUTDp1FsIHlsg0sQewnarexzX6HXejY9caeH4CEzL03gvnp9SJc/\r\n2j16AVm7mDVQ8vN1wslASey1FLFTpc1NaUkWUzpVywoaDa77tdwdPkIrhWxv\r\nERKtzcwvA/bgfggBFyjuDnf9enSV/ZnXgxMooKvENboRsEtOOcfnnUsHMnId\r\nBgdjgxVApYXKbPInI7LzFnqhJvZHqTSg+E2Y4PrfjMRoY9OtoE86Oyg8t5Zs\r\nrVPP2xMtTdQSG8ERTVvObtCuwtsRkLQWWLLypcwa4PQIm90dDLwq8yzFTSzt\r\nluUeiQUYK5FOkyCex+zkWw3f1pC2UVcOXZ32+YR7ngzrddHIuACwmb4WV/T/\r\nZgVDmE7gP2VxZAFUlY3CDkn4yzQXInibC715orEq9hiHz+WpJSzeiFFr2GSA\r\n6+81bhmWPvC5L0aGV9eS4ai3L/8DyjGwLQk=\r\n=OeF4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBgHydnzi+9SHDobA/8nqfsv7geshdNqiGOEdbVP7NukAiBo+s05WEcAuKttCKVjoPQZk60pUrzhfS2KTWWsIYnj5A=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.11_1646773058041_0.6693510150522337"},"_hasShrinkwrap":false},"4.0.1-rc.12":{"name":"ts-pattern","version":"4.0.1-rc.12","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports **predicates**, **unions**, **intersections** and **exclusions** patterns for non-trivial cases.\n- Supports properties selection, via the `P.select(name?)` function.\n- Tiny bundle footprint ([**only 1.9kB**](https://bundlephobia.com/package/ts-pattern@3.2.4)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages which let you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### compatibility with different TypeScript versions\n\n| ts-pattern                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| ------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x                                                    | ✅               | ❌               | ❌               |\n| [v3.x](https://github.com/gvergnaud/ts-pattern/tree/v3) | ✅               | ✅               | ⚠️               |\n| [v2.x](https://github.com/gvergnaud/ts-pattern/tree/v2) | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ Not supported\n\n# Documentation\n\nNote: This is the documentation for **TS-Pattern v4**. Find the documentation for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n      - [`__` wildcard](#__-wildcard)\n      - [`P.string` wildcard](#Pstring-wildcard)\n      - [`P.number` wildcard](#Pnumber-wildcard)\n      - [`P.boolean` wildcard](#Pboolean-wildcard)\n      - [`P.nullish` wildcard](#Pnullish-wildcard)\n      - [`P.bigint` wildcard](#Pbigint-wildcard)\n      - [`P.symbol` wildcard](#Psymbol-wildcard)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- TS-Pattern v4\n  - [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n  - [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n  - [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n  - [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n  - [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n  - [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n  - [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [TS-Pattern v3](https://github.com/gvergnaud/ts-pattern/tree/v3#code-sandbox-examples)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is inferred as { status: 'loading' }\n    // `event` is inferred as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.__`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n## Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"4b98d3e7077b14543dddb99038048e8d04828626","_id":"ts-pattern@4.0.1-rc.12","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-oLSbWAXRK5UPUBsXtC1mao6/Hs7Y70oFSfEJgxHhnfb42BMsv+6UXO9Y1cUNOD4u0gwWhZ/jiCbhIpmfm7g4SQ==","shasum":"55ec89ae34500cb8980e91ecb60efbed92b1cb70","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.12.tgz","fileCount":27,"unpackedSize":217818,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiJ8RgACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqH1A/+LXV9jNeVyEprrg4WdAL2GcYBGauvvB+iSgL+x+dURbsVGwxo\r\n4M8i3M9JEW8v9jtWHuguiS7as2RijHNa3d8dKOpZMj/8l3DW3kpKw0xbprk4\r\nGbhfEjPiUmIYcscU9xTgMLjM5JAf9y1m0SjJbVOj7AFf4Sb1kZxfxoARqM0J\r\n/SfN5CEbK2CA5ib43ISiWz3OCKlTi4plrd67EpO/QfUyXWxB8I+urYTZDULU\r\nGO0+ARTsCgrr5a18vmqXnxUoBKB3HUc/nYgfD8wedy1aysBzrBXwomiZFeh0\r\nTubjr4/Z1o9c/U+KUJXs068QAtoLJXMjjWLsqWO8wKFYSXPXVoN6odrInMoc\r\nMzRUOQ57zRSP2nDgg6KTLMj1MrvhXeId3fgR75eiYjw/sZbO4k0letLd1FMP\r\ngGvJ0cCALkqFWfG1rhM0DpG3Sk5/Zy0m2pFPbfKX0mZJngTwVP5MhEfIImCn\r\npk8wyiTrkXKhGFcqq+PCXc7IG8/gIEBcA4oU/Qff21y7NIL/MZESxXbStS1m\r\nE7WXDT5cNguXzh5w282gymiKQONIqJHQumDCQUJD6QJs77r6LxUwM5wf6qsH\r\ni3hpEaJNOiibF5aJcZDF18XMhpn4zrFCGr6QMnuV82kiq/KA5YAE1Tg8gTCq\r\nEyn9Lh2beoZz4mAAA4YlTHZoFfl0+pQkuoc=\r\n=rGIw\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICs6hiehzgCT20V/mRyKuzcNjEmnj34aEUHZdkF6pmp1AiAKISBMm30mFL7cJCOrmzlrki3B8/DlHfkoSHFMXMniCw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.12_1646773344229_0.20907383946545122"},"_hasShrinkwrap":false},"4.0.1-rc.13":{"name":"ts-pattern","version":"4.0.1-rc.13","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with `.exhaustive()`.\n- **Expressive API**, with catch-all and type specific **wildcards**: `__`.\n- Supports **predicates**, **unions**, **intersections** and **exclusion** patterns for non-trivial cases.\n- Supports properties selection, via the `P.select(name?)` function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern@4.0.1-rc.12)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages, which let you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ Not supported\n\n# Documentation\n\n#### ⚠️ This is the docs for **TS-Pattern v4**. Find the docs for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is inferred as { status: 'loading' }\n    // `event` is inferred as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.__`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n## Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"11e47c04712e67df0d2eac31ebd68514c0e1ef88","_id":"ts-pattern@4.0.1-rc.13","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-ZhDXyvv8TVeyFa+JuCsAx0Mc1UVbkXUV7kG45k06luHnMPylbDSc+To5Wdpt+5iYIZkMdyPxjr9WBFhZB1e8GQ==","shasum":"0bb346ba4b0f751a03f73b3c8ad5414aae3383c1","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.13.tgz","fileCount":27,"unpackedSize":217797,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiLS7LACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpSrQ/9HNSxwEYv/dQnAhjA4W42H0C4iprkYb7yaDyd8i1Tfz41n0uW\r\nAspq+WqGQ483bEHgy/O7By8wWO9M0iAB31oYw7lsH7GpcTJgbIuDK9TWqyL1\r\nuoXoR29zS1mgpk5R8vBswUnRJbi7MBWT7695bz24PRSUEzxbUbQB78N78l9b\r\nETKIOmETq/idCOOPk/J8AD55yjMBIJkbyNz56uXzH9ZNCmkUZTw8bAkxnA/X\r\nbwa5EYE8OhvurDYa0V2MeAFbNJZ2N/lpvLTb1b4j3FTb/mrmI94+firIhaJ0\r\nZDycbcDgIyQrJnnItgF6NsoKY8CoXBIHobhcH3YYcVJVAJrsn0X5POn/7QI6\r\nL1FKkeBDv1iB0m84ySodDVsGqGjwVmBiU+i3ujmjUAonxOqpzvH90lqgGXkA\r\n8ZnoGmAJ6HsjA6JAQ0gqAR1pkVbX/fshs49pPD99/VV0NBa5Bxh+YAegVH9Q\r\nl1wZdmqOr4uqarEI6o5gYqKr7kbRRPF8o3yhsNPlDNHnaa8fs9HWQwvU/xrb\r\nVBl94uOWKJ4q9PTe0N4uhc8wE404nuv3NrK7k/qpgU61PlUVse+cQNPlwZGb\r\n7aVc4tPWL/SHGvJDnqWHr3xV23tyB8GGqKYqKk/2sG8GGfAtF7m7mWkBEAYa\r\n+GiRKG8p9h8Aq8cMlIir3ufQoF8UUFDRkf8=\r\n=fVUz\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC2GtXb4nVXurqJbMAYKAZyXK5HBdTn/wK4V8JuS308+gIgONhYAoOt8CSFloypOTGmBnr0iEuw0xlaXXQ6Ee83Vj0="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.13_1647128267244_0.9364051616892672"},"_hasShrinkwrap":false},"4.0.1-rc.14":{"name":"ts-pattern","version":"4.0.1-rc.14","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`__`](#__-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#punion-patterns), [**intersections**](#pintersection-patterns) and [**exclusion**](#pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern@4.0.1-rc.12)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages, which let you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ Not supported\n\n# Documentation\n\n#### ⚠️ This is the docs for **TS-Pattern v4**. Find the docs for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is inferred as { status: 'loading' }\n    // `event` is inferred as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.__`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n## Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"b0116408e000329d1692705254e571f2220cc537","_id":"ts-pattern@4.0.1-rc.14","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-drOFGlNzC6E6eLDlJFRNsUVdE2W9pR8YaP43HQ5f0LvPGNudtt7LQ7WkMckr/Ptb1UoG2q37sZknG76Darl4Iw==","shasum":"93a7dc226a29efb27c3f0d7ca105328e2af935f3","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.14.tgz","fileCount":27,"unpackedSize":217907,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiLm4XACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoOFA//c2T4Sg4XOTTeBlVBw3FnTxmYv3BlLWBHZyK6s1CgDQ353ELS\r\nlEgcsxuzS2bVlrtiWAFrFBb0iJaxbd0dzCRD86MlE3XXVgkHKMH9rsRyA/oI\r\npyxg2pbgjyOH1v/PZM54Af3yxL/usQJVG2pCVDYGoVHm9VHTV9JXzyso/MYD\r\n0qitKRFEqocv2KwAXl1w70nuS80Lp/USINNdqXHuVSkl9b4CF2+pUjrrVGOC\r\nDhglp6QKy0sEqeSmUjag9C0WV6UgHdUvOXLncfsZpMQfg7YU1yzydu1rToD8\r\nc8QjDHHE54qX+NvB6hnD12P7NQiHYCywTwuqq8krcfY3VYORv6NU11PMyYDB\r\nZeh7hNJ+K1PD6tAW940s78a0RMQdHIoR4uZA9VtFX+Au0owz3h9Hkkwtfeth\r\na4sUmen6u07mRm9tGEWo1pa27P25BosBwst4lpeFqjUaOlWdMU4Q2llyvMVR\r\n3LgyIjW9dzmOvNdVlU/4Cc2R8t4cdpKUayDGZWJMFpwbU2fRyjmqFeuN5yAh\r\nVy0KotyXypGSHXGxjmORj6SlKRq5c1XqqMfIfOZJPNn4VXgITqiOqjyhl0JR\r\nrvuPrFAl7vxk3CkXfjDaRn5xA7awkCiZ0AkA5s6k4sI9s9jAx8cjZRkyMzNF\r\ng6N+jHBTHya2F5sYU3qvXjKySIAtCux1vMo=\r\n=tcmu\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIANTmq+adBJ0umKBA6pHnJmanhIia6/SkAzoSR2CSx6OAiADwcwtO0wBwrGYutuOWVrFVt6hJkp3JryOyT3j0HISeg=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.14_1647210007390_0.9448034148278563"},"_hasShrinkwrap":false},"4.0.1-rc.15":{"name":"ts-pattern","version":"4.0.1-rc.15","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`__`](#__-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#punion-patterns), [**intersections**](#pintersection-patterns) and [**exclusion**](#pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern@4.0.1-rc.12)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages, which let you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n✅ Full support\n\n⚠️ Partial support, everything works except passing more than 2 patterns to `.with()`\n\n❌ Not supported\n\n# Documentation\n\n#### ⚠️ This is the docs for **TS-Pattern v4**. Find the docs for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P, __ } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(__, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is inferred as { status: 'loading' }\n    // `event` is inferred as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `__` wildcard\n\n`__` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(__, () => state)\n\n  // You could also use it inside your pattern:\n  .with([__, __], () => state)\n\n  // at any level:\n  .with([__, { type: __ }], () => state)\n\n```\n\nYou can also use `P.any`, which is an alias to `__`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(__, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n## Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `__` wildcard\n\nThe `__` pattern will match any value.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(__, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\nYou can also use `P.any` which is an alias to `__`.\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, __ } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([__, '+', __], ([x, , y]) => x + y)\n  .with([__, '-', __], ([x, , y]) => x - y)\n  .with([__, '*', __], ([x, , y]) => x * y)\n  .with(['-', __], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(__, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: __ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"12103f67c91c01f47241d9412d269b36dfe46632","_id":"ts-pattern@4.0.1-rc.15","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-jFuWD2xjvdFCR4OdckfDB/pOYzro25waba274wqBIOp9dmTmHN8aXg+jFryLfhvbbxixwHdg1tT6TC5RK1UQkA==","shasum":"5fa3ea726869aa9089856c85f5e7bffc2360f436","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.15.tgz","fileCount":27,"unpackedSize":219698,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiOQDPACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqWog/8CKz7Ap2Njd7PB1iRrfjVAI0Loc6wq7o9lhg3YcBIWpNwlvxl\r\nrM/6yN8C+rH0c6s38uFbuxNKM4mTScPv0Mf0sRdozauYrOg8zE/fwAfj/KOn\r\nms8co9nt+XFfITN9p8DtMSDk+e/GW0ggwjQffdYB4tBn0sRZGFCTbiNbBtC5\r\n3b7kFTzzG6CbRFctVZ9mSN1j03eRST6CBDSm+54BfkDJR3GIc94uPZzCU1aq\r\nZgbsEsy/WuaRS6vsKh/hzYsp14AqWl2JOC9HKNiHszXC5WWE3Ed8Eck9ud4D\r\nQnM+KL+aYuIoF2dR5T8rCtWTznw8/3fTB+JIoyP1aqqjKQwS3P/HAs79S+SN\r\nDaUqq68gkG5zOH24AFMWb1iW9NjfK1or8ydj5bHKxDxmYvRIejk/++mz3YCe\r\nvLtP5gR+ixkZ/EClJAXquYCWdx17qTiFuWR6r1kTwVpCqLcRtzkczOhSAdNY\r\n4YTUvzNmuGdziknATkUEh4d6yhnDpzXYHes7a5hnrbKewwdIQfyOvPlySlqs\r\nEfpB1Uj8GCTHuHp106aeL61dCXrtWKKSXm7ylPnSDWdPHJNZdKZim4Uv1gNY\r\ng9BcrY9T5i3ZqKHTITVdaXdQtAWUyqY33p1Ee26k3R/1lAJ+i2gs+2snilFy\r\nKGPTU2QwagGd039R4jRqqVYchMFX1cazbpc=\r\n=/Dnj\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDyelhg/8QvsbQKcdBRbhivPEmqMw7r5Mqe+Q1q0fZNugIgdSP5dJDPeB6gNPg5inupAzQ/v4ACMLTgJiYe4WaLteE="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.15_1647902927206_0.9649356847447284"},"_hasShrinkwrap":false},"4.0.1-rc.16":{"name":"ts-pattern","version":"4.0.1-rc.16","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"readme":"<h1 align=\"center\">ts-pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads per month\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, (res) => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Works on **any data structure**: nested objects, arrays, tuples, Sets, Maps and all primitive types.\n- **Typesafe**, with helpful type inference.\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#punion-patterns), [**intersections**](#pintersection-patterns) and [**exclusion**](#pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern@4.0.1-rc.12)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages, which let you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n#### ⚠️ This is the docs for **TS-Pattern v4**. Find the docs for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n- [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with([{ status: 'loading' }, { type: 'success' }], ([, event]) => ({\n      status: 'success',\n      data: event.data,\n    }))\n\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n\n    .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n      status: 'loading',\n      startTime: Date.now(),\n    }))\n\n    .with(\n      [\n        { status: 'loading', startTime: P.when((t) => t + 2000 < Date.now()) },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n\n    .with(P._, () => state)\n\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with([{ status: 'loading' }, { type: 'success' }], ([state, event]) => ({\n    // `state` is inferred as { status: 'loading' }\n    // `event` is inferred as { type: 'success', data: string }\n    status: 'success',\n    data: event.data,\n  }))\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` let you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'error', error: P.select() }],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [{ status: 'success', data: P.select('prevData') }, { type: 'error', error: P.select('err') }],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with([{ status: P.not('loading') }, { type: 'fetch' }], () => ({\n    status: 'loading',\n  }))\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' },{ type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value.\nYou can use it at the top level, or inside your pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside your pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\nYou can also use `P.any`, which is an alias to `P._`.\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nObviously, it also works with more complex patterns than strings. Exhaustive matching also works as you would expect.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (value: TInput, selections: Selections<TInput>) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>[],\n  when: (value: TInput) => unknown,\n  handler: (\n    [selection: Selection<TInput>, ]\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nExecutes the match case, return its result, and enable exhaustive pattern matching, making sure at compile time that all possible cases are handled.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nExecutes the match case and return its result.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\nType guard function to check if a value is matching a pattern or not.\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether or not the value matches the pattern.\n  - if the only argument given to the function is the pattern, then `isMatching` will return a **type guard function** taking a value and returning a boolean telling us whether or not the value matches the pattern.\n\n## Patterns\n\nPatterns are values matching one of the possible shapes of your input. They can\nbe literal values, data structures, wildcards, or special functions like `not`,\n`when` and `select`.\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you have no constraints\non the shape of your pattern, you can put whatever you want. In your handler, your\nvalue will take the type described by your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like number, string, boolean, bigint, null, undefined, and symbol.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\nYou can also use `P.any` which is an alias to `P._`.\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nYou will **not often need this wildcard** as ordinarily `null` and `undefined`\nare their own wildcards.\n\nHowever, sometimes `null` and `undefined` appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | string | boolean | null | undefined>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nA pattern can be an object with sub-pattern properties. In order to match,\nthe input must be an object with all properties defined on the pattern object\nand each property must match its sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern match on tuples\nwith a tuple pattern, matching your value in length and shape.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on an array of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and returns a pattern which will match if all\nelements in the input array, match the sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nSimilarly to array patterns, set patterns have a different meaning\nif they contain a single sub-pattern or several of them:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nMap patterns are similar to object patterns. They match if each\nkeyed sub-pattern match the input value for the same key.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\nthe `P.when` function enables you to test the input with a custom guard function.\nThe pattern will match only if all `P.when` functions return a truthy value.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\nThe `P.not` function enables you to match on everything **but** a specific value.\nit's a function taking a pattern and returning its opposite:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\nThe `P.select` function enables us to pick a piece of our input data structure\nand inject it in our handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` let you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` let you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` let you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### type inference\n\n`ts-pattern` heavily relies on TypeScript's type system to automatically infer the precise type of your input value based on your pattern. Here are a few examples showing how the input type would be narrowed using various patterns:\n\n```ts\ntype Input = { type: string } | string;\n\nmatch<Input, 'ok'>({ type: 'hello' })\n  .with(P._, (value) => 'ok') // value: Input\n  .with(P.string, (value) => 'ok') // value: string\n  .with(\n    P.when((value) => true),\n    (value) => 'ok' // value: Input\n  )\n  .with(\n    P.when((value): value is string => true),\n    (value) => 'ok' // value: string\n  )\n  .with(P.not('hello'), (value) => 'ok') // value: Input\n  .with(P.not(P.string), (value) => 'ok') // value: { type: string }\n  .with(P.not({ type: P.string }), (value) => 'ok') // value: string\n  .with(P.not(P.when(() => true)), (value) => 'ok') // value: Input\n  .with({ type: P._ }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.string }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.when(() => true) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not('hello' as const) }, (value) => 'ok') // value: { type: string }\n  .with({ type: P.not(P.string) }, (value) => 'ok') // value: never\n  .with({ type: P.not(P.when(() => true)) }, (value) => 'ok') // value: { type: string }\n  .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"34769520d8b83d672fa7a0fada5a2331ca6577be","_id":"ts-pattern@4.0.1-rc.16","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-7eHPNpi/vTiMKlPqDE2EPrHI54pRuyaPWwLtaWmuEgBNA3ips2VRVE3WthihtXvsguZpBuDx4+sAAzehHixyqA==","shasum":"72ca520612b395b1723cabf692f2597af8fee37e","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1-rc.16.tgz","fileCount":27,"unpackedSize":219151,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPYVhACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoVvQ//dQTTaBxG3hq4H/bO5/OsESjO+ibj/AWMHVULruAqCKZUi5My\r\n+gB8qvtB17+ItLHw19bWjIskUPXVRoP/oIQZPiqdN3TznRZ038wgTy6d3VHA\r\nnt/gT2NoruR7qlYVZrVXMKrrXYZuuG+Ed542aqvamOnc3eo2MAK/gCsMwG0b\r\nJedhvFZXWKlKk6RqjAstb+TDU0pBmOo8/A661S2C0EdTTwcS4Ur5VhGr9UEe\r\nC65SYwTpVvpihBNEd9j2WL+3/hhXh3hekaxouvZRpCXias9ZPYWSMM3aVxUu\r\nu6dtjrqqBl6jxDQHsZ/7kLDwqf7s5qnSG29PKhETxnOtzs6dgpYTZnp6Whu/\r\nflBGbTJQgZAAv+4UGkHuHChIGImz5R5d/NY4JlsnGcu5WkUZcJk7shiNJ7//\r\nWf+LhIFXwCnYl5ynPGdBI9ugsNgfg0x3drS5/b6gkj9kl4Q9poW03Vg6ral5\r\nJ144ht9QOCyOhqRZu/bnuymeU/PnunPbHNq35FiGertw8za3Zq9jnqXRSuEI\r\ncrNCJbW9XhXyFTPig/ylfNJYhixsrA51hhFCScDOfTmoS5z/tjddQx+c9PKg\r\n7oFQBfQAAu1a1hdH3dq2JzFleLevJQ390QHpjEP9oQhyy8YAtFn2ZtSSlSmO\r\nFrj2Dkz4FYX9IhB79fK0UCJtFEp/YyWvTGo=\r\n=y9bN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD+HlE7+evFeYis6NeaXgVRHWbt6zAwbIJvItcJl3B6HAIgMZVXdrMt5w4HsUBD98MHrWHuOQgAKR4p/iHQOQMdHMg="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1-rc.16_1648199009180_0.09545288922681738"},"_hasShrinkwrap":false},"4.0.1":{"name":"ts-pattern","version":"4.0.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"gitHead":"1faf75ddb61543247421f97624134866ecb110b7","_id":"ts-pattern@4.0.1","_nodeVersion":"16.9.1","_npmVersion":"7.23.0","dist":{"integrity":"sha512-UaEFiG0xvCAa0tXBi242rD2WU28RlurzQe27t7vc2+3difhtA58Q6BiFl3YQbDlDiWfantdP05YICJPpGo/ulg==","shasum":"3b395d6be7112a542d79443c2f577bd89bdba24e","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.1.tgz","fileCount":27,"unpackedSize":231492,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiPu9xACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoOXQ/+N2xsgiLPnFltfrJrWXiHh4HkdfoBEIdiT2HTUE4ShlaFeOVk\r\nH1Ttxkl1QwzytCoY12YCJORk4YnFBZl+5IRawRoK/uDG/DTNs8z8sqTIAm4z\r\nUCLUVZV5+TJusUygm3D6X7evAmlcsjrjoP8GzxEPJ/TOzmAeqjyjKdyygyD7\r\nen9AbrGunbdyRqcScNUhhzypzc3TxILvQJ0YTPHiFOB4vncNGFsfUgL2B0I7\r\nCw/m+GWXIZ9TUsxG2g6RnKIZhKVRsQVfaylMo3jY0Aq/xPA4FVPn3tLxyIGC\r\n/ooN0oEE11zq8fMkbct4wuCe46mSMRn946LaFpAwnxka3PKe2mK90mHUihGQ\r\nmq3mX83TGpr9SqhnOiytDImTLuWZMHmvRNKX27zFkAQlZRzobAVCeH7xYcYM\r\nxlwo2Vr4kI2H6C7yhf6XJw4y21PruRXrh1awycGXCto/mSdWSqxMAPq1eoRa\r\nqt8ELulZjI7R7jUN66175GrlrWggi9+VL18JxnjRMH3/aIgUS7bPw4xADu8R\r\nhzeLspS/hsOJOKZtiyjeVSOfu7ZH1aq0HsSDHFAcgz2YpzdoCSJJ+0bIax3V\r\nxYg7X3J40T86v3tXxHmWptXLJL6zTSxUILLeCkPhDwKbB9dhMnNiE+iTNo/8\r\n8msxTeBtwtKucRcrg7Sep29BxB6ebwzYbfE=\r\n=q+hX\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCrc1Cz1ODLFePo2XGlRnBjXweBzPZhx6B+UILzJWO/agIhALoemF44ZeZSlPm0GA0+ji6WFSPT8Wg5yX2cec51AZTW"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.1_1648291697754_0.03573319861883428"},"_hasShrinkwrap":false},"4.0.2":{"name":"ts-pattern","version":"4.0.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"require":"./dist/index.cjs","default":"./dist/index.modern.js"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.14.2","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.5.4"},"gitHead":"8d82f40838b0bfb573906fb28bbd49b3f15bb936","_id":"ts-pattern@4.0.2","_nodeVersion":"17.6.0","_npmVersion":"8.5.1","dist":{"integrity":"sha512-eHqR/7A6fcw05vCOfnL6RwgGJbVi9G/YHTdYdjYmElhDdJ1SMn7pWs+6+YuxygaFwQS/g+cIDlu+UD8IVpur1A==","shasum":"b36afdb2de1ec0224539dcb7cea3a57c41453b9f","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.2.tgz","fileCount":27,"unpackedSize":243097,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDoAreiT/J/pdbxlpWBj14SUJFptIMLJvWXwk9uk59yAwIhAOHSJlxdXyRnFUIyhkZu8k92hviglle/ADgz7MN5CERI"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiXEn+ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrMUA/8C+ceaIXIklXmSTvEVAcPhtzo+D2wu7CyPf4oJvVKfhcRvyP6\r\nY+SWL7OW6V/lmNuGGCN8rHjhtKNl9sos0BkWEX27nkDDv9WlTa0YmIFvnzHz\r\nugXw83VP3Y0xMzuohUbYMDn1hArajHLW83R/FI27XLnFJeZDj8lL5h84SqCR\r\nURqgjMgvgXyarp5O9EP0gIxyUi28hEV2j+zAMkCX0kQCdsAepHXVeLElecRO\r\ng+VeyqJz8EcaVCXYxFjvbESe03ynq1ZzQV3R+iR3niA3d1suTHyk0EtRrC2d\r\nvB0hRSXv9PzSdxM6tPP7dfJHCSLyhX1mbtqRLKejsfUuIxNVDK8XTEu37mYA\r\nkctLkSBZSIhabhdQR2HHQGdjzMjKyEhtHcNR08gq/8NHZmKVoaC2cZFXOQP9\r\n/V5O9eijgdGWOtEjVnBFzhUEyQa9vfaajVckCuv/FlDggxhRI+FJq8Nlf1Yg\r\nJqigKgesijjIVsLkqD2joaGetYWmZVpegikOktF4thRJkYaEIdZXqemYsuI/\r\n94g05O9M3Fh3PqQuncyi3eyhFJxfRcc6LXE71uM4eWes3u/U+r8/M79ys2Z0\r\nYTs8SX9k2qpAIiPFtqvagnSIWYq7APjQhsGiNYuDikT63U2sK4EZcOpVh/nS\r\nHAL2B+ajcuSafJLFZxgG1J8ZvkdtEE/Psow=\r\n=iouJ\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.2_1650215421969_0.5850174389776566"},"_hasShrinkwrap":false},"4.0.3-rc.0":{"name":"ts-pattern","version":"4.0.3-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.7.2"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.6kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\nPattern Matching is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n#### ⚠️ This is the docs for **TS-Pattern v4**. Find the docs for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"dd1b6d596d83426ec7d39b4cbf166d4e6fc64979","_id":"ts-pattern@4.0.3-rc.0","_nodeVersion":"18.3.0","_npmVersion":"8.11.0","dist":{"integrity":"sha512-JnhR/em1K6j53id9/d1+ntt3qnipcj5YQjiXFhJpbPdKC2XdbcvB5+DELOBdpGjLuYFQwl79EfuA7BfDDN2vZw==","shasum":"6879c34724ee54c9c499cc830b9c6fa82f9c5e0c","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.3-rc.0.tgz","fileCount":27,"unpackedSize":242879,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBQEt49noN7tWO/M+E15MrjMKcp8hHq+paCgPC4qM5H7AiBxYAK5lmXe7lbQj1t5sADStEGDMzFlw7p4/qJE2rqhwQ=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJinwd5ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqhGg/8DgotvptinHD1wPSkC63dJ5QH3SAS12Dmx37N6Xjz+jKQM7bU\r\nGYapUCDFiZ3qQOlIk6GVg0i6AyaLqoGIMrwlg0Sr9+18G9qAXAq+h4eUccZJ\r\nQtFyBg3zl8j1jo2aom5blMLlrmkp+YHz3uWdKkY19Wr/Iyjro5Nkzfd0JFz9\r\nT8LfKdg1iDSkkL7/xUFA+Vc3Ha1fN7Bi2djUrHi8hN1xsCGfDVWsgtV3JEA1\r\npxNlFXAG69tcmqkUgDRBbYThoduaYORNmCeHpr51sC4cmmpZJ5+TQluhiKEp\r\n0sSYpjnPdBAMux0VoW/3sfjKbbakpu71np2yf8G48lQlGVlkoXRVXd7A/8s0\r\nVR4T7ggWhEM6xUxYdi7xXY37c9CTqna5NB3dk0nyDPfQvE/wpV9AwRLXlPFi\r\nZclI290manyAgr1XkVhsymHJhd+2XstuEXRkea3IJ4Zt2M9ltxMljdXpH5bC\r\nUmw8qpD3yhLBNHsndbANKwHwOy6shOtA5Mx95dMy8K4WAxK5sjPHPjnCzAoA\r\nu0ReTGAD+qCjTYYosj5Ml+3QgbHoi/3hexxItm1Of1EFUxFDJ4SF0cB4Jqyn\r\n90M9EmsftOdJCzOfZeVzOmBQi2qnjhmrUjyPSmfVXzamkzaHUcVPylJUaOeq\r\nZ4ChfAtjXleuOH8Q07hyEBDElZZ9B/OFdGc=\r\n=8HR5\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.3-rc.0_1654589305322_0.9293427210955005"},"_hasShrinkwrap":false},"4.0.3":{"name":"ts-pattern","version":"4.0.3","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.7.2"},"gitHead":"23faa16032d4bb918ac92a1891e1477eb9425c8d","_id":"ts-pattern@4.0.3","_nodeVersion":"18.3.0","_npmVersion":"8.11.0","dist":{"integrity":"sha512-OxQStbr1MKcYYz3YaXsFSBkMo3zjFODVkV8kaLfOak+sWSfx4B+jkOm/VoaWLhnMP+icnIcJ7ENYEnmpAv3jLg==","shasum":"4b5a08ff61fcd5a9bbfe3c1e686c35420ef87bda","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.3.tgz","fileCount":27,"unpackedSize":242874,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIC7zmfhe6B7fyhFWbkv6trUx3FNSvYTvIe6DLoK2ObxmAiEAyA1QrVyVhMJPH0ckkaipUcm7g2Z/tbvLcuypeEuyQCc="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJinwp8ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrO8Q//fZ4DmMJTmjlljLnOia8yNv5aGVFMhQilpsTH0BxSAWkgNZ/5\r\noNqBI5V/gwCj45sCt8u1i81ZegVq+9EVGF+k8sYX44Bg7tedsPFr+PsKMaqC\r\nYXr9cTtXEAyVeR8qu6Wv1Y5oVSZJYNDC3azyI6/W9Jr+hb926tZCXOpw4teV\r\nh0D+6UlseRqp8NBy7WRqg1zaxP9VBe/YrPgEwImlCLSk8VvtaEB6cc6Z3qFq\r\nc91P+LHH2fl9yVVCInzz93i0mByl2VVUXQgPwkffDSF6KgTPqRI1AANzdIVY\r\nyYAMI97JOYNLVbpkWLWwliErDw+E+iTD00oG9ah32Dhbr6DmBnCproQNxYRr\r\njgqTH7XGz0tt60RAj0Kw5qAe4PJ7cY6Cv3EXGnk9cDpoIh5YF+67Rlntt5WM\r\nT8A8bGtn+PeU/sWEk4VbIV2b1mD00vKrRjv/JO6MHN1O7jLWP9fb6BrxzRge\r\nAE8WmkO4MIIrKbtA0lcgKSVfMeXTFefa7YolQ3l7VrcbaeFI5RlVeDwEb3DJ\r\nJBYsIBkfCQ5+QNWohrei/wauaxD+47S1McN+SbMW8l3ZRplAouQ4rEsD6I2j\r\nXqnAABn/LoUnFx4Xmod/fx7VCNv8EtlIsV7goSsIPHYdnb+3wZRFDfOon3LI\r\n5YaE54QZFwETBwiyPkfT/2uhpA7k9LBqAek=\r\n=qvp5\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.3_1654590076682_0.7963041084965652"},"_hasShrinkwrap":false},"4.0.4":{"name":"ts-pattern","version":"4.0.4","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.7.2"},"gitHead":"f837a386e2fe9fc3c94304161dacd5e256710a63","_id":"ts-pattern@4.0.4","_nodeVersion":"18.3.0","_npmVersion":"8.11.0","dist":{"integrity":"sha512-gDKHf3T+4X2w5k5IpD4FQ6P5b0LRYW7sJdf/yG7uAdxKitgk2Z8UZLdSBjrXs5mI0Vq6E/hRQd6+Kh3FbdjBzw==","shasum":"95bae7be40851628f93c6fd647cb0183c27c23a7","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.4.tgz","fileCount":27,"unpackedSize":244463,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC695Afv0PBz1tammDpcWkGkCEncLS9/SUHCHRwA+Zd0wIgZFhlJgmw+QVa0RVUb3CPKKml6yWeUIFbt7RguKPcXdQ="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJixYxhACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo7wQ/8C87MPw5NcMvY3zIS4RCcaltoqSyDrgHPmWWM3HKcNVhYkb75\r\nrEg3n2syU+n24UtdavfgCchTZ7qjcr6N6m9IUt/WzHxLPYUPj51XfIsx2AKt\r\nD1/oO+a9Kp/mkxkk1d+qR7EKlpHdmdY+/HJOzWKZ7IcSZHdHom9Yo0Y+zKkP\r\n6l0d5w4vREkEwNX3gPuqYNpBb92BdN2yhV8hapn9NxRBUFjutYdut7aZD5iW\r\nsgsMSNcbIZsL8jAOsbUiqY+DXNVWpnxusJ6on9L8G0cw2NHjMVrLMuOg0423\r\nhT41Bd0Co9IQGb5u5YNrkjGKe9ZRw/MbVYgjlLh01OM0Y5m5hJMJt37KoHxU\r\ndC9KQ0QcMy2t1aL841QHOXlEg71r6EROXaD4alaMHGeioKhUMBI5L1t+rcva\r\nJ5MqFdOEjQ5RnAKapPwZvDkguQnRLEPG3Tc1YztT1HC0SSpFHGfCB0+dmWgx\r\nFK1caIOQs28LQ2+flKUKvM8USIJi1lvoofM3ed+mwHVgZBxfaKHwXXopYa2E\r\nrgWAQqPPlk7IAUCwKd/i3x3jCogKTSyu1l/OXZ1iwvDIafCSaLjeBGqUBM3Z\r\ncyVl6SP4f+juV2fF3TwprYIsL6fk8JCaMZT05AApnnxscDU+l6ZhtJD0fL2N\r\nS28O5Zn/Qb8EpwDJwrgWeXpaP236r2CkBeQ=\r\n=EREg\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.4_1657113697439_0.48557737733701"},"_hasShrinkwrap":false},"4.0.5":{"name":"ts-pattern","version":"4.0.5","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"./package.json":"./package.json",".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.7.2"},"gitHead":"8d2e1702bb98afa3dc7bd42fbc40abee4072cb47","_id":"ts-pattern@4.0.5","_nodeVersion":"18.3.0","_npmVersion":"8.11.0","dist":{"integrity":"sha512-Bq44KCEt7JVaNLa148mBCJkcQf4l7jtLEBDuDdeuLynWDA+1a60P4D0rMkqSM9mOKLQbIWUddE9h3XKyKwBeqA==","shasum":"8e87db265b890ddb0dfc10deda36568296ebd5c3","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.5.tgz","fileCount":27,"unpackedSize":244503,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCP/F/0Qrwz1TtGZFb8nYjw/A9etWiuCRKXU/765v8HVwIhAI9xvHmaXfLw0Vje4c5j0Ar0jUBxD8p41m+VDQ5b8dKx"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJizpUcACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr25A/9GIAUE7HWHp/jxD3VdZjhnOocYl0A6xEpIwBq6W5hZVfVNrze\r\nL5WDPitLq0QTJy+gEhcNli5ePWbl998PdXA3lHRSYy/3ZQi6ycaLByt3v1Iw\r\ni+IPib51cseWv8e/UjZcJ6c+RD6ERvFDJnAi9VbeeK8+dFpj5Wb0QIPCbs+t\r\nlgk1RFlnfmx4ibO3fwBiHDI+F5nemAowkYj05FmX5cFMD+DC4qeYtSEXSlaX\r\n5EfDyvG4omZHxZDv+qZrdlqddjacAbrEPkqYlUfqyLrDJx50D7GP8Apq/eLu\r\nRSp7t/rRAstyXtr7R5f8mjcUO9FS3UfuONIqf4pLGUevmRWNgo9E1bRGIUvN\r\nM23SUtmSbJ/QQtoy0M7XGQYl6TnmFahtW7ykWmbSsOBgnD0K2gu9FQP+kmDY\r\n1Je2DExN2x7IEvx0kXvPCl6V34z3MX/oZuTBEmYhzqEzQ9z4GSEaLmO1qrPu\r\nFc0Bd856kd+bnNcTeqq8ChHjWnv4CtheTDDLeq5BL393XefTthkVUaJxM3Kj\r\nPisbdYv+3U5KQ4Y2EPxMUlUq4kEj+SXeWpnn2Eps59QQtiWgQJWzXn314oQ4\r\nvLpzItV6Q/qAq9ItWW9V5027bvULyFJyi0diCDeLGTcLdDqxox97VNfbWafo\r\nsWXBmRosTz9r4DD7szt0Qg61qcthKE3MWRQ=\r\n=nA2m\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@hetic.net"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.5_1657705756377_0.5905227468848051"},"_hasShrinkwrap":false},"4.0.6-rc.0":{"name":"ts-pattern","version":"4.0.6-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"./src/index.ts","exports":{"./package.json":"./package.json",".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.mjs"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"./dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n#### ⚠️ This is the docs for **TS-Pattern v4**. Find the docs for [**TS-Pattern v3 here**](https://github.com/gvergnaud/ts-pattern/tree/v3).\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"d631a15df79322503ad0db4fa1237d0a2bef7e30","_id":"ts-pattern@4.0.6-rc.0","_nodeVersion":"18.7.0","_npmVersion":"8.15.0","dist":{"integrity":"sha512-dEZPlZU9wfEX4ctZus6p/VpmOIEbVpuKlndXceHcBha2LxzboRXp7Pdo7b0IFxmKvKuatV8WyisL5VdM3wv/BA==","shasum":"af7ee4ce6b8eac5f1cda41c7e20fe2081bda8955","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.6-rc.0.tgz","fileCount":27,"unpackedSize":246037,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBwMf3vpq5qs9SqXXNzkQqFLthWbVdGMPOk5fC1pd910AiB32flom48I0pvASbgFfkB3Pcc/FSEP1Xsp7R9JNf+QoA=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjIxY+ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqPxg//XXVdFnSSVwNJRB9oGPRQueslpUpfuUv/vSHgPc2yPN6IrLJ3\r\nL5lapaRsxxfZAIZ2OPhnp/AqBgXyYIAjUrVbBN8rkwzXjvcoypaKYYQND2yH\r\nc6HTOlwRfDaYYYvNgQ9s6uRPEbxs5re951CsoLnHUGa+cGVl/cj+IA3Fnyob\r\nVvzswYTLzVsCTGRk9bPrdFGbLxSrD/Vywzj7hHDL8urZQSatK0lTc8gfC9yn\r\nybChh/k1dSvpiZsrOUBd68bdyU0uDqDfJ0QzJ9CR50OW2v3bKWjcDh87H7hn\r\nS7O+PzUzhRdBMZWquD3r7ZGwJ9kM+6TbAi6dca3dx1neKPeLbk3HHqPVzdft\r\nAG5Kh0DO7acy1HI6tEieq/HfDXMWfTe5We+/2+NkuGfT7QEcbGwRQEbXkUr3\r\nGr8Sf98QmhAB1NyiULFkiTlgs5bixorFaWoofsJSi7bDCNm2mop9dx4mjeNy\r\nmag0O2xXzguAIbabvuUdDIOwzVDJ50ioVR//dTi1zftxhQ6DcN/yRWzKyz0i\r\nN+u2Rf6hIbkQYXWN0W7AoLohMJfX2RBvM/zVhiumFXwhl1Xc79UKQx7b6ZTe\r\nOnzi/S8xObwh+d39QMqvbpi6jGMvs/vxHT/KlPr/ljnAOJDEZzbdp7c64g4l\r\nrQbD3GzoeHi5pDC0K7C01vpZh1yig0fnFKE=\r\n=x6I0\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.6-rc.0_1663243837839_0.9081354490558524"},"_hasShrinkwrap":false},"4.0.6":{"name":"ts-pattern","version":"4.0.6","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"./package.json":"./package.json",".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"237282ccd0d97e02a1e0609599b28bcfcddfd8b0","_id":"ts-pattern@4.0.6","_nodeVersion":"18.12.1","_npmVersion":"9.1.1","dist":{"integrity":"sha512-sFHQYD4KoysBi7e7a2mzDPvRBeqA4w+vEyRE+P5MU9VLq8eEYxgKCgD9RNEAT+itGRWUTYN+hry94GDPLb1/Yw==","shasum":"02b17695f6385fcc6d2f3ba7962b0952f709d348","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.0.6.tgz","fileCount":27,"unpackedSize":246241,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBcZ/zxcAwtCrU7XYOE7o+uru0ZzXaMwC4KxnhvuIHJ+AiEAzE6Oe9OO3cuJJ0i/mY3UZVnnORumPqme74AHWYRM1yg="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjchSXACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqLxg//Q4SMKmfNwttGxApWSa9i67A7afWzev7uOgvGBVI6/RoMquuZ\r\nEnbQ2UAdQk6TmA1y0UQd2IMMi8+gtrjIoHAqX6/pkZ0pYWOBwUjKw/hcMAeu\r\nSl3a1/WZv8vUkFOQGrLYH5mDpowrGB3wLv2FAZC238GRXft5eq4PnCm4cceE\r\npqOi3FvK7s1+Xz9324jcQK3Gg+trh+UHINsiiG/hisdR0OzT6vAmDB/Z1rxj\r\nAfKvTcjbpaxubTZquHZ3XVgfi8NDLZCG9VKwMwlbGLVqgW96bZpunY9jITu5\r\ngVJJ+LbNKinhdiygYDLZzFa37Ue07KU51Re5NYr1okRH2w8y0XsONK+XenEu\r\noTnqg6PsNwZ5sHUVjaKX7PA/W5y7H/z5sVwV+xvssXzUGm8ADuSR4s5Mquqj\r\nq2JRbBx9mSPw5Qylk23A4uoXDmNlxp1FBcxEGOnTCl9wOAsbPxCvBeNDH/kq\r\nX72QcDiwqSIxf+WAw97EgcRqKuF0AMwUed9g5r7WNbuXtRS07pJ6hs0vMqlC\r\n8k3/puclABCQe7gStPK+z4pplhSXj6SpIQ+IIPDOaSX1lNZaxCtgwDyfy/md\r\nM0E1ZaQ/yw9XsIAkorbMplIkq0nXoPvzl0gnE4+JTkOAyQ13p1vSJX5V/+/H\r\n9vzpT9+ReFtD/eDxJ5BahvP88w6P0FHDsoA=\r\n=DGUD\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.0.6_1668420759340_0.9711986935252999"},"_hasShrinkwrap":false},"4.1.0":{"name":"ts-pattern","version":"4.1.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"./package.json":"./package.json",".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"5a025f496cc4141a7285f414ee182372ea7f2c31","_id":"ts-pattern@4.1.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-AKvkyz2Ygq+eIxMQkkV4cv4Zx60bazUKUjasMMLvH4hQ5PVxMWFHa3uy2EBbVy5up/+0pEnvz+a0Uzs2pVSR/w==","shasum":"f6a426f681596613ea7700e06dc443bedbe158b1","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.1.0.tgz","fileCount":29,"unpackedSize":287193,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICRzraHJPndt5pJDmJ4xBomiRlPFZjle7TaZh89hn2MrAiEAwadxFxVW55mQ8xolh6EaCu64xdjlohlDFiHFpCMBkyc="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjuzRrACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqzHg//SY9GWPMO8d29nDRqcWHHB1pNyeQPkEHrmF5eZMwBqth4gsmb\r\nST9d61XVsqP1B+CLVDLm/Ppkb88CVG7I5GeDrIG//ouINwd52f2+8w/JM3Aw\r\npObGs1njJAwZCUpD5t34lmMG8JfAmSi3z+hQ1I+kxT4qqoCz2jvtUV8+TgX/\r\n3wZN1HWXONSk7od2+xgIV/43lMPbEZh0noVGGc/SFXyvX+WRPG2ec8yBsTEi\r\n45yP/NEoabGQdPD52E5g0+OrNBUZeLkaZzEIpYPdxjvTYavSZmowSPOFzOyx\r\nnnfmpLqLr+Jc33cWTn4V/UEZKIsG38b5Glb3tf0nMIuhPFaWbbQcQ+lQ3oM/\r\ns5iItoE2SHw+6imu56vnw1X4EzLzv+aSUqjOITjQbq1kBLbbpbVrleNPAzA1\r\nRBpI9QeymLKmD3oclHOq5ulG9rSa8RNIRjxKraPGn39ZtLhwQlydpdnwZpI7\r\nTCp21wBD8ofbg4fIuX5l/KIhRXDdmGIn7JJk/RBCOgsfTpEsSntD+VEPprqI\r\nAOKa55aklw/YXyd+aBrpgAwqsqstR+GnK4gdD6EMSLNit8IZ2RH0HvN2CyfQ\r\nHy6g7+6iVtnBuijwY+//5SceMXtkpAKJ7atNgOJDtQABF4D3QfLMaxo7a8Af\r\nw3FWLHdot2C089uozJyz1MobfKLuBeolHuE=\r\n=xw0B\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.1.0_1673213035311_0.21453528261018806"},"_hasShrinkwrap":false},"4.1.1":{"name":"ts-pattern","version":"4.1.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{"./package.json":"./package.json",".":{"import":{"types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"require":{"types":"./dist/index.d.ts","default":"./dist/index.cjs"}}},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"53b4582aa8218be84901497ba75d494d90c7c138","_id":"ts-pattern@4.1.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-fLMhPEixNmQieJ0BeWUy4eg90Vn4ECRQxl0LGuU7NE1LUVCsZlb0IFWcBWwAw6WA/YeY5RShY82bZCLbI+Zf3w==","shasum":"272efda0c3ddb4419ec939bbd227aa5cc306048d","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.1.1.tgz","fileCount":29,"unpackedSize":287190,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICJ6iXvopW3S4hctwM6w3ctkim5d8PRYjc+A2syO7bNxAiEAnbpqO9zz8ENW7NA/kXI4+GNvZPpJkjp2JIYieDRYtMQ="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjuz4tACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqDRw//Zwu+CU582l0m5u1kd5y1Ficu52nxHC7WUFpW6kPQ1pei1ufG\r\nuvKkK9JpIdFsBU369FU1BKcNC5AyPezCkd3IDFS2TUZ800L+QlzeFnOW46wq\r\ncbQCL+unIYRpzR8uz/Tqbw2R3BB9ZYmNCei1IjW2UQsS69n2yAQBZjaH92+G\r\n7+qhnxkhCqR9pCfgUw9XhRIVdy/jOT4AJTH4qmB7/vjfth50kT832sS7Azm5\r\nSgsiQLvYCHFz4B3IFicYHfWjr4PEcHjUJbA6BDa80phP/XhYm3tEHpDtYqr8\r\nGdWJXTpB0j3TKoSmD1dt19ukC5+QWKPClvrJSwzNO2hGKUviebU3zZI3t+a2\r\ndozlQ2PyFJk4i25pdYTmIsJoRhx8sCCmoHAEZzhxxKHOKdzO4NPYsXd/StK4\r\nyKcM2auaOqNC7XlWesBziRHTC8zMXjzEq3H/KNr0Efs7rRH4WcBWMICFcvWp\r\nvs5wvyTY6uvieqnXQiFU7N6Ck16s/xsRg+k/T2Vq7fm55F2192lpaxskbY3o\r\n98N/NLa0IzWOoRiACER0N2I3RcGHYInpe7AeNnIyTEq2evGhBPsV2UecIeKY\r\n6t7m4hwcJFwYYYIw/4E3EPsrh8wGXak3uhOQSJJmCCMznAJ4fgWZASCjg2ml\r\nCq8o2/C8eqLccymq1wSnPbF7Czqab8Z1x9g=\r\n=dnp7\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.1.1_1673215532850_0.20098081778307475"},"_hasShrinkwrap":false},"4.1.2":{"name":"ts-pattern","version":"4.1.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"9116af6ee255550ea7c8ba0ffe986a09a887fd92","_id":"ts-pattern@4.1.2","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-R/NEQHgeQwiyQyD5++s8rVB6jC1c6KiHHac2GEm0Pf82p3dth7s/kZfSimcUkVLjz+bPJn12721Vw9sbMpY5Rw==","shasum":"27968615b9344735b0b825aab3d5463af9a27cc0","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.1.2.tgz","fileCount":29,"unpackedSize":287137,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICQFLbNl+j8nfYiD4sA3X6+TFipsHQteBFOReX7eWtLaAiEA47XWZIxN5MfMvrj0SbFq4G6YNeQkWeLx5Oy4Rv1RojE="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJju/B3ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqlzA//eyF9zr30beuCKWsyigvcrJaEgwFccnjH0OQkdGnWRVNR6iCl\r\neK1V5YACJhe8EvKEfMEy7fKAsFtiJQ2xoYbUuMBlYM1CxUQ/foowDNrphd7O\r\nJwZig96isOHi9jsRgVKZMk/07sBlF398aIwQfqQnm2ObafZAukjOcx7HGA+f\r\nEmoptMMSYF1+A28EAI6NYEXAxfNrkjfGCmSanx3HTQGN9rmmBgydF2EjuZPf\r\n9XGTy+GLqI4PZrFbfZXqSoUdDd4MBb93nYDmdYD4QcopDh/j3PEVA6tXSFW9\r\nAjC4hNJf1zksGhuPNL1eRMsVym+mAGj0LbUlnXHFcdXNrM/mgLmL86j9aliE\r\n5BuRcmfy7GOQgg8m8UEAeTJCYa15qjcRMPIYf+N10RAf/mkj15o10RFhvrjF\r\nur7VUd0vYUR71L8JKBdckteTxafOx7DMm/+0DMrp+eCRvUt15vsY5OHDmiE2\r\nBhOWaCqSeYctzZT6dTQiIw2bw6XJBZEznofFIBZMDh60ph3RwrcdinDqgq3h\r\nfW86YddSIu6wHS2q9sb1ob53atihU0g1Bt5mcT/NApIxlBH7pMFIq5ccAU4L\r\no6+a9SzdZ0vCZlb6Oniso1m+gKcsJFPSt4Dv40Pcdvf2JqPxi+A8DmgklKz8\r\n8466Ma34NnuyEFAr/R2poH1iYFm6/yms1EE=\r\n=bCVw\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.1.2_1673261175193_0.8101800514508488"},"_hasShrinkwrap":false},"4.1.3":{"name":"ts-pattern","version":"4.1.3","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"2aa12fa7c5aa1dfcbac7bb547453166b6b8f7c26","_id":"ts-pattern@4.1.3","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-8beXMWTGEv1JfDjSxfNhe4uT5jKYdhmEUKzt4gZW9dmHlquq3b+IbEyA7vX9LjBfzHmvKnM4HiomAUCyaW2Pew==","shasum":"8036392a31c42cc3580608024f0a6d298b6438c9","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.1.3.tgz","fileCount":29,"unpackedSize":287155,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCFF3u/33HfgQjOaXVtBj2Lx8MDO+WF4Gj52iiR+WeoKQIgFJ0LQMTmsi+pcf53w+jBnUj4oan8BUEuKRKR1ggTkGs="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjv84yACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr9ew//WUIcKQItTKuyB5HO7vtSvcwOZBWKH3kL54VP/jtM5/J+9c95\r\nzDDE+x/th1M9krGMqWe8J2MhkGSJocDDxatc1NiwbWW8ef6jNG/rApRf886A\r\nAPcNxIGLEZGRqQzZeXSfQDEqrH4WRdOO5+Rm9AJv5tbD2R+I40bab9MWTLRB\r\nC6vhSiop+l29vElzNVySy3MYwwSoeRyyA0LaFh3jdqUhxfzS3vAbhC4OkGs1\r\n8GIQ0GpdMLBTSk1mEP6gr7mcuBvEqtLRQFka6XseG8ZlgWWYIdCBxEqjWK/b\r\n7BbWFE2OuLo6VkVDeYYpGUT57B9fPpaY4wqHRyX7uqLJqfyByjVaFv/hOktz\r\nQ6T+aEJS9H1iBKrYNYvnxWnWehsNm8vCAzx4bJ7UkCH78puck1RTXyA9P5Zj\r\nxCcqRrDawWLrwVTkKn34P8wAPenHUz4bAYPzlk0aNQguQc8DeJCMKn13hvp7\r\n+IfUz1jDMGyBqr3rns1CeePR22192velZI5d6bF7dlsfdWAjcgvkJREI8j7Z\r\nubD3dEAgOdlSBrDIt3Lc46UWq15kJDoh/lppXAVk3VRvZUgBm8eDAzaI7W8H\r\nwDE9txmQ4OQmGH7SU1bFutfxb7q/Dwip6LQaE1+RaTT+eKXPKotSwmxB2K/K\r\nKdWiSV+TET+r2S+dshUwcl3a8s4lrgMkvlI=\r\n=hCa5\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.1.3_1673514546332_0.45102556934246674"},"_hasShrinkwrap":false},"4.1.4-test.0":{"name":"ts-pattern","version":"4.1.4-test.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"types":"./dist/index.d.ts","require":"./dist/index.cjs","import":"./dist/index.module.mjs","default":"./dist/index.modern.mjs"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.mjs","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"693f4f17f3e74c3dec8f5bb679ffc291a33debdd","_id":"ts-pattern@4.1.4-test.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-uKqEumhp7+vIDQMSxy3UDBEocY8GrpGp488IYh6TJWe8fmkTg6cbY1K78jlTaq75JDLHMBk/G4kMQVYUMJ7XHw==","shasum":"853d9e969a45c30072a188a59782c644c3cb0411","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.1.4-test.0.tgz","fileCount":31,"unpackedSize":326593,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCgHawUj2h9SiJA5iGwMBnFCv+kElGA52R18DOA+/UhIAIgJS9myFTV+k/eEJ+O4A2j7+ygjY9DTpDtmAqYKuFF3yU="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjw/IEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqMiw//S6oT22lxdTIl9UeIGKm76Pp1EhRhJQwe50Z0ZyLM08dAHoZL\r\nUuP+px3AzUnpDtwDKOskVIl+XMcL1b2FVJVu3R0WlQ2ve0s1uizS9hwwo08K\r\nUBZlQKx11q8A+egc/Un0oyGQCI6o+ttFPMHffrw53lPTeW/5k0syb2U5CAAc\r\nsdQV9zarIKdYXusawSQksLjtffSuODXO7LunxFNGFajJkyVTwnriNR7/FBvW\r\nuvuV7QICItRMn7MV2LPxyT9FUqcHUCnjjw4omT6YTDUGgJ/J2ImT83pGNiM4\r\nmrGKMHdLcc20Zrt3vbHjuj6Ga0KcTpIlac1jQwPCv2NFgFSRxG1qC3Qtrb2i\r\nAfByjq80Jf/kS5He01vWVBdRIoXC7f7ZzNQwIal+UeMDILZuK1riNHV3GZ14\r\ntfGzVSnHaz0wFNutT7DaLw0Yh2opFA0N4bOVUKdI50icOkBdK8ZOFRCVEf6Z\r\nupGW7A/FR1X/Nm6ApO83IgpE2RSjHfh/w2qkThZx+JF/ZNp+ZuPNamzFDoF1\r\nxdMpZkkvl5OsLipNMilAUFHGxw1V2cNUmAekutHHLJJNUgll/eJerGh7oj4z\r\ntGv+8ZO7+kN3DXqOTaAoZeDNa8vF0JL+oMSQjU3rCjHtwf8I9JaarRpOODvx\r\n1GH+AknBi3a1EJU4q6jLn7MQFf7SgB+xhBw=\r\n=kYU7\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.1.4-test.0_1673785859845_0.041517200173314395"},"_hasShrinkwrap":false},"4.1.4":{"name":"ts-pattern","version":"4.1.4","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"c6bf3e4a64245e49aa9af0bb3f50b811d118fa63","_id":"ts-pattern@4.1.4","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-Mcw65oUd1w5ktKi5BRwrnz16Otwk9iv7P0dKgvbi+A1albCDgnixohSqNLuFwIp5dzxPmTPm0iDQ6p1ZJr9uGw==","shasum":"1125c227cfe627d8559545d6b7884bebfb85723c","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.1.4.tgz","fileCount":31,"unpackedSize":327007,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDd3JP7bOgr/Enn8gOJH9ow1Czry3ufv16Y6eB7r8QcqAIgQEfcDFjtay2K8yGUAp0ShEc4fY0+b9VmPJotsAAvTUc="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj4YlPACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo+6Q//egvCIs+RJtHbovoZqa6H1JW13+ZMG7Rr8FF2WbXR2I0ucT+l\r\nBrzn6sujpQGot1GH8IEgq2gmjSj/nJrlQ4cLl+faZhI4aSxA4olDUs+BSeh0\r\ncnwRFgi9P6av0I4sb//f+XykXBDQeKtvcVGz8JXrZglqzad3VzpaEJfNU6e6\r\nFzzdc3bCN8tsU6reZ6y04LDnU6HdQ/0CJvkX9sMigfYBbVF0rSDpvpC5b5Im\r\nK2eocGyIPZNUjMqzGlBI5zznxNuZvKTOqBuGXydp66Yhv/QMJqU/rLEukBB0\r\nI/Lr1vXmAq3WHGTWizihti6L4HMgYEtv4uMBg9xaISF5YZLK9agZnkIrMXwc\r\nsrda1KDzSzhLqbqJVl0QuM3zgEq1JpAnESeSHN9BBRinh3bTveb3869fOyfr\r\nbIc7Cu4BgEJrrlboe6sFBeba9ruUZ6R8TcFHr8xLg9jm93sN80k9BuEFjz3Q\r\n70Q4LCZO73+W3ITE8EYj+IGMveY7i8vmIR/8gX0vFTN+mmt7W9NN2Y8hTFgQ\r\nvYcee0ofXtR8f8IvGKy7ezyrRnuBnnkfE3sC3I7GE5FfMdmIhd6W6XZ4Xhsw\r\n4j1lwqNEo8OAgPntc4G41Zv7o+iW14hdduEyYk52WIqpls4Uxb0asce1DR7V\r\nW4uHKmvdbB4YtAF/yG2yk1fsg/Nuk17IJXk=\r\n=QjXF\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.1.4_1675725135600_0.2687256797100419"},"_hasShrinkwrap":false},"4.2.0-rc.0":{"name":"ts-pattern","version":"4.2.0-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nreturn match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern v3.0](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"3a7fcbfbbf66b651648c6e7433b4a640f8543b88","_id":"ts-pattern@4.2.0-rc.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-rzRYcfEy83/09gBgh5hHDeIkhB0QmLyjmbbqGm0n78SrgqamsY09gzkp1cRBnrhPgFnk93sBWTC5lJf40DF+yg==","shasum":"09e02588b56c0e31874681bb0abc94ddaddbcb73","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.0-rc.0.tgz","fileCount":31,"unpackedSize":326044,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCBIZNmoDfAlxml6cYiieZVV2B75i1hXzAXkncx8AD9sQIhAMfR1+/bxNahwTlPtjpUAuwjP/XFKDrtM6gTGz4GQMWe"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj8lwCACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrDTBAAlduiYhIYow8Gq4Rgs91jIp9SqOvgAK4Oosd9meG26yNMhhXa\r\n8SiwSwCKGECymCSBF3ty+kYhX0de3S8bRnr9H68XKPDP3qqN6Osl1+HGKjBD\r\n8Fc0tmp3pdDLMqb1WyYaOpkWUDb1YjAV900kYSq+EJlSuIOJruaoGtjWxgY2\r\noYY5iaZQUYbkj8xxLtqTewxlrORw19iBOR9aVyQkR2wW4+UqwU6TwLD/h0zn\r\nVT4QRnJVrx8IbmgJ+NoNpPdePuFwuzx38hLHtZokHQogYxPx5fhYtOiPA70L\r\n6YMZ7ctIa1eeae0D/8m+CsCBuecvGikkaA7d6aP7No9/XM3nQYMBZkCcj5ty\r\nVH5DdUbIdeijXj0Om/7bDgrg2sv7VAeP3j4QEOmS1qS8Rl03M1rlhQaKycbr\r\nyy3bI687WfTwM52x4oB7H6HhuSsu6q1o/YUeJOdwlEXvrWkAqgcjOPH8iPfY\r\n5JDXaxtZo6EosufYpbk1dEa2cv5F3VwS/NGBjYni/jn5WgfKB/ICtaYuAOsQ\r\nsr7zbD7fq0Ij1qcgLp384C1LlupYoMVLX0LYh/4Pmz4ugMw081GNpqFRLRJ+\r\nsYjAF3g6jG7WelXMtmJhCXl0+Rk3Hzm8jXCwMDGVHdF7KDXABd/67R7JGmgx\r\nlrKnr5NnayPoom2bKTBGjRzoiTl8Juequ68=\r\n=DgJ+\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.0-rc.0_1676827649937_0.7197995871460907"},"_hasShrinkwrap":false},"4.2.0":{"name":"ts-pattern","version":"4.2.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"52ba83cf113248c07928c9d9a8c0a09c5afc77d9","_id":"ts-pattern@4.2.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-Bmi5G8KQyTnkcpRYzAwgPj8nvIodm2S7aneJtILrW0/2ZzqXQbl5nC5YjCiZUj5Iqihl8MLH+TK7pmCAZ61xJg==","shasum":"35b8840627619819ce5746dec5ca31c3030f8dcc","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.0.tgz","fileCount":31,"unpackedSize":326951,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIG4wZ+byQkuJ2RVypahN23x1rE8hcC7a4r++6zjlVau5AiBnPDRUPfBJ5qlcHNecMWgWKsXhDRq8/kGvAB4TSKbeXg=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj8l9qACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqPwBAAh1DQKzkMOGZBjiTCymxJCCsYmFEZxQxXm3Cf5UXJgLK/cYRd\r\nq5X0rez9/eAEatHewBMj4vLYDwDK4T+0HPiGjpkKWqlHi0exH4WqrbpLLprB\r\n19mNOgz0+4nVxX6aP4Sml/1oK1cxvqeElAqlvGAlp5Ng5rF8baZ9Z9Q441tJ\r\nTTJy42t1617SnacMDj56IqwqyUE6jvII390Oc8FDUsbAI+AFXrMdd+U58Fm5\r\n0G3eRXTn7BgD/ffj8FAqDskMdEnd92vsq244sVEjKM3VbO2jvrXQE03xav6e\r\nCkfXqzV1r565tKjnZTNQivHRTSSsRzxZQu0lzlgcL87rp24e5PlIKqQE3sM/\r\nHxQvh19Z8rJkSBoKpEqd5bP3VYyGMNycjQSXxTVqqXf49W1y72APY9Tcwds0\r\nXsFOGLDxyq1fQSsk21PKxqpkprxsLQ1Q79OzcTSfZnjBlOPUDBApXR7Evo+R\r\nP1/lza/a6tAUV/Ozrk7yPCI1gHtou+Pmu2uQzGQs6gHMeId8A3nrR6wwpznZ\r\nhPRCaP/Alc8lMWoqug0bw3d0uZ9qgFZzKviVlUqbKL1MzXiMgoxF9/rytZAc\r\nDaFkJliiTvaVQmOu/ThnV1UpV+87uzr6kRQ7ht3CJUBggRO6L3VeZxWEJiCy\r\nuxnFDKm2pdIUQD0sybsWY5FAXgGwOXOQbPs=\r\n=slN7\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.0_1676828522617_0.5980892790649408"},"_hasShrinkwrap":false},"4.2.1":{"name":"ts-pattern","version":"4.2.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"363b8b2725f92006b08284b826f6a46ecae57513","_id":"ts-pattern@4.2.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-lXCmHZb01QOM9HdCLvisCGUH9ATdKPON9UaUvwe007gJAhuSBhRWIAIowys5QqNxEq6odWctfMIdI96vzjnOMQ==","shasum":"d626da4c5755d78c1ae62b8f2675c94884a31a8c","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.1.tgz","fileCount":31,"unpackedSize":326981,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDqH/IQ7UfW7A3bgXV3aXR+hQDXHoo22ReQE9hbftIy7AiEA772MKB2mZG5I9vm6uR3I0Uy2e5UCxS8XXvY9WkGP5RY="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJj9dizACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqyhBAAmaP1UmFerZonb8x85a7tJLH3ssXQMCjUR5pnNdlF5S8j8irv\r\npLV6sPSQD2rzUylUkXRRKnF/U3VCe2TsmA5DS8w3q4TpowWOwHTWQ5xoG/D+\r\nKYG5SRNBy+B5J/q2JN/cYNzcW1TpcLJxXojNGXFNp8GyNdp7e9k1XhElXUZA\r\n3PP9yo9OdUUkgbtc/AqTvycIegbfGhzwMLiAFt9/N+4oeuVFmU+0hNZejHwU\r\n5qivfMxYymLfC4ABBXmYjIFySU1AAJ/BzD9ngzFFzDyAvxvEOuvC9N29tVn2\r\nmhObk1DQ3vzZ1oOGkFxUUjG4ZHvHAAfsNeXuX0n4Jrmb+wQTWNxbCfiTdTqg\r\nC1ild+SvRaT0T477H44J+YDzEzoKv2iQMe9r/x0AbYW+nTT9qaOtowhnPLVC\r\nEbF8vptyh+3FyobvFP70h5/zMZ3ieWU16/0dyXHdDIFoKllh1z0rmwivZa50\r\nmrYNg1U2jfzZYvtlEfTLaIyRl9mTCdQe4tStxYk59QtOC97ayy0o3ZUp6YIH\r\nkI1tXct4NeEl18t0JnOKY4jVdaPH2QBW+3z2Ufv1YetrZ6y16KtOKZXOMMoq\r\nYqg8hXxU5XxBlrUDu1rnsd2yNQL1KSDzxEH6krXxx0+5ZMcSsgXQv8x1VT9E\r\niCpWI0/DdtTHZ1ymzg9pkPL3byky218xmcA=\r\n=zwUt\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.1_1677056179583_0.24747072578179452"},"_hasShrinkwrap":false},"4.2.2":{"name":"ts-pattern","version":"4.2.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":"./dist/index.cjs","import":"./dist/index.module.js","types":"./dist/index.d.ts","default":"./dist/index.modern.js"},"./package.json":"./package.json"},"main":"./dist/index.cjs","types":"dist/index.d.ts","module":"./dist/index.module.js","unpkg":"./dist/index.umd.js","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.0","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"8430222c5b61fa21cf4cba817cbffd9b8d2da9a6","_id":"ts-pattern@4.2.2","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-qzJMo2pbkUJWusRH5o8xR+xogn6RmvViyUgwBFTtRENLse470clCGjHDf6haWGZ1AOmk8XkEohUoBW8Uut6Scg==","shasum":"e6fae2aa1ff1a7ff2ce3166f8c329a4f252f78d6","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.2.tgz","fileCount":31,"unpackedSize":327065,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEnBbfv7RsT0L+Ur1tGlLdZJbeM2fUcmxOxnrZjk1AEZAiA9J6FRAuLrjbpmPw/5nNAfQy4OoAJxFcrQU1Ra//w8gw=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJkHI7EACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrurRAApIsyebTPwSpxZ+HDnf714peMhDKvdf+QFJtn4d/7s0N/dsTf\r\nlO9+9jeOYvK+kbYW6m1iwywEBNY3pgxijTXtb0cpdzpHUNGfM36ny2CSwwVo\r\nBOqf4ULTS5MFJAZMHQWpQtFrRfaaJYBGFd6G5+7fQxjUgs4nwg11TQiy6+ih\r\nBMzar1sMgVNEd7rvXtpp5llEJf5oyac5lBCc3fA4OP4hKuMDzoUdlMHwpTKA\r\nLq+bEqm47hvndnWY0Hpm/MepGuR/KHeMsMstck5G6kXxda84CFLLy6FFg2pI\r\nWMLJ3Dw686JJCsA9Xq5I9Kep5Liq7NtuzrJ4uDM8g59XQZuvILzJBFPbIHNY\r\nudgTYkbo0LVw2wfe9tgaFPQyUfI4Fqjn99GA8m+mKDqCB6uhJm9OL3qCd6xs\r\nLlRz2eYRfeG46VL1g9PDcWP6ap/By05T2v1L/GF89UOIgPuKIIdvQc9vp6tN\r\nktUv3DElxOMEYqCUmbfArUKx//orVlfAcsZN+1uWZx3aN36LbTMfig6Z1d4G\r\nH6CEEE3eiScp2Yke9/3NYBqgwGLwS4s4uUUu+NJ6dlykGw5otIU3+9Ee7qGt\r\nOiCaS7qrwh1D906e2YyXNbU4hwKFQ7jYt2IeN8u7vzuteoLLkTlSU08+tvku\r\nyO/VVylCpQeOGIi2oWyPzDNRoydC1Bce0Po=\r\n=Wu05\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.2_1679593156355_0.10089909441897538"},"_hasShrinkwrap":false},"4.2.3-test.0":{"name":"ts-pattern","version":"4.2.3-test.0","description":" The exhaustive Pattern Matching library for TypeScript.","main":"./dist/index.js","module":"./dist/index.module.js","exports":"./dist/foo.modern.mjs","unpkg":"./dist/index.umd.js","types":"dist/index.d.ts","scripts":{"build":"microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"7ad422bc514fa6c2784a488f763d48e3455b21e8","_id":"ts-pattern@4.2.3-test.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-KcXNmrb7QPFFJub25+btZviv75NYniVHCB45FANYHB0iH5cXRNExr1o/No/DfHnv8JtptexLJ6p7oSyBDGcUEQ==","shasum":"381ae1dded1365dfb4dd0d8a65ee19070cfd0aea","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.3-test.0.tgz","fileCount":27,"unpackedSize":249428,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDkPhilzCMOKTaOkLpIZFhL1sqhLMcIghaTXZZBo0FDnwIhALZq6b9nQXyKfyzJjDY1+VA3/ak19YhXj3jXQHmnokl1"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.3-test.0_1683370146422_0.25554321420152304"},"_hasShrinkwrap":false},"4.2.3-test.1":{"name":"ts-pattern","version":"4.2.3-test.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"types":"./dist/index.d.ts","import":"./dist/index.mjs","require":"./dist/index.js","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.js","module":"dist/index.mjs","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"8f74d9d89b48b0c4dae43cd86fb2cdd54cda13bc","_id":"ts-pattern@4.2.3-test.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-3AzEzHKHwgWfXN+ox9GhtgHfyrWXYNW8s7D7PuH1MXBg3BRXZTx63Tap1tws3OaU90hyI9kVAyOunebzzrNobg==","shasum":"697d4465e41ab829e3c87fd0a82811ad2a9e93d1","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.3-test.1.tgz","fileCount":25,"unpackedSize":212211,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIB9oXHYuADR/+2fz0+bksWIHQaChwYI8yb1hRmODSF2qAiEAm3KojkgO5A69XJXfUbb5di2GOMiOawERI0ixnbX1tjA="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.3-test.1_1683371840640_0.00738211899661656"},"_hasShrinkwrap":false},"4.2.3-test.2":{"name":"ts-pattern","version":"4.2.3-test.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"types":"./dist/index.d.ts","import":"./dist/index.mjs","require":"./dist/index.cjs","default":"./dist/index.cjs"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.mjs","unpkg":"dist/index.umd.cjs","scripts":{"build":"rimraf dist && microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"2a0048ca331ee362b2a57ad4e3a2ab370ee0ac83","_id":"ts-pattern@4.2.3-test.2","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-r7VreDXHxmJx6Awqq026Yia3AOqUfxT0BvW5dFjEnO+qlSOQac8VtMWuhGJKfYFCMGhtLfJA769VqpK70hHqWg==","shasum":"076c0a248fda631902fa347695f21d51610611cd","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.3-test.2.tgz","fileCount":25,"unpackedSize":212217,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIB7T/ZKB9zzqvYrGH3pVTyjCxxHVaRKeJuQbXIuvk81YAiArTF/QWZJ6aVIvFZDAWw/65soDSCeqz82uSAGD5DBa4g=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.3-test.2_1683373404163_0.27925691953102416"},"_hasShrinkwrap":false},"4.2.3-test.3":{"name":"ts-pattern","version":"4.2.3-test.3","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"types":"./dist/index.d.ts","import":"./dist/index.mjs","require":"./dist/index.cjs","default":"./dist/index.mjs"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.mjs","unpkg":"dist/index.umd.cjs","scripts":{"build":"rimraf dist && microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"b7daf743fa5129323176e306ee677da5cd6549d6","_id":"ts-pattern@4.2.3-test.3","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-/tnujBThmDoSAyDCj+gJLLe63ULz51NgRnVJLjRBxu9He65VKG9MsuPjiSjx9lM9nCI/KUD6of/vukrUnhw1Yg==","shasum":"adda10f730cb92ff16b074db5a9ce689f010a758","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.3-test.3.tgz","fileCount":25,"unpackedSize":212217,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCID3o09PoUxd7tTcSGyf5Dym+10R4QWWfN1d2lI+mNeS8AiEA+CsE4zQm9oUx7+NI7rKZn0MMb/kho4Fok81FcturDro="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.3-test.3_1683374427225_0.9627661285028479"},"_hasShrinkwrap":false},"4.2.3":{"name":"ts-pattern","version":"4.2.3","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"types":"./dist/index.d.ts","import":"./dist/index.mjs","require":"./dist/index.cjs","default":"./dist/index.mjs"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.mjs","unpkg":"dist/index.umd.cjs","scripts":{"build":"rimraf dist && microbundle","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"788c082e85c3e03374177b253f002fc11c38d059","_id":"ts-pattern@4.2.3","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-tPg2/owaVtWiimsmXpFEzI5IcfPU2BEwzFbviuSmqqaKIGyy6hyvBF4kxcuhy8UJz+6nEKUOEeaHc43drIuvpQ==","shasum":"4434d983ff8958a82bdbd42a69b1f3f24c7ce047","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.3.tgz","fileCount":25,"unpackedSize":212210,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDTeQQJKXBJ5m6Tzem7clw0dwuj/QGPwNnpDUJ0ymx0wwIgfjg5Qskm18V5toMACEq6Cvz4qPcpPW0LxTHmVeykKHM="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.3_1683377164722_0.10450352172036048"},"_hasShrinkwrap":false},"4.2.4-test.0":{"name":"ts-pattern","version":"4.2.4-test.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.mjs"},"types":"./dist/index.d.ts","default":"./dist/index.mjs"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.mjs","unpkg":"dist/index.umd.cjs","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"47a4474027f3cbb283c33bee29c2886965d8a2ce","_id":"ts-pattern@4.2.4-test.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-jmm34dEaKqi6RMyISDY1ArjTBTCIeY+S5by1wOM9Y4IupqMdIHdCUwb37NqSJoxdSy9hNK+fnHKXA/siGugELg==","shasum":"d7d84012da0cce5a82b14233491da59b029b8e79","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.4-test.0.tgz","fileCount":41,"unpackedSize":259040,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDEG2yHtBlJ3Qm9Tjyw/WYg/ms599ExOOrrWX6ldqKHUgIhAN3IhgMTS6GtV6o91Ay9/CWlhQly0H/Y/Y88vLxn7o84"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.4-test.0_1683481284250_0.27851113820068596"},"_hasShrinkwrap":false},"4.2.4-test.1":{"name":"ts-pattern","version":"4.2.4-test.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Sets\n\nPatterns can be Sets.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(new Set([1, 'hello']), (set) => `Set contains 1 and 'hello'`)\n  .with(new Set([1, 2]), (set) => `Set contains 1 and 2`)\n  .with(new Set([P.string]), (set) => `Set contains only strings`)\n  .with(new Set([P.number]), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'Set contains 1 and 2'\n```\n\nIf a Set pattern contains one single wildcard pattern, it will match if\neach value in the input set match the wildcard.\n\nIf a Set pattern contains several values, it will match if the\ninput Set contains each of these values.\n\n### Maps\n\nPatterns can be Maps. They match if the input is a Map, and if each\nvalue match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(new Map([['b', 2]]), (map) => `map.get('b') is 2`)\n  .with(new Map([['a', P.string]]), (map) => `map.get('a') is a string`)\n  .with(\n    new Map([\n      ['a', P.number],\n      ['c', P.number],\n    ]),\n    (map) => `map.get('a') and map.get('c') are number`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => 'map.get('b') is 2'\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user] as const)\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"feb7fff8769713e8290210ef113f1d0a17fe5670","_id":"ts-pattern@4.2.4-test.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-DLsVY4A5HA0l1sWCuU0GDrUZD7D0ta1njHtNkMcqMlTd21L4dDGEzhg3M5V9SFxZZlUKQknNRKTCMUs5ZNnGAw==","shasum":"f69d0b446bb31f1bcb403d3e0616d3b918bf48b0","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.2.4-test.1.tgz","fileCount":41,"unpackedSize":259149,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIH//+ZWCY7sGDDjCELFZVJ/xo+a8Izfbd560v+YxMCzNAiEA1vtrA2h9TjDBxX1OCNYmFlvpo8ZWnciBWC/DlO+7G1Q="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.2.4-test.1_1683537400192_0.8967412659055831"},"_hasShrinkwrap":false},"4.3.0":{"name":"ts-pattern","version":"4.3.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.5.1","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^4.8.3"},"gitHead":"f147f96b0efaa5778c6955e7c598a7fd5ae5733c","_id":"ts-pattern@4.3.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-pefrkcd4lmIVR0LA49Imjf9DYLK8vtWhqBPA3Ya1ir8xCW0O2yjL9dsCVvI7pCodLC5q7smNpEtDR2yVulQxOg==","shasum":"7a995b39342f1b00d1507c2d2f3b90ea16e178a6","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-4.3.0.tgz","fileCount":41,"unpackedSize":259142,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDzZHHuZ/hN4EqsU96s9pnWaZcz1l+8BM5cLw41k9MeDwIgfxcGOaqyLgb9UU+wTJiAdQydotFFUrL/aip6Ikv7TRs="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_4.3.0_1683585070805_0.7286789820058981"},"_hasShrinkwrap":false},"5.0.0-rc.0":{"name":"ts-pattern","version":"5.0.0-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^5.0.4"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"69b021f54353688ff28fb4b40b14776bf0cac1d8","_id":"ts-pattern@5.0.0-rc.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-8va86uitwAaQyPnIMnG0exq+JRV05z84X0mNvuZoNFDHsXO7KdPHTtBnfzr/0R/l/7Iq8WMFPPkHsrU4wo1gWQ==","shasum":"e479c7b3d2eee34fb9c698876035257a91fe3730","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.0.tgz","fileCount":41,"unpackedSize":455285,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCszkgQxPnovhE+cQlk7ofvWfImS/WDHvYVp6ZG3E6W/AIgfbJ9K/leUjLUrzP1WnzEmSZRYZ/V72Z01M6eqPwBeYM="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.0_1684162457517_0.4777600489311864"},"_hasShrinkwrap":false},"5.0.0-rc.1":{"name":"ts-pattern","version":"5.0.0-rc.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^27.0.2","jest":"^27.4.5","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.0","ts-jest":"^27.1.2","typescript":"^5.0.4"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                              | TypeScript v4.5+ | TypeScript v4.2+ | TypeScript v4.1+ |\n| --------------------------------------------------------------------------------------------------------------------------------------- | ---------------- | ---------------- | ---------------- |\n| v4.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅               | ❌               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                            | ✅               | ✅               | ⚠️               |\n| v2.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v2#documentation)                                                            | ✅               | ✅               | ✅               |\n\n- ✅ Full support\n- ⚠️ Partial support, All features except passing multiple patterns to `.with()`.\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"373cefbcdf75ae74a3a4b0df66db970d991f3589","_id":"ts-pattern@5.0.0-rc.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-Wb0s2expqr36hUiWZX2PD3FTEqNfsHpmb7W/D3a+rH9vV2oH5QABqJIcHXNsboa3UqOy6IGEdPe3NkNOEMIr/A==","shasum":"cc0b47602301f9acf73a09055e3aa8e1deddd146","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.1.tgz","fileCount":41,"unpackedSize":466382,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEs1X2o7DfBbffHwzGa95Biiy4ScZ3LlRrNPD2nqFax6AiB/6GoCsvIP6T2GhhvlEgAQ0pujrVuZxyN+hbphxeo3pQ=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.1_1684241018268_0.9988694996170913"},"_hasShrinkwrap":false},"5.0.0-rc.2":{"name":"ts-pattern","version":"5.0.0-rc.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.when((age) => age > 18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.when((age) => age > 18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"5f1c1441c8b6f8a934e637cab90c87e2c1b8d6ce","_id":"ts-pattern@5.0.0-rc.2","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-cDXHq3rcgv4S8CtFDdNYdG2RaIqy+E3+fUgpPEXw6BPHOgRdNzKy5KMSkBsMlpk8aeK8CjDRJEs6oIiRG0BT0g==","shasum":"a78699e11fe88583c6da549ead435cf500b56990","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.2.tgz","fileCount":41,"unpackedSize":471619,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCHlKwV9QI2O5XKueQ2aNFQhAi1Tk/NzqGQqEgPBxgSbQIhAOkFhxr0AAeFOYceDT3CridxTK5vgSSnRC7+1Psmh2DB"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.2_1685872271941_0.098880834451057"},"_hasShrinkwrap":false},"5.0.0-rc.3":{"name":"ts-pattern","version":"5.0.0-rc.3","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  likeCount: P.number,\n  author: {\n    name: P.string,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"96922f8e8de7274fd775be901c3715e3a6b01961","_id":"ts-pattern@5.0.0-rc.3","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-hw7XHRrx6eRjvR1MAW4NwHPFuo4d7yrv5rwNTZBF2nvIy5SEdy/YvXooFp2037r4DpJSRWkyi13v7uK24cGi7w==","shasum":"6704c278f9120e53f7229b59348df57f84139702","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.3.tgz","fileCount":41,"unpackedSize":471599,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBbm0hk2avHzuwXER0yaOmUSwvFC8RUJsdNunTi4BrQ8AiEAknNcmwpcHHjSUkB18x5mTBHOuRX4bkPksKbL4W1mRQM="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.3_1685888641811_0.2898363900701242"},"_hasShrinkwrap":false},"5.0.0-rc.4":{"name":"ts-pattern","version":"5.0.0-rc.4","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"661387e3038d65550f316b49186404cce583242b","_id":"ts-pattern@5.0.0-rc.4","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-/lsh4Ihl75hz6MyzCpu4G1QyPTJLtsRORO6Ezq8sACljWJ2WGlcB4A2ZAMVKl0QUrut5qJc7ngiVZb2jfNP40Q==","shasum":"c6fee7aad3f1874efc3d08c1a0e02e918d59d2a1","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.4.tgz","fileCount":41,"unpackedSize":471643,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCbVzVl6o2ytQz2n3LVC6Eifv7IYYf9BlP446gL0T6wtQIhAMJECl3ggoNJfzcZXw1EsJ6kbd+eU+d97piyDPbSwFyK"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.4_1686000751072_0.38095536037534483"},"_hasShrinkwrap":false},"5.0.0-rc.5":{"name":"ts-pattern","version":"5.0.0-rc.5","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"5750e102ab3cb0c74d6356b902b90eb202bac4eb","_id":"ts-pattern@5.0.0-rc.5","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-jMZDVp0VTq2z+sGIHJ15tHRsV7dBtUlmwe+U7e+n6cq89m2vplCfL3BYmtbhjEqgIn+wGCjjcsqJWJyzGxfYqw==","shasum":"a10223a7f11831145b023553534afced6ad2c25c","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.5.tgz","fileCount":41,"unpackedSize":465600,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIEDbbdOIPxhjfN9xqndsggKBryQzFFRRTHvH/7qJJ6S/AiB/p5hUXC0xA6Mbqk7SXEGHX8Vp2JxF5L5ZFZqEYko+8Q=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.5_1686001478260_0.621331405188901"},"_hasShrinkwrap":false},"5.0.0-rc.6":{"name":"ts-pattern","version":"5.0.0-rc.6","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"b6966e5279839681f8741979ea76794d1c3c715d","_id":"ts-pattern@5.0.0-rc.6","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-LKIxnDhOKltBcFfgWABMlftNCss6hnyU0JLAz1N/9ybPfVcMMtRMwpAdQIiFXb6ZzVsN9AcLHH/fBusdm8Bv0g==","shasum":"44c5cf04e2a47f9e29e30a710ca19d273c944a3a","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.6.tgz","fileCount":41,"unpackedSize":458612,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCRWFfbvLnoAjPqU7TS/vvcA9Re+/XAjK/JEf3TzjtBrgIhANvWbGixHJJ+uou28pfMbtaZ+wDaYTV/glOQetUsCa+U"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.6_1686322031586_0.4716780585614553"},"_hasShrinkwrap":false},"5.0.0-rc.7":{"name":"ts-pattern","version":"5.0.0-rc.7","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"a0415cf872cf933d99969e40be33e9a6bc4cc4f3","_id":"ts-pattern@5.0.0-rc.7","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-VK264wujQRhOhWBeY3XN57P2R7LJIesNsLn8+kbPu1InUD1bIMAk/GSHJ1noMd4vf6l0AfgWPAqKF5EMOIIHZQ==","shasum":"357c8acc3f0dadd16bddfd5ae9bf94347b72b361","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.7.tgz","fileCount":41,"unpackedSize":457499,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEBi2YHteR6Q2a3nk9DLOpzDIXUBqF5DWy8IJmDr5zkrAiEA0LI6r+/+lI3JJ+dthoTH40NRODLOt7Xq9CkfYPSc4nU="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.7_1686580393508_0.03123332962714409"},"_hasShrinkwrap":false},"5.0.0-rc.8":{"name":"ts-pattern","version":"5.0.0-rc.8","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#sets), [Maps](#maps) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only 1.7kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#sets)\n    - [Maps](#maps)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  title: P.string,\n  description: P.string,\n};\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed())\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed())\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` helper patterns\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` helper patterns\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n};\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"29a2a43be8573574b088625eb1478ba76e15f1e0","_id":"ts-pattern@5.0.0-rc.8","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-jjPGea+qNLvYQpaNigty30EJPwERLfFWAwW/pYuCh5KVZeXDPCfoNF4EjZSVlVBDbc5Mh4r1xP0rG74v2t45fw==","shasum":"031f721542304f7450f6c40f03a786bb79b708b5","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0-rc.8.tgz","fileCount":41,"unpackedSize":464056,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIFMrSdUK+wiAcVFHtQWHlI7+YmCPalLGxLVrFYYchCceAiEAtWrQ5soLTnHkH4QmlVB3xtNhw5z+rkjXJWW/l/29JPg="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0-rc.8_1686649781075_0.7672538464431218"},"_hasShrinkwrap":false},"5.0.0":{"name":"ts-pattern","version":"5.0.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"ce1925d6d3dd8f05d1bd42719be7535f9ace50da","_id":"ts-pattern@5.0.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-FDTdTujq2GvMmrwYM0Om6pMilRAUKvBApEN+YniTQui/HGjFwaI6WAx9SepD+yDBf4q29JLf6yqGB8uvdzysEg==","shasum":"5971254f4f68b69d83956c2ce4e823edb5fd6d13","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.0.tgz","fileCount":41,"unpackedSize":464080,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDEoLSVmLDfmRD9FtrHtj1wlluj9Kyu4lkoEQt7glW4jwIgXth+hvP1COvj1t6X84fZ+ySBOcNmGMe3CBr4qJspf6M="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.0_1686659873803_0.2876523909991966"},"_hasShrinkwrap":false},"5.0.1":{"name":"ts-pattern","version":"5.0.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"7ccc1d3333e424391f0b8e0f1ec0055025448bda","_id":"ts-pattern@5.0.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-ZyNm28Lsg34Co5DS3e9DVyjlX2Y+2exkI4jqTKyU+9/OL6Y2fKOOuL8i+7no71o74C6mVS+UFoP3ekM3iCT1HQ==","shasum":"340d91647982b90ca6c71645ae438f78518e9842","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.1.tgz","fileCount":41,"unpackedSize":464224,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDevUFk0nMVXoK1y2k5vOl8n1IATuBGotesnvUkMEvDhQIhANAkzs1JORY/uPvCA1x1ORVW5wWQV1j6LcdVWVJ7FiGd"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.1_1686667504855_0.30274423659538874"},"_hasShrinkwrap":false},"5.0.2":{"name":"ts-pattern","version":"5.0.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"8e9e3302db42d82addc5f94997b2c4d5db3ee273","_id":"ts-pattern@5.0.2","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-JYcu4oJ7AGbww1z835AqMhrjwqclhICWhzjib4dp8MrY3UiFHqy1PVegVy+mW6VZ5vHrMeGombCbau2FGGSTJw==","shasum":"02f5dd1080a6ff5423fcc1ab6e3315bc6c90e2dc","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.2.tgz","fileCount":41,"unpackedSize":463725,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCbe+wxJs0wwRCqP4l1cQdRR0Z6zzVhE8aofu1YGcsRxQIgfGRR/DGZoyZXy7U4YOPn39tPF8W7KpKfGJnS3+7VDI8="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.2_1689266102002_0.1635652617927208"},"_hasShrinkwrap":false},"5.0.3-rc.0":{"name":"ts-pattern","version":"5.0.3-rc.0","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#pset-patterns), [Maps](#pmap-patterns) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only ~2kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.returnType`](#returntype)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#pset-patterns)\n    - [Maps](#pmap-patterns)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.string` predicates](#pstring-predicates)\n    - [`P.number` and `P.bigint` predicates](#pnumber-and-pbigint-predicates)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.returnType`\n\n```ts\nmatch(...)\n  .returnType<string>()\n  .with(..., () => \"has to be a string\")\n  .with(..., () => \"Oops\".length)\n  //               ~~~~~~~~~~~~~ ❌ `number` isn't a string!\n```\n\nThe `.returnType<SomeType>()` method allows you to control the return type of all of your branches of code. It accepts a single type parameter that will be used as the return type of your `match` expression. All code branches must return values assignable to this type.\n\n#### Signature\n\n```ts\nfunction returnType<TOutputOverride>(): Match<TInput, TOutputOverride>;\n```\n\n#### Type arguments\n\n- `TOutputOverride`\n  - The type that your `match` expression will return. All branches must return values assignable to it.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n} as const;\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed(2))\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed(2))\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` predicates\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.maxLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]+$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` predicates\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n} as const;\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\nAlthough not strictly necessary, using `as const` after the pattern definition ensures that TS-Pattern infers the most precise types possible.\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"e0a58f00bb9bc88cf3557d6af07086d5a3f48205","_id":"ts-pattern@5.0.3-rc.0","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-t2PL2QKUSq7ypDV71bpaypJpKp03jZT655bBN5/ahplBxnOJ05i/AiwQosFKcO1Vteg1Pkr4FzLhdCJkgEFvOQ==","shasum":"fbb53499378966b87754b6e5a1ee8ee55c0ec231","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.3-rc.0.tgz","fileCount":41,"unpackedSize":464002,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBUANTT+L9kuCRe0qh1bjdn5HWFKgvBwZjiw3FjU+N4CAiBcO3m0aYxu/G/TptUIXe1CN7oxBI8lPGhgD2aZpEmSPA=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.3-rc.0_1689268339550_0.7724154780711328"},"_hasShrinkwrap":false},"5.0.3-rc.1":{"name":"ts-pattern","version":"5.0.3-rc.1","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#pset-patterns), [Maps](#pmap-patterns) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only ~2kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.returnType`](#returntype)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#pset-patterns)\n    - [Maps](#pmap-patterns)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.string` predicates](#pstring-predicates)\n    - [`P.number` and `P.bigint` predicates](#pnumber-and-pbigint-predicates)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.returnType`\n\n```ts\nmatch(...)\n  .returnType<string>()\n  .with(..., () => \"has to be a string\")\n  .with(..., () => \"Oops\".length)\n  //               ~~~~~~~~~~~~~ ❌ `number` isn't a string!\n```\n\nThe `.returnType<SomeType>()` method allows you to control the return type of all of your branches of code. It accepts a single type parameter that will be used as the return type of your `match` expression. All code branches must return values assignable to this type.\n\n#### Signature\n\n```ts\nfunction returnType<TOutputOverride>(): Match<TInput, TOutputOverride>;\n```\n\n#### Type arguments\n\n- `TOutputOverride`\n  - The type that your `match` expression will return. All branches must return values assignable to it.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n} as const;\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed(2))\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed(2))\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` predicates\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.maxLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]+$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` predicates\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n} as const;\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\nAlthough not strictly necessary, using `as const` after the pattern definition ensures that TS-Pattern infers the most precise types possible.\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"2b6c3956ee458f3d04ec7594a425ccd09ed99225","_id":"ts-pattern@5.0.3-rc.1","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-7tEP/tGy4cGpeaF3Ii/XUysvs5+JGH7y7s5V77KrucdQD2eUig81WKmLDtIXWagGd/YXMQJBuorQLFZM+EtNEg==","shasum":"6b05509b39a16bf89f3ee09af2d23534a00fb044","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.3-rc.1.tgz","fileCount":41,"unpackedSize":417927,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHyCLwvIrC6Sw05CI/zBimXRslQ39NlWfugObQkh9+8pAiEA8wkqXNniGfmyUD3338UwGqGbBBq3mVmOQwvaUR0ooVo="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.3-rc.1_1689268795490_0.47603269954185734"},"_hasShrinkwrap":false},"5.0.3-rc.2":{"name":"ts-pattern","version":"5.0.3-rc.2","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => `<p>Oups! An error occured</p>`)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => `<p>${res.data.content}</p>`)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => `<img src=${src} />`)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#pset-patterns), [Maps](#pmap-patterns) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#P_-wildcard), [`P.string`](#Pstring-wildcard), [`P.number`](#Pnumber-wildcard), etc.\n- Supports [**predicates**](#Pwhen-patterns), [**unions**](#Punion-patterns), [**intersections**](#Pintersection-patterns) and [**exclusion**](#Pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#Pselect-patterns) function.\n- Tiny bundle footprint ([**only ~2kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages, which lets you scrutinize the structure of values in a declarative way. It has proven itself to be less verbose and more powerful than imperative alternatives (if/else/switch statements), especially when branching on complex data structures or on several values.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to the EcmaScript specification, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nNote: TS-Pattern assumes [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.returnType`](#returntype)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#pset-patterns)\n    - [Maps](#pmap-patterns)\n    - [`P.array` patterns](#Parray-patterns)\n    - [`P.when` patterns](#Pwhen-patterns)\n    - [`P.not` patterns](#Pnot-patterns)\n    - [`P.select` patterns](#Pselect-patterns)\n    - [`P.optional` patterns](#Poptional-patterns)\n    - [`P.instanceOf` patterns](#Pinstanceof-patterns)\n    - [`P.union` patterns](#Punion-patterns)\n    - [`P.intersection` patterns](#Pintersection-patterns)\n    - [`P.string` predicates](#pstring-predicates)\n    - [`P.number` and `P.bigint` predicates](#pnumber-and-pbigint-predicates)\n  - [Types](#types)\n    - [`P.infer`](#Pinfer)\n    - [`P.Pattern`](#PPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, we are going to create a state reducer for a\nfrontend application fetching some data using an HTTP request.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want to create\na reducer function that **matches on both the state and the event**\nand return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested\nswitch statements, we can do that in a very expressive way:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event): State =>\n  match<[State, Event], State>([state, event])\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([, event]) => ({\n        status: 'success',\n        data: event.data,\n      })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({\n        status: 'error',\n        error,\n      })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({\n        status: 'loading',\n        startTime: Date.now(),\n      })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({\n        status: 'idle',\n      })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\n**Let's go through this bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n```ts\nmatch<[State, Event], State>([state, event]);\n```\n\nHere we wrap the state and the event objects in an array and we explicitly\nspecify the type `[State, Event]` to make sure it is interpreted as\na [Tuple](#tuples-arrays) by TypeScript, so we\ncan match on each value separately.\n\nMost of the time, you don't need to specify the type of input\nand output with `match<Input, Output>(...)` because `match` is able to\ninfer both of these types.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value**\nyou expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if\nthe input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({\n      status: 'error',\n      error,\n    })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({\n      status: 'loading',\n    })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check if a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith `ts-pattern` there are two options to use a guard function:\n\n- use `P.when(<guard function>)` inside your pattern\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({\n      status: 'idle',\n    })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({\n      status: 'idle'\n    })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having **longer compilation times** because the type checker has more work to do.\n\nAlternatively you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\nIf you don't want to use `.exhaustive()` and also don't want to provide a default value with `.otherwise()`, you can use `.run()` instead:\n\n```ts\n  .run();\n```\n\nIt's just like `.exhaustive()`, but it's **unsafe** and might throw runtime error if no branch matches your input value.\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (value: TInput, selections: Selections<TInput>) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.returnType`\n\n```ts\nmatch(...)\n  .returnType<string>()\n  .with(..., () => \"has to be a string\")\n  .with(..., () => \"Oops\".length)\n  //               ~~~~~~~~~~~~~ ❌ `number` isn't a string!\n```\n\nThe `.returnType<SomeType>()` method allows you to control the return type of all of your branches of code. It accepts a single type parameter that will be used as the return type of your `match` expression. All code branches must return values assignable to this type.\n\n#### Signature\n\n```ts\nfunction returnType<TOutputOverride>(): Match<TInput, TOutputOverride>;\n```\n\n#### Type arguments\n\n- `TOutputOverride`\n  - The type that your `match` expression will return. All branches must return values assignable to it.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): IOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nRuns the pattern-matching expression and returns its result. It throws an error at run time if no match was found, same as `exhaustive()`. However, unlike `.exhaustive()`, exhaustiveness is not checked at compile time, meaning the type checker will not verify that all possible cases are covered.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n} as const;\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#P_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed(2))\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed(2))\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements which can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item match the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` predicates\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.maxLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]+$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` predicates\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n} as const;\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\nAlthough not strictly necessary, using `as const` after the pattern definition ensures that TS-Pattern infers the most precise types possible.\n\n### `P.narrow`\n\n`P.narrow<Input, typeof Pattern>` will narrow the input type to only keep the set of values that are compatible with the provided pattern type.\n\n```ts\ntype Input = ['a' | 'b' | 'c', 'a' | 'b' | 'c'];\nconst Pattern = ['a', P.union('a', 'b')] as const;\n\ntype Narrowed = P.narrow<Input, typeof Pattern>;\n//     ^? ['a', 'a' | 'b']\n```\n\nNote that most of the time, the `match` and `isMatching` functions perform narrowing for you, and you do not need to narrow types yourself.\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","gitHead":"07dbc232a4ef14df7949cccbc41724eafe043c91","_id":"ts-pattern@5.0.3-rc.2","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-uhvRARq30g9Uk5J4RjA936u/hwe6/RiPSuAOT24AQeiBqwuT6DvX8qSy4DBZnyX4px008ZnCReTvVlYpHokuvg==","shasum":"7462081599875ab4e7c527a7535eb067d06c3d84","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.3-rc.2.tgz","fileCount":41,"unpackedSize":422597,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGSwFGPlnMRuDf/tEuW+0ySFoPyoPb5W6XiJiOHinLz7AiEAvI2aFhujf0pnxz/CVau0Gz7Bqy7xgKQLh0BPEUGXOs4="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.3-rc.2_1689269803727_0.5291481181502009"},"_hasShrinkwrap":false},"5.0.3":{"name":"ts-pattern","version":"5.0.3","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"a612fa290555b3aa35244182ef520a2cb0281d8c","_id":"ts-pattern@5.0.3","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-JMfGCcuRz0/efyv7vI71QgIp7en2n7KxQ/cFk9nlyo8eFFgsa6TEfbnKw3N5mLGo7Mf8oUwOyRpTEqXU0kuV+w==","shasum":"bd81acab451428eeab2c9cb49eafe0ac9a2611ac","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.3.tgz","fileCount":41,"unpackedSize":418834,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCPt/IU/n1aacvzgZCUhYRS/DyBahpyeoo/XtLGsnd1xwIhAMV5d6aroji3XtsoOBGmwTAbuW51GEH1pJDb5jVCQ/mO"}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.3_1689333504968_0.35248454825835673"},"_hasShrinkwrap":false},"5.0.4":{"name":"ts-pattern","version":"5.0.4","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"d6c481b8b82bef676628978176f534f11cafa81e","_id":"ts-pattern@5.0.4","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-D5iVliqugv2C9541W2CNXFYNEZxr4TiHuLPuf49tKEdQFp/8y8fR0v1RExUvXkiWozKCwE7zv07C6EKxf0lKuQ==","shasum":"11508e1fb09c4a65b3fa85fd297941792c0ab7d1","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.4.tgz","fileCount":41,"unpackedSize":418486,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIH7TGc5S/0FXk4zF2FxoRwwLPEiOnJWDpDTPkW3PAkJqAiAF5iTcilqrvOWG3Ihn2mssnVG9ifWYibFBOV84VAii1A=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.4_1689781476221_0.9321525091919554"},"_hasShrinkwrap":false},"5.0.5":{"name":"ts-pattern","version":"5.0.5","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"6eee0f9ac8cbbf7d8c7accbd9372a15b55426d77","_id":"ts-pattern@5.0.5","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-tL0w8U/pgaacOmkb9fRlYzWEUDCfVjjv9dD4wHTgZ61MjhuMt46VNWTG747NqW6vRzoWIKABVhFSOJ82FvXrfA==","shasum":"20f82d50ea56c1d9cd1aa772911f7bb545d9607d","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.5.tgz","fileCount":41,"unpackedSize":404423,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDBCYY+QnWDd85nHlt2NDEcduiXJo02/HGCvZUJgb86qwIgKbNoxcmjk30FcBkVRwyp5xyxmU612nUA3etd3iXfgr4="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.5_1691357741941_0.33010609306391636"},"_hasShrinkwrap":false},"5.0.6":{"name":"ts-pattern","version":"5.0.6","description":" The exhaustive Pattern Matching library for TypeScript.","type":"module","source":"src/index.ts","exports":{".":{"require":{"types":"./dist/index.d.cts","default":"./dist/index.cjs"},"import":{"types":"./dist/index.d.ts","default":"./dist/index.js"},"types":"./dist/index.d.ts","default":"./dist/index.js"},"./package.json":"./package.json"},"types":"dist/index.d.ts","main":"dist/index.cjs","module":"dist/index.js","unpkg":"dist/index.umd.js","scripts":{"build":"rimraf dist && microbundle --format modern,cjs,umd && sh ./scripts/generate-cts.sh","dev":"microbundle watch","prepublishOnly":"npm run test && npm run build","test":"jest","clear-test":"jest --clearCache","perf":"tsc --project tests/tsconfig.json --noEmit --extendedDiagnostics","fmt":"prettier ./src/** ./tests/** -w","check":"tsc --strict --noEmit --extendedDiagnostics"},"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"author":{"name":"Gabriel Vergnaud"},"license":"MIT","bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"homepage":"https://github.com/gvergnaud/ts-pattern#readme","devDependencies":{"@types/jest":"^29.5.2","jest":"^29.5.0","microbundle":"^0.15.1","prettier":"^2.8.8","rimraf":"^5.0.1","ts-jest":"^29.1.0","typescript":"^5.1.3"},"gitHead":"16786f0fe0f8ac92d1f095c61bfcee2ef55b2311","_id":"ts-pattern@5.0.6","_nodeVersion":"18.12.1","_npmVersion":"9.1.2","dist":{"integrity":"sha512-Y+jOjihlFriWzcBjncPCf2/am+Hgz7LtsWs77pWg5vQQKLQj07oNrJryo/wK2G0ndNaoVn2ownFMeoeAuReu3Q==","shasum":"53af94065c761ec9f87b9113e52e6b884f81d60d","tarball":"https://registry.npmjs.org/ts-pattern/-/ts-pattern-5.0.6.tgz","fileCount":41,"unpackedSize":404402,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDEjfI3WsN4WskMUQM/KXgyIv/YfEjXosAxC3n6+VgPvAiBrGwaa4kz1nCty4ZxJeF1NCHpJGnq1fNmJRFldPfxjVw=="}]},"_npmUser":{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"},"directories":{},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/ts-pattern_5.0.6_1701570300973_0.8736131802147926"},"_hasShrinkwrap":false}},"time":{"created":"2020-05-24T16:51:07.831Z","0.0.1":"2020-05-24T16:51:08.006Z","modified":"2023-12-03T02:25:01.352Z","0.0.2":"2020-05-24T17:00:39.489Z","0.0.3":"2020-05-24T22:09:46.516Z","0.0.4":"2020-05-24T22:18:47.577Z","0.1.0":"2020-05-25T09:24:27.686Z","0.1.1":"2020-05-25T09:38:44.892Z","0.1.2":"2020-05-25T13:02:35.236Z","0.1.3":"2020-05-26T08:55:45.997Z","0.1.4":"2020-05-26T12:58:45.420Z","0.1.5":"2020-05-26T18:20:10.693Z","0.1.6":"2020-05-26T18:32:45.619Z","0.1.7":"2020-05-26T18:39:14.139Z","0.1.8":"2020-05-27T10:23:17.814Z","0.1.9":"2020-05-29T13:18:37.840Z","0.2.0":"2020-05-29T14:02:25.401Z","0.2.1":"2020-06-01T11:49:12.792Z","0.2.2":"2020-06-02T11:32:48.041Z","0.3.0":"2020-06-04T13:05:46.965Z","0.3.1":"2020-06-04T13:11:44.109Z","0.3.2":"2020-06-05T11:06:59.816Z","1.0.0":"2020-06-10T17:02:52.749Z","1.1.0":"2020-07-03T15:47:22.333Z","2.0.1-next.0":"2021-01-16T18:55:39.530Z","2.0.1-next.1":"2021-01-17T17:53:29.164Z","2.0.1-next.2":"2021-01-17T20:23:07.017Z","2.1.0":"2021-01-30T09:06:57.914Z","2.1.1-next.0":"2021-02-04T08:32:41.358Z","2.1.1":"2021-02-04T08:55:47.460Z","2.1.2":"2021-02-08T08:56:51.209Z","2.1.3-next.0":"2021-02-21T22:06:22.226Z","2.1.3":"2021-02-23T08:16:25.156Z","2.1.4":"2021-02-24T18:41:38.993Z","2.2.1-next.0":"2021-02-25T08:07:27.979Z","2.2.1-next.1":"2021-02-25T11:48:25.321Z","2.1.5":"2021-02-25T11:49:39.751Z","2.1.6":"2021-03-01T08:10:48.760Z","2.2.1-next.2":"2021-03-01T08:34:51.732Z","2.2.1":"2021-03-01T18:30:19.252Z","2.2.2":"2021-03-01T20:38:15.271Z","3.0.1-next.0":"2021-03-05T14:44:57.098Z","3.0.1-next.1":"2021-03-06T09:44:45.481Z","3.0.1-next.2":"2021-03-07T10:11:46.716Z","3.0.1-next.3":"2021-03-08T08:47:07.133Z","3.0.1-next.4":"2021-03-08T09:16:34.611Z","3.0.1-next.5":"2021-03-08T18:12:55.118Z","2.2.3":"2021-03-08T18:34:08.296Z","2.4.0":"2021-03-09T13:30:22.559Z","3.0.1-next.6":"2021-03-10T11:07:38.537Z","3.0.1-next.7":"2021-03-13T09:14:49.655Z","3.0.1-next.8":"2021-03-14T09:31:29.475Z","3.0.1":"2021-03-14T21:16:02.443Z","3.0.2":"2021-03-14T21:28:46.212Z","3.0.3":"2021-03-16T08:26:30.717Z","3.0.4":"2021-03-16T18:13:48.882Z","3.0.5":"2021-03-16T18:26:28.588Z","3.0.6":"2021-03-17T09:59:17.735Z","3.1.1-next.0":"2021-03-23T08:38:22.968Z","3.1.1":"2021-03-25T09:00:29.048Z","3.1.2":"2021-04-04T22:22:49.766Z","3.1.3":"2021-05-10T08:13:25.985Z","3.2.1-next.0":"2021-05-10T08:23:29.623Z","3.1.4":"2021-05-10T12:49:07.804Z","3.1.5":"2021-05-12T08:58:58.041Z","3.1.6":"2021-05-26T13:55:21.008Z","3.1.7":"2021-05-31T07:29:06.819Z","3.2.1-next.1":"2021-07-01T20:18:37.073Z","3.2.1":"2021-07-01T20:30:47.841Z","3.2.2":"2021-07-21T13:17:39.429Z","3.2.3":"2021-07-31T22:46:57.640Z","3.2.4":"2021-08-01T12:16:38.913Z","3.2.5":"2021-08-21T10:21:15.164Z","3.3.1":"2021-09-17T17:03:39.690Z","3.3.2":"2021-09-23T20:17:47.787Z","3.3.3":"2021-09-23T21:05:26.750Z","3.3.4-rc.0":"2021-12-16T09:56:14.297Z","3.3.4-rc.1":"2021-12-19T14:35:56.851Z","3.3.4":"2021-12-20T10:32:55.516Z","4.0.0-rc.0":"2022-01-01T20:06:51.952Z","4.0.0-rc.1":"2022-01-02T09:26:25.444Z","4.0.1-rc.1":"2022-01-02T10:28:28.419Z","4.0.1-rc.2":"2022-01-02T10:39:43.907Z","4.0.1-rc.3":"2022-01-02T19:08:06.577Z","4.0.1-rc.4":"2022-01-19T20:24:55.451Z","3.3.5":"2022-01-23T21:24:47.638Z","4.0.1-rc.5":"2022-01-24T11:03:47.184Z","4.0.1-rc.6":"2022-01-31T17:40:45.623Z","4.0.1-rc.7":"2022-02-01T11:15:21.795Z","4.0.1-rc.8":"2022-02-13T10:53:07.305Z","4.0.1-rc.9":"2022-03-01T21:15:46.964Z","4.0.1-rc.10":"2022-03-03T10:16:53.911Z","4.0.1-rc.11":"2022-03-08T20:57:38.295Z","4.0.1-rc.12":"2022-03-08T21:02:24.398Z","4.0.1-rc.13":"2022-03-12T23:37:47.356Z","4.0.1-rc.14":"2022-03-13T22:20:07.624Z","4.0.1-rc.15":"2022-03-21T22:48:47.401Z","4.0.1-rc.16":"2022-03-25T09:03:29.363Z","4.0.1":"2022-03-26T10:48:17.939Z","4.0.2":"2022-04-17T17:10:22.393Z","4.0.3-rc.0":"2022-06-07T08:08:25.606Z","4.0.3":"2022-06-07T08:21:16.870Z","4.0.4":"2022-07-06T13:21:37.674Z","4.0.5":"2022-07-13T09:49:16.551Z","4.0.6-rc.0":"2022-09-15T12:10:38.020Z","4.0.6":"2022-11-14T10:12:39.584Z","4.1.0":"2023-01-08T21:23:55.510Z","4.1.1":"2023-01-08T22:05:33.064Z","4.1.2":"2023-01-09T10:46:15.377Z","4.1.3":"2023-01-12T09:09:06.512Z","4.1.4-test.0":"2023-01-15T12:31:00.006Z","4.1.4":"2023-02-06T23:12:15.780Z","4.2.0-rc.0":"2023-02-19T17:27:30.160Z","4.2.0":"2023-02-19T17:42:02.893Z","4.2.1":"2023-02-22T08:56:19.784Z","4.2.2":"2023-03-23T17:39:16.560Z","4.2.3-test.0":"2023-05-06T10:49:06.620Z","4.2.3-test.1":"2023-05-06T11:17:20.810Z","4.2.3-test.2":"2023-05-06T11:43:24.384Z","4.2.3-test.3":"2023-05-06T12:00:27.444Z","4.2.3":"2023-05-06T12:46:04.934Z","4.2.4-test.0":"2023-05-07T17:41:24.450Z","4.2.4-test.1":"2023-05-08T09:16:40.389Z","4.3.0":"2023-05-08T22:31:11.000Z","5.0.0-rc.0":"2023-05-15T14:54:17.703Z","5.0.0-rc.1":"2023-05-16T12:43:38.438Z","5.0.0-rc.2":"2023-06-04T09:51:12.106Z","5.0.0-rc.3":"2023-06-04T14:24:02.083Z","5.0.0-rc.4":"2023-06-05T21:32:31.341Z","5.0.0-rc.5":"2023-06-05T21:44:38.433Z","5.0.0-rc.6":"2023-06-09T14:47:11.724Z","5.0.0-rc.7":"2023-06-12T14:33:13.733Z","5.0.0-rc.8":"2023-06-13T09:49:41.241Z","5.0.0":"2023-06-13T12:37:54.033Z","5.0.1":"2023-06-13T14:45:05.044Z","5.0.2":"2023-07-13T16:35:02.411Z","5.0.3-rc.0":"2023-07-13T17:12:19.830Z","5.0.3-rc.1":"2023-07-13T17:19:55.661Z","5.0.3-rc.2":"2023-07-13T17:36:43.966Z","5.0.3":"2023-07-14T11:18:25.235Z","5.0.4":"2023-07-19T15:44:36.453Z","5.0.5":"2023-08-06T21:35:42.130Z","5.0.6":"2023-12-03T02:25:01.154Z"},"maintainers":[{"name":"gabrielvergnaud","email":"gabriel.vergnaud@gmail.com"}],"description":" The exhaustive Pattern Matching library for TypeScript.","homepage":"https://github.com/gvergnaud/ts-pattern#readme","keywords":["pattern","matching","pattern-matching","typescript","match-with","match","switch","adt"],"repository":{"type":"git","url":"git+ssh://git@github.com/gvergnaud/ts-pattern.git"},"author":{"name":"Gabriel Vergnaud"},"bugs":{"url":"https://github.com/gvergnaud/ts-pattern/issues"},"license":"MIT","readme":"<h1 align=\"center\">TS-Pattern</h1>\n\n<p align=\"center\">\nThe exhaustive Pattern Matching library for <a href=\"https://github.com/microsoft/TypeScript\">TypeScript</a>\nwith smart type inference.\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/dm/ts-pattern.svg\" alt=\"downloads\" height=\"18\">\n  </a>\n  <a href=\"https://www.npmjs.com/package/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/v/ts-pattern.svg\" alt=\"npm version\" height=\"18\">\n  </a>\n  <a href=\"https://github.com/gvergnaud/ts-pattern\">\n    <img src=\"https://img.shields.io/npm/l/ts-pattern.svg\" alt=\"MIT license\" height=\"18\">\n  </a>\n</p>\n\n```tsx\nimport { match, P } from 'ts-pattern';\n\ntype Data =\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ntype Result =\n  | { type: 'ok'; data: Data }\n  | { type: 'error'; error: Error };\n\nconst result: Result = ...;\n\nconst html = match(result)\n  .with({ type: 'error' }, () => <p>Oups! An error occured</p>)\n  .with({ type: 'ok', data: { type: 'text' } }, (res) => <p>{res.data.content}</p>)\n  .with({ type: 'ok', data: { type: 'img', src: P.select() } }, (src) => <img src={src} />)\n  .exhaustive();\n```\n\n## About\n\nWrite **better** and **safer conditions**. Pattern matching lets you express complex conditions in a single, compact expression. Your code becomes **shorter** and **more readable**. Exhaustiveness checking ensures you haven’t forgotten **any possible case**.\n\n![ts-pattern](https://user-images.githubusercontent.com/9265418/231688650-7cd957a9-8edc-4db8-a5fe-61e1c2179d91.gif)\n\n<p align=\"center\"><i>Animation by <a target=\"_blank\" href=\"https://twitter.com/nicoespeon/status/1644342570389061634?s=20\">@nicoespeon</a></i></p>\n\n## Features\n\n- Pattern-match on **any data structure**: nested [Objects](#objects), [Arrays](#tuples-arrays), [Tuples](#tuples-arrays), [Sets](#pset-patterns), [Maps](#pmap-patterns) and all primitive types.\n- **Typesafe**, with helpful [type inference](#type-inference).\n- **Exhaustiveness checking** support, enforcing that you are matching every possible case with [`.exhaustive()`](#exhaustive).\n- Use [patterns](#patterns) to **validate** the shape of your data with [`isMatching`](#ismatching).\n- **Expressive API**, with catch-all and type specific **wildcards**: [`P._`](#p_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), etc.\n- Supports [**predicates**](#pwhen-patterns), [**unions**](#punion-patterns), [**intersections**](#pintersection-patterns) and [**exclusion**](#pnot-patterns) patterns for non-trivial cases.\n- Supports properties selection, via the [`P.select(name?)`](#pselect-patterns) function.\n- Tiny bundle footprint ([**only ~2kB**](https://bundlephobia.com/package/ts-pattern)).\n\n## What is Pattern Matching?\n\n[Pattern Matching](https://stackoverflow.com/questions/2502354/what-is-pattern-matching-in-functional-languages) is a code-branching technique coming from functional programming languages that's more powerful and often less verbose than imperative alternatives (if/else/switch statements), especially for complex conditions.\n\nPattern Matching is implemented in Haskell, Rust, Swift, Elixir, and many other languages. There is [a tc39 proposal](https://github.com/tc39/proposal-pattern-matching) to add Pattern Matching to EcmaScript, but it is still in stage 1 and isn't likely to land before several years. Luckily, pattern matching can be implemented in userland. `ts-pattern` Provides a typesafe pattern matching implementation that you can start using today.\n\nRead the introduction blog post: [Bringing Pattern Matching to TypeScript 🎨 Introducing TS-Pattern](https://dev.to/gvergnaud/bringing-pattern-matching-to-typescript-introducing-ts-pattern-v3-0-o1k)\n\n## Installation\n\nVia npm\n\n```\nnpm install ts-pattern\n```\n\nVia yarn\n\n```\nyarn add ts-pattern\n```\n\nVia pnpm\n\n```\npnpm add ts-pattern\n```\n\nVia Bun\n\n```\nbun add ts-pattern\n```\n\n### Compatibility with different TypeScript versions\n\nTS-Pattern assumes that [Strict Mode](https://www.typescriptlang.org/tsconfig#strict) is enabled in your `tsconfig.json` file.\n\n| ts-pattern                                                                                                                                                                              | TypeScript v5+ | TypeScript v4.5+ | TypeScript v4.2+ |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | ---------------- |\n| v5.x [(Docs)](#documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v4-to-v5-migration-guide.md)                                                 | ✅             | ❌               | ❌               |\n| v4.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v4##documentation) [(Migration Guide)](https://github.com/gvergnaud/ts-pattern/tree/master/docs/v3-to-v4-migration-guide.md) | ✅             | ✅               | ❌               |\n| v3.x [(Docs)](https://github.com/gvergnaud/ts-pattern/tree/v3#documentation)                                                                                                            | ✅             | ✅               | ✅               |\n\n- ✅ Full support\n- ❌ Not supported\n\n# Documentation\n\n- [Code Sandbox Examples](#code-sandbox-examples)\n- [Getting Started](#getting-started)\n- [API Reference](#api-reference)\n  - [`match`](#match)\n  - [`.with`](#with)\n  - [`.when`](#when)\n  - [`.returnType`](#returntype)\n  - [`.exhaustive`](#exhaustive)\n  - [`.otherwise`](#otherwise)\n  - [`.run`](#run)\n  - [`isMatching`](#ismatching)\n  - [Patterns](#patterns)\n    - [Literals](#literals)\n    - [Wildcards](#wildcards)\n    - [Objects](#objects)\n    - [Tuples (arrays)](#tuples-arrays)\n    - [Sets](#pset-patterns)\n    - [Maps](#pmap-patterns)\n    - [`P.array` patterns](#parray-patterns)\n    - [`P.when` patterns](#pwhen-patterns)\n    - [`P.not` patterns](#pnot-patterns)\n    - [`P.select` patterns](#pselect-patterns)\n    - [`P.optional` patterns](#poptional-patterns)\n    - [`P.instanceOf` patterns](#pinstanceof-patterns)\n    - [`P.union` patterns](#punion-patterns)\n    - [`P.intersection` patterns](#pintersection-patterns)\n    - [`P.string` predicates](#pstring-predicates)\n    - [`P.number` and `P.bigint` predicates](#pnumber-and-pbigint-predicates)\n  - [Types](#types)\n    - [`P.infer`](#pinfer)\n    - [`P.Pattern`](#pPattern)\n    - [Type inference](#type-inference)\n- [Inspirations](#inspirations)\n\n## Code Sandbox Examples\n\n- [Basic Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/basic.tsx)\n- [React gif fetcher app Demo](https://codesandbox.io/s/ts-pattern-gif-search-demo-v4-bkumdw?file=/src/App.tsx)\n- [React.useReducer Demo](https://codesandbox.io/s/ts-pattern-reducer-example-v4-fx2yqu?file=/src/App.tsx)\n- [Handling untyped API response Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/api.tsx)\n- [`P.when` Guard Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/when.tsx)\n- [`P.not` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/not.tsx)\n- [`P.select` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/select.tsx)\n- [`P.union` Pattern Demo](https://codesandbox.io/s/ts-pattern-examples-v4-bdy5p2?file=/src/examples/union.tsx)\n\n## Getting Started\n\nAs an example, let's create a state reducer for a frontend application that fetches some data.\n\n### Example: a state reducer with ts-pattern\n\nOur application can be in four different states: `idle`, `loading`,\n`success` and `error`. Depending on which state we are in, some events\ncan occur. Here are all the possible types of event our application\ncan respond to: `fetch`, `success`, `error` and `cancel`.\n\nI use the word `event` but you can replace it with `action` if you are used\nto Redux's terminology.\n\n```ts\ntype State =\n  | { status: 'idle' }\n  | { status: 'loading'; startTime: number }\n  | { status: 'success'; data: string }\n  | { status: 'error'; error: Error };\n\ntype Event =\n  | { type: 'fetch' }\n  | { type: 'success'; data: string }\n  | { type: 'error'; error: Error }\n  | { type: 'cancel' };\n```\n\nEven though our application can handle 4 events, **only a subset** of these\nevents **make sense for each given state**. For instance we can only `cancel`\na request if we are currently in the `loading` state.\nTo avoid unwanted state changes that could lead to bugs, we want our state reducer function to branch on **both the state and the event**, and return a new state.\n\nThis is a case where `match` really shines. Instead of writing nested switch statements, we can use pattern matching to simultaneously check the state and the event object:\n\n<!-- prettier-ignore -->\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst reducer = (state: State, event: Event) =>\n  match([state, event])\n    .returnType<State>()\n    .with(\n      [{ status: 'loading' }, { type: 'success' }],\n      ([_, event]) => ({ status: 'success', data: event.data })\n    )\n    .with(\n      [{ status: 'loading' }, { type: 'error', error: P.select() }],\n      (error) => ({ status: 'error', error })\n    )\n    .with(\n      [{ status: P.not('loading') }, { type: 'fetch' }],\n      () => ({ status: 'loading', startTime: Date.now() })\n    )\n    .with(\n      [\n        {\n          status: 'loading',\n          startTime: P.when((t) => t + 2000 < Date.now()),\n        },\n        { type: 'cancel' },\n      ],\n      () => ({ status: 'idle' })\n    )\n    .with(P._, () => state)\n    .exhaustive();\n```\n\nThere's a lot going on, so **let's go through this code bit by bit:**\n\n### match(value)\n\n`match` takes a value and returns a [_builder_](https://en.wikipedia.org/wiki/Builder_pattern) on which you can add your pattern matching cases.\n\n<!-- prettier-ignore -->\n```ts\nmatch([state, event])\n```\n\nIt's also possible to specify the input and output type explicitly with `match<Input, Output>(...)`, but this is usually unnecessary, as TS-Pattern is able to infer them.\n\n### .returnType\\<OutputType\\>()\n\n`.returnType` is an optional method that you can call if you want to force all following code-branches to return a value of a specific type. It takes a single type parameter, provided between `<AngleBrackets>`.\n\n```ts\n  .returnType<State>()\n```\n\nHere, we use this method to make sure all branches return a valid `State` object.\n\n### .with(pattern, handler)\n\nThen we add a first `with` clause:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'success' }],\n    ([state, event]) => ({\n      // `state` is inferred as { status: 'loading' }\n      // `event` is inferred as { type: 'success', data: string }\n      status: 'success',\n      data: event.data,\n    })\n  )\n```\n\nThe first argument is the **pattern**: the **shape of value** you expect for this branch.\n\nThe second argument is the **handler function**: the code **branch** that will be called if the input value matches the pattern.\n\nThe handler function takes the input value as first parameter with its type **narrowed down** to what the pattern matches.\n\n### P.select(name?)\n\nIn the second `with` clause, we use the `P.select` function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error) => ({ status: 'error', error })\n  )\n```\n\n`P.select()` lets you **extract** a piece of your input value and **inject** it into your handler. It is pretty useful when pattern matching on deep data structures because it avoids the hassle of destructuring your input in your handler.\n\nSince we didn't pass any name to `P.select()`, It will inject the `event.error` property as first argument to the handler function. Note that you can still access **the full input value** with its type narrowed by your pattern as **second argument** of the handler function:\n\n```ts\n  .with(\n    [\n      { status: 'loading' },\n      { type: 'error', error: P.select() }\n    ],\n    (error, stateAndEvent) => {\n      // error: Error\n      // stateAndEvent: [{ status: 'loading' }, { type: 'error', error: Error }]\n    }\n  )\n```\n\nIn a pattern, we can only have a **single** anonymous selection. If you need to select more properties on your input data structure, you will need to give them **names**:\n\n```ts\n.with(\n    [\n      { status: 'success', data: P.select('prevData') },\n      { type: 'error', error: P.select('err') }\n    ],\n    ({ prevData, err }) => {\n      // Do something with (prevData: string) and (err: Error).\n    }\n  )\n```\n\nEach named selection will be injected inside a `selections` object, passed as first argument to the handler function. Names can be any strings.\n\n### P.not(pattern)\n\nIf you need to match on everything **but** a specific value, you can use a `P.not(<pattern>)` pattern. it's a function taking a pattern and returning its opposite:\n\n```ts\n  .with(\n    [{ status: P.not('loading') }, { type: 'fetch' }],\n    () => ({ status: 'loading' })\n  )\n```\n\n### `P.when()` and guard functions\n\nSometimes, we need to make sure our input value respects a condition that can't be expressed by a pattern. For example, imagine you need to check that a number is positive. In these cases, we can use **guard functions**: functions taking a value and returning a `boolean`.\n\nWith TS-Pattern, there are two ways to use a guard function:\n\n- use `P.when(<guard function>)` inside one of your patterns\n- pass it as second parameter to `.with(...)`\n\n#### using P.when(predicate)\n\n```ts\n  .with(\n    [\n      {\n        status: 'loading',\n        startTime: P.when((t) => t + 2000 < Date.now()),\n      },\n      { type: 'cancel' },\n    ],\n    () => ({ status: 'idle' })\n  )\n```\n\n#### Passing a guard function to `.with(...)`\n\n`.with` optionally accepts a guard function as second parameter, between\nthe `pattern` and the `handler` callback:\n\n```ts\n  .with(\n    [{ status: 'loading' }, { type: 'cancel' }],\n    ([state, event]) => state.startTime + 2000 < Date.now(),\n    () => ({ status: 'idle' })\n  )\n```\n\nThis pattern will only match if the guard function returns `true`.\n\n### the `P._` wildcard\n\n`P._` will match any value. You can use it either at the top level, or within another pattern.\n\n```ts\n  .with(P._, () => state)\n\n  // You could also use it inside another pattern:\n  .with([P._, P._], () => state)\n\n  // at any level:\n  .with([P._, { type: P._ }], () => state)\n\n```\n\n### .exhaustive(), .otherwise() and .run()\n\n```ts\n  .exhaustive();\n```\n\n`.exhaustive()` **executes** the pattern matching expression, and **returns the result**. It also enables **exhaustiveness checking**, making sure we don't forget any possible case in our input value. This extra type safety is very nice because forgetting a case is an easy mistake to make, especially in an evolving code-base.\n\nNote that exhaustive pattern matching is **optional**. It comes with the trade-off of having slightly **longer compilation times** because the type checker has more work to do.\n\nAlternatively, you can use `.otherwise()`, which takes an handler function returning a default value. `.otherwise(handler)` is equivalent to `.with(P._, handler).exhaustive()`.\n\n```ts\n  .otherwise(() => state);\n```\n\n### Matching several patterns\n\nAs you may know, `switch` statements allow handling several cases with\nthe same code block:\n\n```ts\nswitch (type) {\n  case 'text':\n  case 'span':\n  case 'p':\n    return 'text';\n\n  case 'btn':\n  case 'button':\n    return 'button';\n}\n```\n\nSimilarly, ts-pattern lets you pass several patterns to `.with()` and if\none of these patterns matches your input, the handler function will be called:\n\n```ts\nconst sanitize = (name: string) =>\n  match(name)\n    .with('text', 'span', 'p', () => 'text')\n    .with('btn', 'button', () => 'button')\n    .otherwise(() => name);\n\nsanitize('span'); // 'text'\nsanitize('p'); // 'text'\nsanitize('button'); // 'button'\n```\n\nAs you might expect, this also works with more complex patterns than strings and exhaustiveness checking works as well.\n\n## API Reference\n\n### `match`\n\n```ts\nmatch(value);\n```\n\nCreate a `Match` object on which you can later call `.with`, `.when`, `.otherwise` and `.run`.\n\n#### Signature\n\n```ts\nfunction match<TInput, TOutput>(input: TInput): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `input`\n  - **Required**\n  - the input value your patterns will be tested against.\n\n### `.with`\n\n```ts\nmatch(...)\n  .with(pattern, [...patterns], handler)\n```\n\n#### Signature\n\n```ts\nfunction with(\n  pattern: Pattern<TInput>,\n  handler: (selections: Selections<TInput>, value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for multiple patterns\nfunction with(\n  pattern1: Pattern<TInput>,\n  ...patterns: Pattern<TInput>[],\n  // no selection object is provided when using multiple patterns\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n\n// Overload for guard functions\nfunction with(\n  pattern: Pattern<TInput>,\n  when: (value: TInput) => unknown,\n  handler: (\n    selection: Selection<TInput>,\n    value: TInput\n  ) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<TInput>`\n  - **Required**\n  - The pattern your input must match for the handler to be called.\n  - [See all valid patterns below](#patterns)\n  - If you provide several patterns before providing the `handler`, the `with` clause will match if one of the patterns matches.\n- `when: (value: TInput) => unknown`\n  - Optional\n  - Additional condition the input must satisfy for the handler to be called.\n  - The input will match if your guard function returns a truthy value.\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n- `handler: (selections: Selections<TInput>, value: TInput) => TOutput`\n  - **Required**\n  - Function called when the match conditions are satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n  - `selections` is an object of properties selected from the input with the [`select` function](#select-patterns).\n  - `TInput` might be narrowed to a more precise type using the `pattern`.\n\n### `.when`\n\n```ts\nmatch(...)\n  .when(predicate, handler)\n```\n\n#### Signature\n\n```ts\nfunction when(\n  predicate: (value: TInput) => unknown,\n  handler: (value: TInput) => TOutput\n): Match<TInput, TOutput>;\n```\n\n#### Arguments\n\n- `predicate: (value: TInput) => unknown`\n  - **Required**\n  - Condition the input must satisfy for the handler to be called.\n- `handler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called when the predicate condition is satisfied.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.returnType`\n\n```ts\nmatch(...)\n  .returnType<string>()\n  .with(..., () => \"has to be a string\")\n  .with(..., () => \"Oops\".length)\n  //               ~~~~~~~~~~~~~ ❌ `number` isn't a string!\n```\n\nThe `.returnType<SomeType>()` method allows you to control the return type of all of your branches of code. It accepts a single type parameter that will be used as the return type of your `match` expression. All code branches must return values assignable to this type.\n\n#### Signature\n\n```ts\nfunction returnType<TOutputOverride>(): Match<TInput, TOutputOverride>;\n```\n\n#### Type arguments\n\n- `TOutputOverride`\n  - The type that your `match` expression will return. All branches must return values assignable to it.\n\n### `.exhaustive`\n\n```ts\nmatch(...)\n  .with(...)\n  .exhaustive()\n```\n\nRuns the pattern-matching expression and returns its result. It also enables exhaustiveness checking, making sure at compile time that we have handled all possible cases.\n\n#### Signature\n\n```ts\nfunction exhaustive(): TOutput;\n```\n\n#### Example\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n\nconst fn2 = (org: Plan, user: Permission) =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    .with(['pro', 'editor'], () => {})\n    .exhaustive(); // Works!\n```\n\n### `.otherwise`\n\n```ts\nmatch(...)\n  .with(...)\n  .otherwise(defaultHandler)\n```\n\nRuns the pattern-matching expression with a default handler which will be called if no previous `.with()` clause match the input value, and returns the result.\n\n#### Signature\n\n```ts\nfunction otherwise(defaultHandler: (value: TInput) => TOutput): TOutput;\n```\n\n#### Arguments\n\n- `defaultHandler: (value: TInput) => TOutput`\n  - **Required**\n  - Function called if no pattern matched the input value.\n  - Think of it as the `default:` case of `switch` statements.\n  - All handlers on a single `match` case must return values of the same type, `TOutput`.\n\n### `.run`\n\n```ts\nmatch(...)\n  .with(...)\n  .run()\n```\n\nreturns the result of the pattern-matching expression, or **throws** if no pattern matched the input. `.run()` is similar to `.exhaustive()`, but is **unsafe** because exhaustiveness is not checked at compile time, so you have no guarantees that all cases are indeed covered. Use at your own risks.\n\n#### Signature\n\n```ts\nfunction run(): TOutput;\n```\n\n### `isMatching`\n\n```ts\nif (isMatching(pattern, value))  {\n  ...\n}\n```\n\n`isMatching` is a type guard function which checks if a pattern matches a given value. It is _curried_, which means it can be used in two ways.\n\nWith a single argument:\n\n```ts\nimport { isMatching, P } from 'ts-pattern';\n\nconst isBlogPost = isMatching({\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n});\n\nif (isBlogPost(value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\nWith two arguments:\n\n```ts\nconst blogPostPattern = {\n  type: 'blogpost',\n  title: P.string,\n  description: P.string,\n} as const;\n\nif (isMatching(blogPostPattern, value)) {\n  // value: { type: 'blogpost', title: string, description: string }\n}\n```\n\n#### Signature\n\n```ts\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p\n): (value: any) => value is InvertPattern<p>;\nexport function isMatching<p extends Pattern<any>>(\n  pattern: p,\n  value: any\n): value is InvertPattern<p>;\n```\n\n#### Arguments\n\n- `pattern: Pattern<any>`\n  - **Required**\n  - The pattern a value should match.\n- `value?: any`\n  - **Optional**\n  - if a value is given as second argument, `isMatching` will return a boolean telling us whether the pattern matches the value or not.\n  - if we only give the pattern to the function, `isMatching` will return another **type guard function** taking a value and returning a boolean which tells us whether the pattern matches the value or not.\n\n## Patterns\n\nA pattern is a description of the expected shape of your input value.\n\nPatterns can be regular JavaScript values (`\"some string\"`, `10`, `true`, ...), data structures ([objects](#objects), [arrays](#tuples-arrays), ...), wildcards ([`P._`](#p_-wildcard), [`P.string`](#pstring-wildcard), [`P.number`](#pnumber-wildcard), ...), or special matcher functions ([`P.not`](#pnot-patterns),\n[`P.when`](#pwhen-patterns), [`P.select`](#pselect-patterns), ...).\n\nAll wildcards and matcher functions can be imported either as `Pattern` or as `P` from the `ts-pattern` module.\n\n```ts\nimport { match, Pattern } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(Pattern.string, (str) => str)\n    .with(Pattern.number, (num) => num.toFixed(2))\n    .with(Pattern.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nOr\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst toString = (value: unknown): string =>\n  match(value)\n    .with(P.string, (str) => str)\n    .with(P.number, (num) => num.toFixed(2))\n    .with(P.boolean, (bool) => `${bool}`)\n    .otherwise(() => 'Unknown');\n```\n\nIf your input isn't typed, (if it's a `any` or a `unknown`), you are free to use any possible pattern. Your handler will infer the input type from the shape of your pattern.\n\n### Literals\n\nLiterals are primitive JavaScript values, like `numbers`, `strings`, `booleans`, `bigints`, `symbols`, `null`, `undefined`, or `NaN`.\n\n```ts\nimport { match } from 'ts-pattern';\n\nconst input: unknown = 2;\n\nconst output = match(input)\n  .with(2, () => 'number: two')\n  .with(true, () => 'boolean: true')\n  .with('hello', () => 'string: hello')\n  .with(undefined, () => 'undefined')\n  .with(null, () => 'null')\n  .with(NaN, () => 'number: NaN')\n  .with(20n, () => 'bigint: 20n')\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'number: two'\n```\n\n### Objects\n\nPatterns can be objects containing sub-patterns. An object pattern will match\nIf and only if the input value **is an object**, contains **all properties** the pattern defines\nand each property **matches** the corresponding sub-pattern.\n\n```ts\nimport { match } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'image'; src: string }\n  | { type: 'video'; seconds: number };\n\nlet input: Input = { type: 'user', name: 'Gabriel' };\n\nconst output = match(input)\n  .with({ type: 'image' }, () => 'image')\n  .with({ type: 'video', seconds: 10 }, () => 'video of 10 seconds.')\n  .with({ type: 'user' }, ({ name }) => `user of name: ${name}`)\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'user of name: Gabriel'\n```\n\n### Tuples (arrays)\n\nIn TypeScript, [Tuples](https://en.wikipedia.org/wiki/Tuple) are arrays with a fixed\nnumber of elements that can be of different types. You can pattern-match on tuples\nusing a tuple pattern. A tuple pattern will match if the input value **is an array of the same length**,\nand each item matches the corresponding sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | [number, '+', number]\n  | [number, '-', number]\n  | [number, '*', number]\n  | ['-', number];\n\nconst input: Input = [3, '*', 4];\n\nconst output = match(input)\n  .with([P._, '+', P._], ([x, , y]) => x + y)\n  .with([P._, '-', P._], ([x, , y]) => x - y)\n  .with([P._, '*', P._], ([x, , y]) => x * y)\n  .with(['-', P._], ([, x]) => -x)\n  .otherwise(() => NaN);\n\nconsole.log(output);\n// => 12\n```\n\n### Wildcards\n\n#### `P._` wildcard\n\nThe `P._` pattern will match any value. You can also use `P.any`, which is an alias to `P._`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with(P._, () => 'It will always match')\n  // OR\n  .with(P.any, () => 'It will always match')\n  .otherwise(() => 'This string will never be used');\n\nconsole.log(output);\n// => 'It will always match'\n```\n\n#### `P.string` wildcard\n\nThe `P.string` pattern will match any value of type `string`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 'hello';\n\nconst output = match(input)\n  .with('bonjour', () => 'Won‘t match')\n  .with(P.string, () => 'it is a string!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a string!'\n```\n\n#### `P.number` wildcard\n\nThe `P.number` pattern will match any value of type `number`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 2;\n\nconst output = match<number | string>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a number!'\n```\n\n#### `P.boolean` wildcard\n\nThe `P.boolean` pattern will match any value of type `boolean`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = true;\n\nconst output = match<number | string | boolean>(input)\n  .with(P.string, () => 'it is a string!')\n  .with(P.number, () => 'it is a number!')\n  .with(P.boolean, () => 'it is a boolean!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is a boolean!'\n```\n\n#### `P.nullish` wildcard\n\nThe `P.nullish` pattern will match any value of type `null` or `undefined`.\n\nEven though `null` and `undefined` can be used as literal patterns, sometimes they appear in a union together\n(e.g. `null | undefined | string`) and you may want to treat them as equivalent using `P.nullish`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = null;\n\nconst output = match<number | null | undefined>(input)\n  .with(P.number, () => 'it is a number!')\n  .with(P.nullish, () => 'it is either null or undefined!')\n  .with(null, () => 'it is null!')\n  .with(undefined, () => 'it is undefined!')\n  .exhaustive();\n\nconsole.log(output);\n// => 'it is either null or undefined!'\n```\n\n#### `P.bigint` wildcard\n\nThe `P.bigint` pattern will match any value of type `bigint`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = 20000000n;\n\nconst output = match<bigint | null>(input)\n  .with(P.bigint, () => 'it is a bigint!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a bigint!'\n```\n\n#### `P.symbol` wildcard\n\nThe `P.symbol` pattern will match any value of type `symbol`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nconst input = Symbol('some symbol');\n\nconst output = match<symbol | null>(input)\n  .with(P.symbol, () => 'it is a symbol!')\n  .otherwise(() => '?');\n\nconsole.log(output);\n// => 'it is a symbol!'\n```\n\n### `P.array` patterns\n\nTo match on arrays of unknown size, you can use `P.array(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** in the input\narray match this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { title: string; content: string }[];\n\nlet input: Input = [\n  { title: 'Hello world!', content: 'This is a very interesting content' },\n  { title: 'Bonjour!', content: 'This is a very interesting content too' },\n];\n\nconst output = match(input)\n  .with(\n    P.array({ title: P.string, content: P.string }),\n    (posts) => 'a list of posts!'\n  )\n  .otherwise(() => 'something else');\n\nconsole.log(output);\n// => 'a list of posts!'\n```\n\n### Matching variadic tuples with `P.array`\n\nIn TypeScript, [Variadic Tuple Types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types) are array types created with the `...` spread operator, like `[string, ...string[]]`, `[number, ...boolean[], string]` etc. You can match against variadic tuple types using array literals containing `...P.array(subpattern)`:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = (number | string)[];\n\ndeclare const input: Input;\n\nconst output = match(input)\n  // P.array's parameter is optional\n  .with([P.string, ...P.array()], (input) => input) // input: [string, ...(number | string)[]]\n  .with(['print', ...P.array(P.string)], (input) => input) // input: ['print', ...string[]]\n  // you can put patterns on either side of `...P.array()`:\n  .with([...P.array(P.string), 'end'], (input) => input) // input: [...string[], 'end']\n  .with(['start', ...P.array(P.string), 'end'], (input) => input) // input: ['start', ...string[], 'end']\n  .otherwise((input) => input);\n```\n\n### `P.set` patterns\n\nTo match a Set, you can use `P.set(subpattern)`.\nIt takes a sub-pattern, and will match if **all elements** inside the set\nmatch this sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Set<string | number>;\n\nconst input: Input = new Set([1, 2, 3]);\n\nconst output = match(input)\n  .with(P.set(1), (set) => `Set contains only 1`)\n  .with(P.set(P.string), (set) => `Set contains only strings`)\n  .with(P.set(P.number), (set) => `Set contains only numbers`)\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"Set contains only numbers\"\n```\n\n### `P.map` patterns\n\nTo match a Map, you can use `P.map(keyPattern, valuePattern)`.\nIt takes a subpattern to match against the key, a subpattern to match agains the value, and will match if **all elements** inside this map\nmatch these two sub-patterns.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = Map<string, string | number>;\n\nconst input: Input = new Map([\n  ['a', 1],\n  ['b', 2],\n  ['c', 3],\n]);\n\nconst output = match(input)\n  .with(P.map(P.string, P.number), (map) => `map's type is Map<string, number>`)\n  .with(P.map(P.string, P.string), (map) => `map's type is Map<string, string>`)\n  .with(\n    P.map(P.union('a', 'c'), P.number),\n    (map) => `map's type is Map<'a' | 'c', number>`\n  )\n  .otherwise(() => '');\n\nconsole.log(output);\n// => \"map's type is Map<string, number>\"\n```\n\n### `P.when` patterns\n\n`P.when` lets you define your own logic to check if the pattern should match or not.\nIf the `predicate` function given to when returns a truthy value, then the pattern\nwill match for this input.\n\nNote that you can narrow down the type of your input by providing a\n[Type Guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards) to `P.when`.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { score: number };\n\nconst output = match({ score: 10 })\n  .with(\n    {\n      score: P.when((score): score is 5 => score === 5),\n    },\n    (input) => '😐' // input is inferred as { score: 5 }\n  )\n  .with({ score: P.when((score) => score < 5) }, () => '😞')\n  .with({ score: P.when((score) => score > 5) }, () => '🙂')\n  .run();\n\nconsole.log(output);\n// => '🙂'\n```\n\n### `P.not` patterns\n\n`P.not` lets you match on everything **but** a specific value.\nit's a function taking a pattern and returning the opposite pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = boolean | number;\n\nconst toNumber = (input: Input) =>\n  match(input)\n    .with(P.not(P.boolean), (n) => n) // n: number\n    .with(true, () => 1)\n    .with(false, () => 0)\n    .run();\n\nconsole.log(toNumber(2));\n// => 2\nconsole.log(toNumber(true));\n// => 1\n```\n\n### `P.select` patterns\n\n`P.select` lets you pick a piece of your input data-structure\nand injects it in your handler function.\n\nIt's especially useful when pattern matching on deep data structure to\navoid the hassle of destructuring it in the handler function.\n\nSelections can be either named (with `P.select('someName')`) or anonymous (with `P.select()`).\n\nYou can have only one anonymous selection by pattern, and the selected value will be directly inject in your handler as first argument:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string } }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' } }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select() } },\n      username => username // username: string\n    )\n    .otherwise(() => 'anonymous');\n\nconsole.log(output);\n// => 'Gabriel'\n```\n\nIf you need to select several things inside your input data structure, you can name your selections by giving a string to `P.select(<name>)`. Each selection will be passed as first argument to your handler in an object.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'post'; user: { name: string }, content: string }\n  | { ... };\n\nconst input: Input = { type: 'post', user: { name: 'Gabriel' }, content: 'Hello!' }\n\nconst output = match(input)\n    .with(\n      { type: 'post', user: { name: P.select('name') }, content: P.select('body') },\n      ({ name, body }) => `${name} wrote \"${body}\"`\n    )\n    .otherwise(() => '');\n\nconsole.log(output);\n// => 'Gabriel wrote \"Hello!\"'\n```\n\nYou can also pass a sub-pattern to `P.select` if you want it to only\nselect values which match this sub-pattern:\n\n```ts\ntype User = { age: number; name: string };\ntype Post = { body: string };\ntype Input = { author: User; content: Post };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    {\n      author: P.select({ age: P.number.gt(18) }),\n    },\n    (author) => author // author: User\n  )\n  .with(\n    {\n      author: P.select('author', { age: P.number.gt(18) }),\n      content: P.select(),\n    },\n    ({ author, content }) => author // author: User, content: Post\n  )\n  .otherwise(() => 'anonymous');\n```\n\n### `P.optional` patterns\n\n`P.optional(subpattern)` lets you annotate a key in an object pattern as being optional,\nbut if it is defined it should match a given sub-pattern.\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input = { key?: string | number };\n\nconst output = match(input)\n  .with({ key: P.optional(P.string) }, (a) => {\n    return a.key; // string | undefined\n  })\n  .with({ key: P.optional(P.number) }, (a) => {\n    return a.key; // number | undefined\n  })\n  .exhaustive();\n```\n\n### `P.instanceOf` patterns\n\nThe `P.instanceOf` function lets you build a pattern to check if\na value is an instance of a class:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\nclass A {\n  a = 'a';\n}\nclass B {\n  b = 'b';\n}\n\ntype Input = { value: A | B };\n\nconst input: Input = { value: new A() };\n\nconst output = match(input)\n  .with({ value: P.instanceOf(A) }, (a) => {\n    return 'instance of A!';\n  })\n  .with({ value: P.instanceOf(B) }, (b) => {\n    return 'instance of B!';\n  })\n  .exhaustive();\n\nconsole.log(output);\n// => 'instance of A!'\n```\n\n### `P.union` patterns\n\n`P.union(...subpatterns)` lets you test several patterns and will match if\none of these patterns do. It's particularly handy when you want to handle\nsome cases of a union type in the same code branch:\n\n```ts\nimport { match, P } from 'ts-pattern';\n\ntype Input =\n  | { type: 'user'; name: string }\n  | { type: 'org'; name: string }\n  | { type: 'text'; content: string }\n  | { type: 'img'; src: string };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with({ type: P.union('user', 'org') }, (userOrOrg) => {\n    // userOrOrg: User | Org\n    return userOrOrg.name;\n  })\n  .otherwise(() => '');\n```\n\n### `P.intersection` patterns\n\n`P.intersection(...subpatterns)` lets you ensure that the input matches\n**all** sub-patterns passed as parameters.\n\n```ts\nclass A {\n  constructor(public foo: 'bar' | 'baz') {}\n}\n\nclass B {\n  constructor(public str: string) {}\n}\n\ntype Input = { prop: A | B };\n\ndeclare const input: Input;\n\nconst output = match(input)\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'bar' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'bar' }\n  )\n  .with(\n    { prop: P.intersection(P.instanceOf(A), { foo: 'baz' }) },\n    ({ prop }) => prop.foo // prop: A & { foo: 'baz' }\n  )\n  .otherwise(() => '');\n```\n\n## `P.string` predicates\n\n`P.string` has a number of methods to help you match on specific strings.\n\n### `P.string.startsWith`\n\n`P.string.startsWith(str)` matches strings that start with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.startsWith('TS'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('TS-Pattern')); // logs '🎉'\n```\n\n### `P.string.endsWith`\n\n`P.string.endsWith(str)` matches strings that end with the provided string.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.endsWith('!'), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Hola!')); // logs '🎉'\n```\n\n### `P.string.minLength`\n\n`P.string.minLength(min)` matches strings with at least `min` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.minLength(2), () => '🎉')\n    .otherwise(() => '❌');\n\nconsole.log(fn('two')); // logs '🎉'\n```\n\n### `P.string.maxLength`\n\n`P.string.maxLength(max)` matches strings with at most `max` characters.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.maxLength(5), () => '🎉')\n    .otherwise(() => 'too long');\n\nconsole.log(fn('is this too long?')); // logs 'too long'\n```\n\n### `P.string.includes`\n\n`P.string.includes(str)` matches strings that contain the provided substring.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.includes('!'), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn('Good job! 🎉')); // logs '✅'\n```\n\n### `P.string.regex`\n\n`P.string.regex(RegExp)` matches strings if they match the provided regular expression.\n\n```ts\nconst fn = (input: string) =>\n  match(input)\n    .with(P.string.regex(/^[a-z]+$/), () => 'single word')\n    .otherwise(() => 'other strings');\n\nconsole.log(fn('gabriel')); // logs 'single word'\n```\n\n## `P.number` and `P.bigint` predicates\n\n`P.number` and `P.bigint` have several of methods to help you match on specific numbers and bigints.\n\n### `P.number.between`\n\n`P.number.between(min, max)` matches numbers between `min` and `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.between(1, 5), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(3), fn(1), fn(5), fn(7)); // logs '✅ ✅ ✅ ❌'\n```\n\n### `P.number.lt`\n\n`P.number.lt(max)` matches numbers smaller than `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(2), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.gt`\n\n`P.number.gt(min)` matches numbers greater than `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gt(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(7)); // logs '✅ ❌'\n```\n\n### `P.number.lte`\n\n`P.number.lte(max)` matches numbers smaller than or equal to `max`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.lte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(12)); // logs '✅ ❌'\n```\n\n### `P.number.gte`\n\n`P.number.gte(min)` matches numbers greater than or equal to `min`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.gte(7), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(2)); // logs '✅ ❌'\n```\n\n### `P.number.int`\n\n`P.number.int()` matches integers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.int(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(12), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.finite`\n\n`P.number.finite()` matches all numbers except `Infinity` and `-Infinity`.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.finite(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(Infinity)); // logs '✅ ❌'\n```\n\n### `P.number.positive`\n\n`P.number.positive()` matches positive numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.positive(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(7), fn(-3.141592)); // logs '✅ ❌'\n```\n\n### `P.number.negative`\n\n`P.number.negative()` matches negative numbers.\n\n```ts\nconst fn = (input: number) =>\n  match(input)\n    .with(P.number.negative(), () => '✅')\n    .otherwise(() => '❌');\n\nconsole.log(fn(-3.141592), fn(7)); // logs '✅ ❌'\n```\n\n## Types\n\n### `P.infer`\n\n`P.infer<typeof somePattern>` lets you infer a type of value from a type of pattern.\n\nIt's particularly useful when validating an API response.\n\n```ts\nconst postPattern = {\n  title: P.string,\n  content: P.string,\n  stars: P.number.between(1, 5).optional(),\n  author: {\n    firstName: P.string,\n    lastName: P.string.optional(),\n    followerCount: P.number,\n  },\n} as const;\n\ntype Post = P.infer<typeof postPattern>;\n\n// posts: Post[]\nconst posts = await fetch(someUrl)\n  .then((res) => res.json())\n  .then((res: unknown): Post[] =>\n    isMatching({ data: P.array(postPattern) }, res) ? res.data : []\n  );\n```\n\nAlthough not strictly necessary, using `as const` after the pattern definition ensures that TS-Pattern infers the most precise types possible.\n\n### `P.narrow`\n\n`P.narrow<Input, typeof Pattern>` will narrow the input type to only keep the set of values that are compatible with the provided pattern type.\n\n```ts\ntype Input = ['a' | 'b' | 'c', 'a' | 'b' | 'c'];\nconst Pattern = ['a', P.union('a', 'b')] as const;\n\ntype Narrowed = P.narrow<Input, typeof Pattern>;\n//     ^? ['a', 'a' | 'b']\n```\n\nNote that most of the time, the `match` and `isMatching` functions perform narrowing for you, and you do not need to narrow types yourself.\n\n### `P.Pattern`\n\n`P.Pattern<T>` is the type of all possible pattern for a generic type `T`.\n\n```ts\ntype User = { name: string; age: number };\n\nconst userPattern: Pattern<User> = {\n  name: 'Alice',\n};\n```\n\n### Type inference\n\nTS-Pattern takes advantage of some of the most advanced features of the type system to narrow the input type using the current pattern. It is also able to accurately know if you have handled all cases, even when matching on complex data-structures.\n\nHere are some examples of TS-Pattern's inference features.\n\n#### Type narrowing\n\nIf you pattern-match on a union type with a discriminant property, TS-Pattern will use this discriminant to narrow the type of input.\n\n```ts\ntype Text = { type: 'text'; data: string };\ntype Img = { type: 'img'; data: { src: string; alt: string } };\ntype Video = { type: 'video'; data: { src: string; format: 'mp4' | 'webm' } };\ntype Content = Text | Img | Video;\n\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with({ type: 'text' }, (text /* : Text */) => '<p>...</p>')\n    .with({ type: 'img' }, (img /* : Img */) => '<img ... />')\n    .with({ type: 'video' }, (video /* : Video */) => '<video ... />')\n    .with(\n      { type: 'img' },\n      { type: 'video' },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .with(\n      { type: P.union('img', 'video') },\n      (video /* : Img | Video */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf you use `P.select`, TS-Pattern will pick up the type of the property you selected, and will inferyour handler's type accordingly.\n\n```ts\nconst formatContent = (content: Content): string =>\n  match(content)\n    .with(\n      { type: 'text', data: P.select() },\n      (content /* : string */) => '<p>...</p>'\n    )\n    .with(\n      { type: 'video', data: { format: P.select() } },\n      (format /* : 'mp4' | 'webm' */) => '<video ... />'\n    )\n    .with(\n      { type: P.union('img', 'video'), data: P.select() },\n      (data /* : Img['data'] | Video['data'] */) => 'img or video'\n    )\n    .exhaustive();\n```\n\nIf the function given to `P.when` is a [Type Guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates), TS-Pattern will use the type guard's return type to narrow the input.\n\n```ts\nconst isString = (x: unknown): x is string => typeof x === 'string';\n\nconst isNumber = (x: unknown): x is number => typeof x === 'number';\n\nconst fn = (input: { id: number | string }) =>\n  match(input)\n    .with({ id: P.when(isString) }, (narrowed /* : { id: string } */) => 'yes')\n    .with({ id: P.when(isNumber) }, (narrowed /* : { id: number } */) => 'yes')\n    .exhaustive();\n```\n\n#### Exhaustiveness checking\n\nIf your data structure contains several union types, you can pattern-match on several of them with a **single pattern**. TS-Pattern will keep track of the cases which have been handled and those which\nhaven't, so you never forget to handle a case.\n\n```ts\ntype Permission = 'editor' | 'viewer';\ntype Plan = 'basic' | 'pro';\n\nconst fn = (org: Plan, user: Permission): string =>\n  match([org, user])\n    .with(['basic', 'viewer'], () => {})\n    .with(['basic', 'editor'], () => {})\n    .with(['pro', 'viewer'], () => {})\n    // Fails with `NonExhaustiveError<['pro', 'editor']>`\n    // because the `['pro', 'editor']` case isn't handled.\n    .exhaustive();\n```\n\n## Want to learn how TS-Pattern is built?\n\nCheck out 👉 [Type-Level TypeScript](https://type-level-typescript.com/), an online course to learn how to take full advantage of the most advanced features of TypeScript!\n\n## Inspirations\n\nThis library has been heavily inspired by this great article by Wim Jongeneel:\n[Pattern Matching in TypeScript with Record and Wildcard Patterns](https://medium.com/swlh/pattern-matching-in-typescript-with-record-and-wildcard-patterns-6097dd4e471d).\nIt made me realize pattern matching could be implemented in userland and we didn't have\nto wait for it to be added to the language itself. I'm really grateful for that 🙏\n","readmeFilename":"README.md","users":{"flumpus-dev":true}}